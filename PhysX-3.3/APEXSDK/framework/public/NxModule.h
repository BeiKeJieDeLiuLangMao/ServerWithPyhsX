/*
 * Copyright (c) 2008-2015, NVIDIA CORPORATION.  All rights reserved.
 *
 * NVIDIA CORPORATION and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA CORPORATION is strictly prohibited.
 */


#ifndef NX_MODULE_H
#define NX_MODULE_H

/*!
\file
\brief APEX Module API
*/

#include "NxApexInterface.h"
#include "NxApexSDK.h"
#include "foundation/PxSimpleTypes.h"

namespace physx
{
namespace apex
{

PX_PUSH_PACK_DEFAULT

class NxApexRenderableIterator;

/**
\brief Render lock modes.  These are used per-module to determine how render locking is done.
*/
struct NxApexRenderLockMode
{
	/**
	\brief Enum of render lock modes
	*/
	enum Enum
	{
		/**
		\brief	Disables render locking in the module scene.
		*/
		NO_RENDER_LOCK					= 0,

		/**
		\brief	Locks all apex actors in the module scene individually.
		*/
		PER_ACTOR_RENDER_LOCK			= 1,

		/**
		\brief	Locks an entire module scene with one lock.
		*/
		PER_MODULE_SCENE_RENDER_LOCK	= 2,
	};
};

/**
\brief A structure that holds two templated values, a min and a max
*/
template <typename T>
struct NxRange
{
	NxRange() {};
	/**
	\brief Constructor, sets min amd max values
	*/
	NxRange(T inMin, T inMax) : minimum(inMin), maximum(inMax) {};

	/**
	\brief operator ==
	*/
	bool operator== (const NxRange& r) const
	{
		return minimum == r.minimum && maximum == r.maximum;
	}

	/**
	\brief Minimal value
	*/
	T minimum;
	/**
	\brief Maximal value
	*/
	T maximum;
};


/**
\brief A named parameter with a range of possible integer values
*/
struct NxApexParameter
{
	NxApexParameter() : name(NULL), current(0) {};

	/**
	\brief Constructor, sets name, range and current value
	*/
	NxApexParameter(const char* inName, NxRange<physx::PxU32> inRange) : name(inName), range(inRange), current(inRange.minimum) {}

	/**
	\brief Name of the parameter
	*/
	const char* name;

	/**
	\brief Range for the parameter value
	*/
	NxRange<physx::PxU32> range;

	/**
	\brief Range for the parameter value
	*/
	physx::PxU32 current;
};

/**
\brief Scales a value from one range to another
*/
class NxInterpolator
{
public:
	/**
	\brief Scales a value from one range to another
	*/
	virtual physx::PxF32 interpolate(physx::PxF32 inCurrent, physx::PxF32 inMin, physx::PxF32 inMax, physx::PxF32 outMin, physx::PxF32 outMax) = 0;
};


/**
\brief base class of all APEX modules

It describes the LODParameters and weights defined by the module.
*/
class NxModule : public NxApexInterface
{
public:
	/**
	\brief Initialize the module
	\param[in] desc use NxModule::getDefaultModuleDesc() to get the descriptor necessary for initializing the module
	*/
	virtual void init(::NxParameterized::Interface& desc) = 0;

	/**
	\brief Returns the name of the module
	*/
	virtual const char* getName() const = 0;

	/**
	\brief Returns the unique ID of the module
	*/
	virtual NxAuthObjTypeID getModuleID() const = 0;

	/**
	\brief Returns the number of parameters of this module
	*/
	virtual physx::PxU32 getNbParameters() const = 0;

	/**
	\brief Returns an array of parameters.
	*/
	virtual NxApexParameter** getParameters() = 0;

	/**
	\brief Returns the NxParameterized interface that contains module initialization parameters
	\note The module itself owns this object, so there's no need for the application to destroy it
	*/
	virtual ::NxParameterized::Interface* getDefaultModuleDesc()
	{
		return NULL;
	}

	/**
	\brief Set a parameter

	Directly sets the current value of the parameter with the given index, bypassing
	any configuration manager.
	*/
	virtual void setIntValue(physx::PxU32 parameterIndex, physx::PxU32 value) = 0;

	/**
	\brief Allocate a renderable iterator

	Returns an NxApexRenderable iterator instance for the specified NxApexScene.  The iterator
	will return pointers to renderables in this scene that were generated by this module. This
	is the preferred method for rendering IOFX actors.
	*/
	virtual NxApexRenderableIterator* createRenderableIterator(const NxApexScene&) = 0;

	/**
	\brief Get the cost of one LOD aspect unit.
	*/
	virtual physx::PxF32 getLODUnitCost() const = 0;

	/**
	\brief Set the cost of one LOD aspect unit.
	*/
	virtual void setLODUnitCost(physx::PxF32) = 0;

	/**
	\brief Get the resource value of one unit of benefit.
	*/
	virtual physx::PxF32 getLODBenefitValue() const = 0;

	/**
	\brief Set the resource value of one unit of benefit.
	*/
	virtual void setLODBenefitValue(physx::PxF32) = 0;

	/**
	\brief Get enabled/disabled state of automatic LOD system.
	*/
	virtual bool getLODEnabled() const = 0;

	/**
	\brief Set enabled/disabled state of automatic LOD system.
	*/
	virtual void setLODEnabled(bool) = 0;

	/**
	\brief Choose the locking mode for the module scene.  See NxApexRenderLockMode.

	Returns true if successful.
	*/
	virtual bool setRenderLockMode(NxApexRenderLockMode::Enum, NxApexScene&) { return false; }

	/**
	\brief Returns the current render lock mode for the module scene.
	*/
	virtual NxApexRenderLockMode::Enum getRenderLockMode(const NxApexScene&) const { return NxApexRenderLockMode::NO_RENDER_LOCK; }

	/**
	\brief Sets a render lock for the module scene.  Used when the SDK render lock mode is NxApexRenderLockMode::PER_MODULE_SCENE_RENDER_LOCK.  See NxApexSDK::setRenderLockMode().
	
	Returns true iff successful.
	*/
	virtual	bool lockModuleSceneRenderLock(NxApexScene&) { return false; }

	/**
	\brief Releases the render lock for the module scene.  See lockModuleSceneRenderLock().

	Returns true iff successful.
	*/
	virtual	bool unlockModuleSceneRenderLock(NxApexScene&) { return false; }
};

PX_POP_PACK

}
} // end namespace physx::apex

#endif // NX_MODULE_H
