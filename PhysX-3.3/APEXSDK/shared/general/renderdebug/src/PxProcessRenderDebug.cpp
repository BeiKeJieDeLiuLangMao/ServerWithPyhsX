/*
 * Copyright (c) 2008-2015, NVIDIA CORPORATION.  All rights reserved.
 *
 * NVIDIA CORPORATION and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA CORPORATION is strictly prohibited.
 */


#include "PxProcessRenderDebug.h"
#include "PsUserAllocated.h"
#include "PsMathUtils.h"
#include "PxMemoryBuffer.h"
#include "PxIOStream.h"

#pragma warning(disable:4100)

#ifdef WITHOUT_DEBUG_VISUALIZE

namespace physx
{
namespace general_renderdebug4
{

PxProcessRenderDebug * createProcessRenderDebug(void)
{
	return NULL;
}

}
};


#else

namespace physx
{
namespace general_renderdebug4
{

class PxProcessRenderDebugHelper
{
public:
	virtual void indirectDebugLine(const PxVec3 &p1,const PxVec3 &p2) = 0;
};

const PxVec3 debug_point[6] =
{
	PxVec3(-1.0f, 0.0f, 0.0f),  PxVec3(1.0f, 0.0f, 0.0f),
	PxVec3(0.0f,-1.0f, 0.0f),  PxVec3(0.0f, 1.0f, 0.0f),
	PxVec3(0.0f, 0.0f,-1.0f),  PxVec3(0.0f, 0.0f, 1.0f)
};

// simple sphere, uses subdivision to enhance...
static PxVec3 simpleSpherePosition[6] =
{
	PxVec3( 1.0f, 0.0f, 0.0f),
	PxVec3(-1.0f, 0.0f, 0.0f),
	PxVec3( 0.0f, 1.0f, 0.0f),
	PxVec3( 0.0f,-1.0f, 0.0f),
	PxVec3( 0.0f, 0.0f, 1.0f),
	PxVec3( 0.0f, 0.0f,-1.0f),
};

static PxU32 simpleSphereIndices[8*3] =
{
	0, 2, 4,
	1, 4, 2,
	0, 5, 2,
	1, 2, 5,

	0, 4, 3,
	1, 3, 4,
	0, 3, 5,
	1, 5, 3,
};


const PxF32 FM_PI = 3.1415926535897932384626433832795028841971693993751f;
const PxF32 FM_DEG_TO_RAD = ((2.0f * FM_PI) / 360.0f);
//const PxF32 FM_RAD_TO_DEG = (360.0f / (2.0f * FM_PI));

PX_INLINE void pxVec3FromArray(PxVec3 &p,const PxF32 *pos)
{
	p.x = pos[0];
	p.y = pos[1];
	p.z = pos[2];
}


PX_INLINE void rotationArc(const PxVec3 &v0,const PxVec3 &v1,PxQuat &quat)
{
	PxVec3 cross = v0.cross(v1);
	PxF32 d = v0.dot(v1);

	if(d<=-1.0f) // 180 about x axis
	{
		quat.x = 1.0f;
		quat.y = quat.z = quat.w =0.0f;
		return;
	}

	PxF32 s = PxSqrt((1+d)*2);
	PxF32 recip = 1.0f / s;

	quat.x = cross.x * recip;
	quat.y = cross.y * recip;
	quat.z = cross.z * recip;
	quat.w = s * 0.5f;

}

/*const PxF32 debug_sphere[32*9] =
{
	0.0000f, 0.0000f, 1.0000f,    0.7071f, 0.0000f, 0.7071f,  0.0000f, 0.7071f, 0.7071f,
	0.7071f, 0.0000f, 0.7071f,    1.0000f, 0.0000f, 0.0000f,  0.7071f, 0.7071f, 0.0000f,
	0.7071f, 0.0000f, 0.7071f,    0.7071f, 0.7071f, 0.0000f,  0.0000f, 0.7071f, 0.7071f,
	0.0000f, 0.7071f, 0.7071f,    0.7071f, 0.7071f, 0.0000f,  0.0000f, 1.0000f, 0.0000f,
	0.0000f, 0.0000f, 1.0000f,    0.0000f, 0.7071f, 0.7071f,  -0.7071f, 0.0000f, 0.7071f,
	0.0000f, 0.7071f, 0.7071f,    0.0000f, 1.0000f, 0.0000f,  -0.7071f, 0.7071f, 0.0000f,
	0.0000f, 0.7071f, 0.7071f,    -0.7071f, 0.7071f, 0.0000f,  -0.7071f, 0.0000f, 0.7071f,
	-0.7071f, 0.0000f, 0.7071f,    -0.7071f, 0.7071f, 0.0000f,  -1.0000f, 0.0000f, 0.0000f,
	0.0000f, 0.0000f, 1.0000f,    -0.7071f, 0.0000f, 0.7071f,  0.0000f, -0.7071f, 0.7071f,
	-0.7071f, 0.0000f, 0.7071f,    -1.0000f, 0.0000f, 0.0000f,  -0.7071f, -0.7071f, 0.0000f,
	-0.7071f, 0.0000f, 0.7071f,    -0.7071f, -0.7071f, 0.0000f,  0.0000f, -0.7071f, 0.7071f,
	0.0000f, -0.7071f, 0.7071f,    -0.7071f, -0.7071f, 0.0000f,  0.0000f, -1.0000f, 0.0000f,
	0.0000f, 0.0000f, 1.0000f,    0.0000f, -0.7071f, 0.7071f,  0.7071f, 0.0000f, 0.7071f,
	0.0000f, -0.7071f, 0.7071f,    0.0000f, -1.0000f, 0.0000f,  0.7071f, -0.7071f, 0.0000f,
	0.0000f, -0.7071f, 0.7071f,    0.7071f, -0.7071f, 0.0000f,  0.7071f, 0.0000f, 0.7071f,
	0.7071f, 0.0000f, 0.7071f,    0.7071f, -0.7071f, 0.0000f,  1.0000f, 0.0000f, 0.0000f,
	0.0000f, 0.0000f, -1.0000f,    0.0000f, 0.7071f, -0.7071f,  0.7071f, 0.0000f, -0.7071f,
	0.0000f, 0.7071f, -0.7071f,    0.0000f, 1.0000f, 0.0000f,  0.7071f, 0.7071f, 0.0000f,
	0.0000f, 0.7071f, -0.7071f,    0.7071f, 0.7071f, 0.0000f,  0.7071f, 0.0000f, -0.7071f,
	0.7071f, 0.0000f, -0.7071f,    0.7071f, 0.7071f, 0.0000f,  1.0000f, 0.0000f, 0.0000f,
	0.0000f, 0.0000f, -1.0000f,    -0.7071f, 0.0000f, -0.7071f,  0.0000f, 0.7071f, -0.7071f,
	-0.7071f, 0.0000f, -0.7071f,    -1.0000f, 0.0000f, 0.0000f,  -0.7071f, 0.7071f, 0.0000f,
	-0.7071f, 0.0000f, -0.7071f,    -0.7071f, 0.7071f, 0.0000f,  0.0000f, 0.7071f, -0.7071f,
	0.0000f, 0.7071f, -0.7071f,    -0.7071f, 0.7071f, 0.0000f,  0.0000f, 1.0000f, 0.0000f,
	0.0000f, 0.0000f, -1.0000f,    0.0000f, -0.7071f, -0.7071f,  -0.7071f, 0.0000f, -0.7071f,
	0.0000f, -0.7071f, -0.7071f,    0.0000f, -1.0000f, 0.0000f,  -0.7071f, -0.7071f, 0.0000f,
	0.0000f, -0.7071f, -0.7071f,    -0.7071f, -0.7071f, 0.0000f,  -0.7071f, 0.0000f, -0.7071f,
	-0.7071f, 0.0000f, -0.7071f,    -0.7071f, -0.7071f, 0.0000f,  -1.0000f, 0.0000f, 0.0000f,
	0.0000f, 0.0000f, -1.0000f,    0.7071f, 0.0000f, -0.7071f,  0.0000f, -0.7071f, -0.7071f,
	0.7071f, 0.0000f, -0.7071f,    1.0000f, 0.0000f, 0.0000f,  0.7071f, -0.7071f, 0.0000f,
	0.7071f, 0.0000f, -0.7071f,    0.7071f, -0.7071f, 0.0000f,  0.0000f, -0.7071f, -0.7071f,
	0.0000f, -0.7071f, -0.7071f,    0.7071f, -0.7071f, 0.0000f,  0.0000f, -1.0000f, 0.0000f,
};*/



//   font info:
//
//Peter Holzmann, Octopus Enterprises
//USPS: 19611 La Mar Court, Cupertino, CA 95014
//UUCP: {hplabs!hpdsd,pyramid}!octopus!pete
//Phone: 408/996-7746
//
//This distribution is made possible through the collective encouragement
//of the Usenet Font Consortium, a mailing list that sprang to life to get
//this accomplished and that will now most likely disappear into the mists
//of time... Thanks are especially due to Jim Hurt, who provided the packed
//font data for the distribution, along with a lot of other help.
//
//This file describes the Hershey Fonts in general, along with a description of
//the other files in this distribution and a simple re-distribution restriction.
//
//USE RESTRICTION:
//        This distribution of the Hershey Fonts may be used by anyone for
//        any purpose, commercial or otherwise, providing that:
//                1. The following acknowledgements must be distributed with
//                        the font data:
//                        - The Hershey Fonts were originally created by Dr.
//                                A. V. Hershey while working at the U. S.
//                                National Bureau of Standards.
//                        - The format of the Font data in this distribution
//                                was originally created by
//                                        James Hurt
//                                        Cognition, Inc.
//                                        900 Technology Park Drive
//                                        Billerica, MA 01821
//                                        (mit-eddie!ci-dandelion!hurt)
//                2. The font data in this distribution may be converted into
//                        any other format *EXCEPT* the format distributed by
//                        the U.S. NTIS (which organization holds the rights
//                        to the distribution and use of the font data in that
//                        particular format). Not that anybody would really
//                        *want* to use their format... each point is described
//                        in eight bytes as "xxx yyy:", where xxx and yyy are
//                        the coordinate values as ASCII numbers.


PxU8 g_font[6350] = {
  0x46,0x4F,0x4E,0x54,0x01,0x00,0x00,0x00,0x43,0x01,0x00,0x00,0x5E,0x00,0x00,0x00,0xC4,0x06,0x00,0x00,0x0A,0xD7,0x23,0x3C,0x3D,0x0A,0x57,0x3E,0x0A,0xD7,0x23,0x3C,
  0x28,0x5C,0x8F,0x3D,0x0A,0xD7,0x23,0x3C,0x08,0xD7,0xA3,0x3C,0x00,0x00,0x00,0x00,0x08,0xD7,0x23,0x3C,0x0A,0xD7,0x23,0x3C,0x00,0x00,0x00,0x00,0x0A,0xD7,0xA3,0x3C,
  0x08,0xD7,0x23,0x3C,0x00,0x00,0x00,0x00,0x3D,0x0A,0x57,0x3E,0x00,0x00,0x00,0x00,0x28,0x5C,0x0F,0x3E,0x0A,0xD7,0xA3,0x3D,0x3D,0x0A,0x57,0x3E,0x0A,0xD7,0xA3,0x3D,
  0x28,0x5C,0x0F,0x3E,0x0A,0xD7,0xA3,0x3D,0x00,0x00,0x80,0x3E,0x0C,0xD7,0x23,0x3C,0x29,0x5C,0x8F,0xBD,0x29,0x5C,0x0F,0x3E,0x00,0x00,0x80,0x3E,0x29,0x5C,0x8F,0x3D,
  0x29,0x5C,0x8F,0xBD,0x0C,0xD7,0x23,0x3C,0x8F,0xC2,0xF5,0x3D,0x9A,0x99,0x19,0x3E,0x8F,0xC2,0xF5,0x3D,0x00,0x00,0x00,0x00,0x8E,0xC2,0x75,0x3D,0x29,0x5C,0x0F,0x3E,
  0x8E,0xC2,0x75,0x3D,0xCD,0xCC,0x4C,0x3D,0x00,0x00,0x80,0x3E,0xCD,0xCC,0x4C,0x3D,0x0A,0xD7,0x23,0xBD,0xEC,0x51,0xB8,0x3D,0x00,0x00,0x80,0x3E,0xEC,0x51,0xB8,0x3D,
  0x0A,0xD7,0x23,0xBD,0x29,0x5C,0x0F,0x3E,0xEB,0x51,0x38,0x3E,0x8F,0xC2,0xF5,0x3D,0xCC,0xCC,0x4C,0x3E,0xEC,0x51,0xB8,0x3D,0x3D,0x0A,0x57,0x3E,0xCD,0xCC,0x4C,0x3D,
  0x3D,0x0A,0x57,0x3E,0x0C,0xD7,0xA3,0x3C,0xCC,0xCC,0x4C,0x3E,0x00,0x00,0x00,0x00,0xEB,0x51,0x38,0x3E,0x00,0x00,0x00,0x00,0x0A,0xD7,0x23,0x3E,0x0C,0xD7,0x23,0x3C,
  0x28,0x5C,0x0F,0x3E,0x0C,0xD7,0xA3,0x3C,0xB8,0x1E,0x05,0x3E,0x0A,0xD7,0x23,0x3D,0x8F,0xC2,0xF5,0x3D,0xCD,0xCC,0xCC,0x3D,0xCC,0xCC,0xCC,0x3D,0x8F,0xC2,0xF5,0x3D,
  0xEB,0x51,0xB8,0x3D,0xB8,0x1E,0x05,0x3E,0x0A,0xD7,0xA3,0x3D,0x29,0x5C,0x0F,0x3E,0x8E,0xC2,0xF5,0x3C,0x8F,0xC2,0xF5,0x3D,0x08,0xD7,0x23,0x3C,0xEC,0x51,0xB8,0x3D,
  0x00,0x00,0x00,0x00,0xCD,0xCC,0x4C,0x3D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8E,0xC2,0xF5,0x3C,0xEB,0x51,0x38,0x3E,0x3D,0x0A,0x57,0x3E,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x28,0x5C,0x8F,0x3D,0x5C,0x8F,0x42,0x3E,0x28,0x5C,0x8F,0x3D,0x7A,0x14,0x2E,0x3E,0x8E,0xC2,0x75,0x3D,0x99,0x99,0x19,0x3E,0x0A,0xD7,0x23,0x3D,
  0x28,0x5C,0x0F,0x3E,0x08,0xD7,0xA3,0x3C,0x28,0x5C,0x0F,0x3E,0x08,0xD7,0x23,0x3C,0xCC,0xCC,0x4C,0x3E,0x8E,0xC2,0xF5,0x3C,0x3D,0x0A,0x57,0x3E,0x28,0x5C,0x8F,0x3D,
  0xCC,0xCC,0x4C,0x3E,0xCC,0xCC,0xCC,0x3D,0x5C,0x8F,0x42,0x3E,0xB8,0x1E,0x05,0x3E,0x5C,0x8F,0x42,0x3E,0x0A,0xD7,0x23,0x3E,0xCC,0xCC,0x4C,0x3E,0x28,0x5C,0x0F,0x3E,
  0x28,0x5C,0x8F,0x3D,0x8F,0xC2,0xF5,0x3D,0x8E,0xC2,0x75,0x3D,0xAE,0x47,0xE1,0x3D,0x0A,0xD7,0x23,0x3D,0xAE,0x47,0xE1,0x3D,0x08,0xD7,0xA3,0x3C,0xB8,0x1E,0x05,0x3E,
  0x00,0x00,0x00,0x00,0x99,0x99,0x19,0x3E,0x00,0x00,0x00,0x00,0x7A,0x14,0x2E,0x3E,0x08,0xD7,0x23,0x3C,0xEB,0x51,0x38,0x3E,0x8E,0xC2,0xF5,0x3C,0xEB,0x51,0x38,0x3E,
  0xCC,0xCC,0x4C,0x3D,0x0A,0xD7,0x23,0x3E,0x28,0x5C,0x8F,0x3D,0xCC,0xCC,0x4C,0x3E,0x8F,0xC2,0xF5,0x3D,0xCC,0xCC,0x4C,0x3E,0xB8,0x1E,0x05,0x3E,0x5C,0x8F,0x42,0x3E,
  0x28,0x5C,0x0F,0x3E,0xEB,0x51,0x38,0x3E,0x28,0x5C,0x0F,0x3E,0x7A,0x14,0x2E,0x3E,0xB8,0x1E,0x05,0x3E,0x0A,0xD7,0x23,0x3E,0xAE,0x47,0xE1,0x3D,0x8E,0xC2,0xF5,0x3D,
  0x8E,0xC2,0xF5,0x3C,0xCC,0xCC,0xCC,0x3D,0x08,0xD7,0x23,0x3C,0x0A,0xD7,0xA3,0x3D,0x00,0x00,0x00,0x00,0x09,0xD7,0x23,0x3D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x0A,0xD7,0x23,0x3D,0x08,0xD7,0x23,0x3C,0x0A,0xD7,0xA3,0x3D,0x08,0xD7,0xA3,0x3C,0xEB,0x51,0xB8,0x3D,0xEB,0x51,0xB8,0x3D,0xB8,0x1E,0x05,0x3E,0xCC,0xCC,0xCC,0x3D,
  0x28,0x5C,0x0F,0x3E,0xAD,0x47,0xE1,0x3D,0x0A,0xD7,0x23,0x3E,0xAD,0x47,0xE1,0x3D,0xEB,0x51,0x38,0x3E,0xCC,0xCC,0xCC,0x3D,0xCC,0xCC,0x4C,0x3E,0x8E,0xC2,0x75,0x3D,
  0xCC,0xCC,0x4C,0x3E,0xCC,0xCC,0x4C,0x3D,0xEB,0x51,0x38,0x3E,0xCC,0xCC,0x4C,0x3D,0x0A,0xD7,0x23,0x3E,0x8E,0xC2,0x75,0x3D,0xB8,0x1E,0x05,0x3E,0x0A,0xD7,0xA3,0x3D,
  0xCC,0xCC,0xCC,0x3D,0xB8,0x1E,0x05,0x3E,0x8E,0xC2,0xF5,0x3C,0x99,0x99,0x19,0x3E,0x08,0xD7,0x23,0x3C,0x7A,0x14,0x2E,0x3E,0x00,0x00,0x00,0x00,0x0A,0xD7,0x23,0x3C,
  0x5C,0x8F,0x42,0x3E,0x00,0x00,0x00,0x00,0xCC,0xCC,0x4C,0x3E,0x0A,0xD7,0xA3,0x3C,0xEB,0x51,0x38,0x3E,0x0A,0xD7,0x23,0x3C,0x0A,0xD7,0x23,0x3E,0x00,0x00,0x00,0x00,
  0x99,0x99,0x19,0x3E,0x29,0x5C,0x8F,0x3D,0x00,0x00,0x80,0x3E,0xCC,0xCC,0x4C,0x3D,0x1E,0x85,0x6B,0x3E,0x8F,0xC2,0xF5,0x3C,0xCC,0xCC,0x4C,0x3E,0x00,0x00,0x00,0x00,
  0xAE,0x47,0xE1,0x3D,0x00,0x00,0x00,0x00,0x28,0x5C,0x8F,0x3D,0x8F,0xC2,0xF5,0x3C,0x0C,0xD7,0xA3,0xBC,0xCC,0xCC,0x4C,0x3D,0xCE,0xCC,0x4C,0xBD,0x00,0x00,0x00,0x00,
  0x00,0x00,0x80,0x3E,0x0A,0xD7,0xA3,0x3C,0x1E,0x85,0x6B,0x3E,0x0A,0xD7,0x23,0x3D,0xCC,0xCC,0x4C,0x3E,0x8F,0xC2,0x75,0x3D,0x0A,0xD7,0x23,0x3E,0x29,0x5C,0x8F,0x3D,
  0xAE,0x47,0xE1,0x3D,0x29,0x5C,0x8F,0x3D,0x28,0x5C,0x8F,0x3D,0x8F,0xC2,0x75,0x3D,0x08,0xD7,0xA3,0x3C,0x0A,0xD7,0x23,0x3D,0x0C,0xD7,0xA3,0xBC,0x0A,0xD7,0xA3,0x3C,
  0xCE,0xCC,0x4C,0xBD,0x00,0x00,0x00,0x00,0x29,0x5C,0x8F,0xBD,0xCC,0xCC,0x4C,0x3D,0x99,0x99,0x19,0x3E,0xCC,0xCC,0x4C,0x3D,0x8E,0xC2,0xF5,0x3C,0x00,0x00,0x00,0x00,
  0x8F,0xC2,0xF5,0x3D,0xCC,0xCC,0xCC,0x3D,0x8E,0xC2,0x75,0x3D,0xCC,0xCC,0xCC,0x3D,0x8F,0xC2,0xF5,0x3D,0xEB,0x51,0xB8,0x3D,0xEB,0x51,0x38,0x3E,0x00,0x00,0x00,0x00,
  0xEB,0x51,0xB8,0x3D,0xEB,0x51,0x38,0x3E,0xEB,0x51,0xB8,0x3D,0x0A,0xD7,0xA3,0x3C,0x0A,0xD7,0x23,0x3D,0x0A,0xD7,0x23,0x3C,0x8E,0xC2,0xF5,0x3C,0x0A,0xD7,0x23,0x3C,
  0xCC,0xCC,0x4C,0x3D,0x0A,0xD7,0xA3,0x3C,0x08,0xD7,0xA3,0x3C,0xEB,0x51,0x38,0x3E,0x00,0x00,0x80,0x3E,0x90,0xC2,0x75,0x3D,0x3D,0x0A,0x57,0x3E,0x0C,0xD7,0x23,0x3C,
  0x7A,0x14,0x2E,0x3E,0x0C,0xD7,0x23,0x3C,0x0A,0xD7,0x23,0x3D,0x90,0xC2,0xF5,0x3C,0x08,0xD7,0x23,0x3C,0x90,0xC2,0x75,0x3D,0x00,0x00,0x00,0x00,0xAE,0x47,0xE1,0x3D,
  0x08,0xD7,0x23,0x3C,0xB8,0x1E,0x05,0x3E,0x0A,0xD7,0x23,0x3D,0x29,0x5C,0x0F,0x3E,0xEB,0x51,0xB8,0x3D,0x29,0x5C,0x0F,0x3E,0x8F,0xC2,0xF5,0x3D,0xB8,0x1E,0x05,0x3E,
  0x7A,0x14,0x2E,0x3E,0xAE,0x47,0xE1,0x3D,0xCC,0xCC,0x4C,0x3E,0x00,0x00,0x00,0x00,0x7A,0x14,0x2E,0x3E,0x0C,0xD7,0xA3,0x3C,0x5C,0x8F,0x42,0x3E,0x8F,0xC2,0xF5,0x3D,
  0x5C,0x8F,0x42,0x3E,0xB8,0x1E,0x05,0x3E,0x99,0x99,0x19,0x3E,0x8F,0xC2,0xF5,0x3D,0xB8,0x1E,0x05,0x3E,0x29,0x5C,0x0F,0x3E,0x00,0x00,0x00,0x00,0x0C,0xD7,0xA3,0x3C,
  0x3D,0x0A,0x57,0x3E,0xB8,0x1E,0x05,0x3E,0x3D,0x0A,0x57,0x3E,0x29,0x5C,0x8F,0x3D,0xB8,0x1E,0x05,0x3E,0xCD,0xCC,0xCC,0x3D,0xB8,0x1E,0x05,0x3E,0x8F,0xC2,0xF5,0x3D,
  0x8F,0xC2,0xF5,0x3D,0xB8,0x1E,0x05,0x3E,0xAE,0x47,0xE1,0x3D,0x29,0x5C,0x0F,0x3E,0x0A,0xD7,0xA3,0x3D,0xCD,0xCC,0xCC,0x3D,0x3D,0x0A,0x57,0x3E,0x9A,0x99,0x19,0x3E,
  0x28,0x5C,0x8F,0x3D,0xCD,0xCC,0xCC,0x3D,0x00,0x00,0x00,0x00,0x8F,0xC2,0xF5,0x3D,0x3D,0x0A,0x57,0x3E,0xCD,0xCC,0x4C,0x3D,0x28,0x5C,0x0F,0x3E,0xAE,0x47,0xE1,0x3D,
  0xB8,0x1E,0x05,0x3E,0x8F,0xC2,0xF5,0x3D,0xEB,0x51,0x38,0x3E,0x29,0x5C,0x8F,0x3D,0x00,0x00,0x00,0x00,0xB8,0x1E,0x05,0x3E,0x8E,0xC2,0x75,0x3D,0xB8,0x1E,0x05,0x3E,
  0x28,0x5C,0x8F,0x3D,0x8F,0xC2,0xF5,0x3D,0xCC,0xCC,0xCC,0x3D,0x8F,0xC2,0xF5,0x3C,0x8F,0xC2,0xF5,0x3D,0x0C,0xD7,0x23,0x3C,0xCC,0xCC,0xCC,0x3D,0x29,0x5C,0x0F,0x3E,
  0x3D,0x0A,0x57,0x3E,0x0C,0xD7,0x23,0x3C,0xEB,0x51,0x38,0x3E,0x0A,0xD7,0x23,0x3D,0xB8,0x1E,0x05,0x3E,0x0A,0xD7,0xA3,0x3D,0x8F,0xC2,0xF5,0x3D,0xAE,0x47,0xE1,0x3D,
  0xAE,0x47,0xE1,0x3D,0xB8,0x1E,0x05,0x3E,0xEB,0x51,0xB8,0x3D,0x29,0x5C,0x0F,0x3E,0x0A,0xD7,0x23,0x3D,0xB8,0x1E,0x05,0x3E,0x08,0xD7,0xA3,0x3C,0x0C,0xD7,0x23,0x3C,
  0xEB,0x51,0xB8,0x3D,0x90,0xC2,0xF5,0x3C,0xAE,0x47,0xE1,0x3D,0x90,0xC2,0x75,0x3D,0x8F,0xC2,0xF5,0x3D,0x8F,0xC2,0xF5,0x3D,0x28,0x5C,0x0F,0x3E,0xB8,0x1E,0x05,0x3E,
  0x0A,0xD7,0x23,0x3E,0xB8,0x1E,0x05,0x3E,0xEB,0x51,0x38,0x3E,0xB8,0x1E,0x05,0x3E,0x28,0x5C,0x0F,0x3E,0x8F,0xC2,0xF5,0x3D,0xAE,0x47,0xE1,0x3D,0xCD,0xCC,0xCC,0x3D,
  0xEB,0x51,0xB8,0x3D,0x29,0x5C,0x8F,0x3D,0x0A,0xD7,0xA3,0x3D,0x90,0xC2,0x75,0x3D,0x0A,0xD7,0xA3,0x3D,0x90,0xC2,0xF5,0x3C,0xEB,0x51,0xB8,0x3D,0x0C,0xD7,0x23,0x3C,
  0xAE,0x47,0xE1,0x3D,0x29,0x5C,0x8F,0x3D,0x3D,0x0A,0x57,0x3E,0x8F,0xC2,0xF5,0x3D,0x0A,0xD7,0x23,0x3D,0x0A,0xD7,0xA3,0x3C,0xAE,0x47,0xE1,0x3D,0x0A,0xD7,0x23,0x3E,
  0xEB,0x51,0x38,0x3E,0x0A,0xD7,0x23,0x3E,0x00,0x00,0x00,0x00,0xEB,0x51,0x38,0x3E,0x8F,0xC2,0xF5,0x3D,0xEB,0x51,0x38,0x3E,0x8E,0xC2,0x75,0x3D,0x0A,0xD7,0x23,0x3E,
  0xEB,0x51,0xB8,0x3D,0x0A,0xD7,0x23,0x3D,0x3D,0x0A,0x57,0x3E,0xAE,0x47,0xE1,0x3D,0x5C,0x8F,0x42,0x3E,0x8F,0xC2,0xF5,0x3D,0x7A,0x14,0x2E,0x3E,0x8F,0xC2,0xF5,0x3D,
  0x99,0x99,0x19,0x3E,0x8F,0xC2,0x75,0x3D,0xCC,0xCC,0xCC,0x3D,0x8F,0xC2,0x75,0x3D,0x28,0x5C,0x8F,0x3D,0xCC,0xCC,0x4C,0x3D,0x08,0xD7,0x23,0x3C,0x29,0x5C,0x8F,0x3D,
  0x08,0xD7,0x23,0x3C,0xEB,0x51,0xB8,0x3D,0x99,0x99,0x19,0x3E,0x28,0x5C,0x8F,0x3D,0x0A,0xD7,0x23,0x3E,0x0A,0xD7,0x23,0x3D,0x0A,0xD7,0x23,0x3E,0x09,0xD7,0xA3,0x3C,
  0x99,0x99,0x19,0x3E,0x00,0x00,0x00,0x00,0x0A,0xD7,0xA3,0x3D,0x08,0xD7,0x23,0x3C,0x8E,0xC2,0x75,0x3D,0x8E,0xC2,0xF5,0x3C,0xCC,0xCC,0x4C,0x3D,0x8E,0xC2,0x75,0x3D,
  0xCC,0xCC,0x4C,0x3D,0x0A,0xD7,0xA3,0x3D,0x8E,0xC2,0x75,0x3D,0xEB,0x51,0xB8,0x3D,0x0A,0xD7,0xA3,0x3D,0x09,0xD7,0xA3,0x3C,0x8E,0xC2,0x75,0x3D,0xCC,0xCC,0xCC,0x3D,
  0x0A,0xD7,0x23,0x3E,0xEB,0x51,0xB8,0x3D,0x8E,0xC2,0x75,0x3D,0xAE,0x47,0xE1,0x3D,0xCC,0xCC,0x4C,0x3D,0xB8,0x1E,0x05,0x3E,0xCC,0xCC,0x4C,0x3D,0x0A,0xD7,0x23,0x3E,
  0xCC,0xCC,0xCC,0x3D,0x0A,0xD7,0x23,0x3E,0x8F,0xC2,0xF5,0x3D,0x99,0x99,0x19,0x3E,0x99,0x99,0x19,0x3E,0x28,0x5C,0x0F,0x3E,0x7A,0x14,0x2E,0x3E,0x90,0xC2,0xF5,0x3C,
  0x28,0x5C,0x8F,0x3D,0x29,0x5C,0x0F,0x3E,0x99,0x99,0x19,0x3E,0xB8,0x1E,0x05,0x3E,0xB8,0x1E,0x05,0x3E,0xEC,0x51,0xB8,0x3D,0xAE,0x47,0xE1,0x3D,0x9A,0x99,0x19,0x3E,
  0x0A,0xD7,0x23,0x3E,0x00,0x00,0x00,0x00,0xB8,0x1E,0x05,0x3E,0x0C,0xD7,0xA3,0x3C,0x8E,0xC2,0xF5,0x3C,0x0A,0xD7,0x23,0x3D,0x08,0xD7,0x23,0x3C,0x9A,0x99,0x19,0x3E,
  0xCC,0xCC,0x4C,0x3D,0x29,0x5C,0x0F,0x3E,0xB8,0x1E,0x05,0x3E,0x0A,0xD7,0xA3,0x3D,0xAE,0x47,0xE1,0x3D,0x9A,0x99,0x19,0x3E,0x0A,0xD7,0xA3,0x3D,0xCD,0xCC,0xCC,0x3D,
  0x0A,0xD7,0xA3,0x3D,0x29,0x5C,0x0F,0x3E,0xAE,0x47,0xE1,0x3D,0xCC,0xCC,0xCC,0x3D,0xCC,0xCC,0x4C,0x3D,0xEB,0x51,0xB8,0x3D,0x08,0xD7,0xA3,0x3C,0x0A,0xD7,0xA3,0x3D,
  0x08,0xD7,0x23,0x3C,0x00,0x00,0x00,0x00,0xCC,0xCC,0x4C,0x3D,0xCD,0xCC,0x4C,0x3D,0x8F,0xC2,0xF5,0x3D,0x8F,0xC2,0xF5,0x3D,0x00,0x00,0x00,0x00,0x0A,0xD7,0x23,0x3E,
  0x3D,0x0A,0x57,0x3E,0x0A,0xD7,0x23,0x3E,0x0A,0xD7,0xA3,0x3D,0x0A,0xD7,0x23,0x3E,0xB8,0x1E,0x05,0x3E,0x29,0x5C,0x0F,0x3E,0x28,0x5C,0x0F,0x3E,0xB8,0x1E,0x05,0x3E,
  0x8F,0xC2,0xF5,0x3D,0xEC,0x51,0xB8,0x3D,0xCC,0xCC,0xCC,0x3D,0x00,0x00,0x00,0x00,0xCC,0xCC,0xCC,0x3D,0xEB,0x51,0xB8,0x3D,0x0A,0xD7,0x23,0x3D,0x9A,0x99,0x19,0x3E,
  0x0C,0xD7,0xA3,0xBC,0xCC,0xCC,0x4C,0x3E,0x3D,0x0A,0x57,0x3E,0x0A,0xD7,0x23,0x3C,0x00,0x00,0x80,0x3E,0x29,0x5C,0x0F,0x3E,0x90,0xC2,0xF5,0xBC,0x8F,0xC2,0x75,0x3D,
  0x00,0x00,0x80,0x3E,0x8F,0xC2,0x75,0x3D,0x29,0x5C,0x8F,0xBD,0x0A,0xD7,0xA3,0x3D,0x1E,0x85,0x6B,0x3E,0xEB,0x51,0x38,0x3E,0x29,0x5C,0x8F,0xBD,0x0A,0xD7,0xA3,0x3C,
  0x0A,0xD7,0x23,0x3E,0x0A,0xD7,0xA3,0x3C,0x8F,0xC2,0xF5,0x3D,0x0A,0xD7,0x23,0x3C,0xB8,0x1E,0x05,0x3E,0x8F,0xC2,0xF5,0x3C,0xB8,0x1E,0x05,0x3E,0x29,0x5C,0x8F,0x3D,
  0x28,0x5C,0x0F,0x3E,0x8F,0xC2,0xF5,0x3D,0x0A,0xD7,0xA3,0x3D,0xAE,0x47,0xE1,0x3D,0x8E,0xC2,0xF5,0x3C,0xEB,0x51,0xB8,0x3D,0x08,0xD7,0x23,0x3C,0xAE,0x47,0xE1,0x3D,
  0x8F,0xC2,0xF5,0x3D,0x8F,0xC2,0xF5,0x3C,0x7A,0x14,0x2E,0x3E,0x8F,0xC2,0xF5,0x3C,0x00,0x00,0x00,0x00,0x8F,0xC2,0xF5,0x3D,0x0C,0xD7,0xA3,0xBC,0xAE,0x47,0xE1,0x3D,
  0xCE,0xCC,0x4C,0xBD,0xCC,0xCC,0xCC,0x3D,0x8E,0xC2,0x75,0xBD,0x0A,0xD7,0xA3,0x3D,0x29,0x5C,0x8F,0xBD,0xCC,0xCC,0x4C,0x3D,0x29,0x5C,0x8F,0xBD,0x8F,0xC2,0xF5,0x3C,
  0x8E,0xC2,0x75,0xBD,0xAE,0x47,0xE1,0x3D,0xCC,0xCC,0xCC,0x3D,0xAE,0x47,0xE1,0x3D,0x00,0x00,0x00,0x00,0x0A,0xD7,0x23,0x3C,0xAE,0x47,0x61,0x3E,0xCC,0xCC,0x4C,0x3D,
  0xCC,0xCC,0x4C,0x3E,0xCC,0xCC,0x4C,0x3D,0xAE,0x47,0x61,0x3E,0xCC,0xCC,0x4C,0x3D,0x90,0xC2,0xF5,0xBC,0x0A,0xD7,0x23,0x3D,0x8E,0xC2,0x75,0xBD,0x0A,0xD7,0xA3,0x3C,
  0x29,0x5C,0x8F,0xBD,0x0A,0xD7,0x23,0x3D,0x0A,0xD7,0xA3,0x3D,0x0A,0xD7,0x23,0x3E,0x28,0x5C,0x0F,0x3E,0x3D,0x0A,0x57,0x3E,0xB8,0x1E,0x05,0x3E,0xAE,0x47,0x61,0x3E,
  0xCC,0xCC,0xCC,0x3D,0xAE,0x47,0x61,0x3E,0x00,0x00,0x00,0x00,0x8F,0xC2,0xF5,0x3D,0x29,0x5C,0x8F,0xBD,0x8E,0xC2,0xF5,0x3C,0x0A,0xD7,0xA3,0x3D,0x0A,0xD7,0xA3,0x3D,
  0x28,0x5C,0x8F,0x3D,0x08,0xD7,0x23,0x3C,0x08,0xD7,0x23,0x3C,0x8F,0xC2,0xF5,0x3C,0x0A,0xD7,0x23,0x3D,0xAE,0x47,0xE1,0x3D,0x28,0x5C,0x0F,0x3E,0x8F,0xC2,0xF5,0x3C,
  0x8E,0xC2,0x75,0x3E,0x0A,0xD7,0xA3,0x3C,0x7A,0x14,0x2E,0x3E,0x8F,0xC2,0xF5,0x3C,0x0A,0xD7,0x23,0x3E,0x0A,0xD7,0xA3,0x3C,0xCC,0xCC,0xCC,0x3D,0x0A,0xD7,0xA3,0x3C,
  0xAE,0x47,0x61,0x3E,0x8F,0xC2,0xF5,0x3C,0xEB,0x51,0x38,0x3E,0x0A,0xD7,0x23,0x3D,0x7A,0x14,0x2E,0x3E,0xCC,0xCC,0x4C,0x3D,0xB8,0x1E,0x05,0x3E,0x0A,0xD7,0x23,0x3D,
  0xAE,0x47,0xE1,0x3D,0x0A,0xD7,0x23,0x3D,0x28,0x5C,0x8F,0x3D,0xCC,0xCC,0x4C,0x3D,0xCC,0xCC,0x4C,0x3D,0x0A,0xD7,0xA3,0x3C,0x0C,0xD7,0xA3,0xBC,0x0A,0xD7,0xA3,0x3C,
  0x0A,0xD7,0x23,0xBD,0x0A,0xD7,0xA3,0x3C,0x0A,0xD7,0xA3,0x3D,0x0A,0xD7,0x23,0x3D,0x8E,0xC2,0x75,0x3D,0x0A,0xD7,0xA3,0x3C,0x8E,0xC2,0x75,0x3E,0x8F,0xC2,0xF5,0x3C,
  0x1E,0x85,0x6B,0x3E,0x0A,0xD7,0x23,0x3D,0x5C,0x8F,0x42,0x3E,0x8F,0xC2,0xF5,0x3C,0xCC,0xCC,0xCC,0x3D,0x8F,0xC2,0xF5,0x3C,0xAE,0x47,0x61,0x3E,0xCC,0xCC,0x4C,0x3D,
  0xEB,0x51,0xB8,0x3D,0x0A,0xD7,0xA3,0x3C,0x00,0x00,0x00,0x00,0x8F,0xC2,0xF5,0x3C,0x0A,0xD7,0x23,0xBD,0x0A,0xD7,0xA3,0x3C,0x8E,0xC2,0x75,0xBD,0xAE,0x47,0xE1,0x3D,
  0x0A,0xD7,0xA3,0x3D,0x7A,0x14,0x2E,0x3E,0x0A,0xD7,0xA3,0x3D,0xEB,0x51,0x38,0x3E,0xCC,0xCC,0xCC,0x3D,0xCC,0xCC,0x4C,0x3D,0xAE,0x47,0xE1,0x3D,0x28,0x5C,0x8F,0x3D,
  0xCC,0xCC,0xCC,0x3D,0xAE,0x47,0xE1,0x3D,0x28,0x5C,0x8F,0x3D,0x99,0x99,0x19,0x3E,0x8E,0xC2,0x75,0x3D,0x7A,0x14,0x2E,0x3E,0x28,0x5C,0x8F,0x3D,0xAE,0x47,0xE1,0x3D,
  0x3D,0x0A,0x57,0x3E,0x9A,0x99,0x19,0x3E,0x3D,0x0A,0x57,0x3E,0x21,0x0A,0x00,0x00,0x00,0x01,0x00,0x02,0x00,0x03,0x00,0x03,0x00,0x04,0x00,0x04,0x00,0x05,0x00,0x05,
  0x00,0x02,0x00,0x22,0x04,0x00,0x06,0x00,0x07,0x00,0x08,0x00,0x09,0x00,0x23,0x08,0x00,0x0A,0x00,0x0B,0x00,0x0C,0x00,0x0D,0x00,0x0E,0x00,0x0F,0x00,0x10,0x00,0x11,
  0x00,0x24,0x2A,0x00,0x12,0x00,0x13,0x00,0x14,0x00,0x15,0x00,0x16,0x00,0x17,0x00,0x17,0x00,0x18,0x00,0x18,0x00,0x19,0x00,0x19,0x00,0x1A,0x00,0x1A,0x00,0x1B,0x00,
  0x1B,0x00,0x1C,0x00,0x1C,0x00,0x1D,0x00,0x1D,0x00,0x1E,0x00,0x1E,0x00,0x1F,0x00,0x1F,0x00,0x20,0x00,0x20,0x00,0x21,0x00,0x21,0x00,0x22,0x00,0x22,0x00,0x11,0x00,
  0x11,0x00,0x23,0x00,0x23,0x00,0x24,0x00,0x24,0x00,0x25,0x00,0x25,0x00,0x26,0x00,0x26,0x00,0x05,0x00,0x05,0x00,0x27,0x00,0x25,0x34,0x00,0x28,0x00,0x29,0x00,0x19,
  0x00,0x2A,0x00,0x2A,0x00,0x2B,0x00,0x2B,0x00,0x2C,0x00,0x2C,0x00,0x2D,0x00,0x2D,0x00,0x2E,0x00,0x2E,0x00,0x1C,0x00,0x1C,0x00,0x1B,0x00,0x1B,0x00,0x2F,0x00,0x2F,
  0x00,0x30,0x00,0x30,0x00,0x19,0x00,0x19,0x00,0x31,0x00,0x31,0x00,0x32,0x00,0x32,0x00,0x33,0x00,0x33,0x00,0x34,0x00,0x34,0x00,0x28,0x00,0x35,0x00,0x36,0x00,0x36,
  0x00,0x37,0x00,0x37,0x00,0x38,0x00,0x38,0x00,0x39,0x00,0x39,0x00,0x3A,0x00,0x3A,0x00,0x3B,0x00,0x3B,0x00,0x3C,0x00,0x3C,0x00,0x3D,0x00,0x3D,0x00,0x3E,0x00,0x3E,
  0x00,0x35,0x00,0x26,0x3C,0x00,0x3F,0x00,0x40,0x00,0x40,0x00,0x41,0x00,0x41,0x00,0x42,0x00,0x42,0x00,0x43,0x00,0x43,0x00,0x44,0x00,0x44,0x00,0x11,0x00,0x11,0x00,
  0x45,0x00,0x45,0x00,0x46,0x00,0x46,0x00,0x47,0x00,0x47,0x00,0x48,0x00,0x48,0x00,0x05,0x00,0x05,0x00,0x02,0x00,0x02,0x00,0x49,0x00,0x49,0x00,0x10,0x00,0x10,0x00,
  0x4A,0x00,0x4A,0x00,0x4B,0x00,0x4B,0x00,0x4C,0x00,0x4C,0x00,0x4D,0x00,0x4D,0x00,0x4E,0x00,0x4E,0x00,0x4F,0x00,0x4F,0x00,0x50,0x00,0x50,0x00,0x08,0x00,0x08,0x00,
  0x51,0x00,0x51,0x00,0x52,0x00,0x52,0x00,0x53,0x00,0x53,0x00,0x54,0x00,0x54,0x00,0x55,0x00,0x55,0x00,0x56,0x00,0x56,0x00,0x57,0x00,0x57,0x00,0x58,0x00,0x27,0x0C,
  0x00,0x59,0x00,0x5A,0x00,0x5A,0x00,0x00,0x00,0x00,0x00,0x1A,0x00,0x1A,0x00,0x5B,0x00,0x5B,0x00,0x5C,0x00,0x5C,0x00,0x5D,0x00,0x28,0x12,0x00,0x5E,0x00,0x5F,0x00,
  0x5F,0x00,0x60,0x00,0x60,0x00,0x5C,0x00,0x5C,0x00,0x61,0x00,0x61,0x00,0x62,0x00,0x62,0x00,0x02,0x00,0x02,0x00,0x63,0x00,0x63,0x00,0x64,0x00,0x64,0x00,0x0D,0x00,
  0x29,0x12,0x00,0x65,0x00,0x66,0x00,0x66,0x00,0x67,0x00,0x67,0x00,0x68,0x00,0x68,0x00,0x69,0x00,0x69,0x00,0x6A,0x00,0x6A,0x00,0x6B,0x00,0x6B,0x00,0x6C,0x00,0x6C,
  0x00,0x6D,0x00,0x6D,0x00,0x6E,0x00,0x2A,0x06,0x00,0x6F,0x00,0x70,0x00,0x71,0x00,0x72,0x00,0x73,0x00,0x10,0x00,0x2B,0x04,0x00,0x74,0x00,0x25,0x00,0x75,0x00,0x76,
  0x00,0x2C,0x0C,0x00,0x77,0x00,0x78,0x00,0x78,0x00,0x49,0x00,0x49,0x00,0x79,0x00,0x79,0x00,0x77,0x00,0x77,0x00,0x7A,0x00,0x7A,0x00,0x29,0x00,0x2D,0x02,0x00,0x75,
  0x00,0x76,0x00,0x2E,0x08,0x00,0x79,0x00,0x49,0x00,0x49,0x00,0x78,0x00,0x78,0x00,0x77,0x00,0x77,0x00,0x79,0x00,0x2F,0x02,0x00,0x7B,0x00,0x6E,0x00,0x30,0x20,0x00,
  0x7C,0x00,0x60,0x00,0x60,0x00,0x7D,0x00,0x7D,0x00,0x71,0x00,0x71,0x00,0x75,0x00,0x75,0x00,0x7E,0x00,0x7E,0x00,0x7F,0x00,0x7F,0x00,0x80,0x00,0x80,0x00,0x47,0x00,
  0x47,0x00,0x81,0x00,0x81,0x00,0x82,0x00,0x82,0x00,0x83,0x00,0x83,0x00,0x84,0x00,0x84,0x00,0x85,0x00,0x85,0x00,0x86,0x00,0x86,0x00,0x08,0x00,0x08,0x00,0x7C,0x00,
  0x31,0x06,0x00,0x87,0x00,0x5B,0x00,0x5B,0x00,0x19,0x00,0x19,0x00,0x26,0x00,0x32,0x1A,0x00,0x5C,0x00,0x7D,0x00,0x7D,0x00,0x88,0x00,0x88,0x00,0x60,0x00,0x60,0x00,
  0x19,0x00,0x19,0x00,0x18,0x00,0x18,0x00,0x86,0x00,0x86,0x00,0x89,0x00,0x89,0x00,0x85,0x00,0x85,0x00,0x8A,0x00,0x8A,0x00,0x8B,0x00,0x8B,0x00,0x20,0x00,0x20,0x00,
  0x29,0x00,0x29,0x00,0x8C,0x00,0x33,0x1C,0x00,0x8D,0x00,0x8E,0x00,0x8E,0x00,0x8F,0x00,0x8F,0x00,0x90,0x00,0x90,0x00,0x91,0x00,0x91,0x00,0x92,0x00,0x92,0x00,0x93,
  0x00,0x93,0x00,0x11,0x00,0x11,0x00,0x56,0x00,0x56,0x00,0x81,0x00,0x81,0x00,0x47,0x00,0x47,0x00,0x26,0x00,0x26,0x00,0x05,0x00,0x05,0x00,0x02,0x00,0x02,0x00,0x49,
  0x00,0x34,0x06,0x00,0x94,0x00,0x62,0x00,0x62,0x00,0x95,0x00,0x94,0x00,0x96,0x00,0x35,0x20,0x00,0x97,0x00,0x8D,0x00,0x8D,0x00,0x0E,0x00,0x0E,0x00,0x1E,0x00,0x1E,
  0x00,0x98,0x00,0x98,0x00,0x09,0x00,0x09,0x00,0x99,0x00,0x99,0x00,0x92,0x00,0x92,0x00,0x93,0x00,0x93,0x00,0x11,0x00,0x11,0x00,0x56,0x00,0x56,0x00,0x81,0x00,0x81,
  0x00,0x47,0x00,0x47,0x00,0x26,0x00,0x26,0x00,0x05,0x00,0x05,0x00,0x02,0x00,0x02,0x00,0x49,0x00,0x36,0x2C,0x00,0x9A,0x00,0x86,0x00,0x86,0x00,0x08,0x00,0x08,0x00,
  0x7C,0x00,0x7C,0x00,0x60,0x00,0x60,0x00,0x7D,0x00,0x7D,0x00,0x71,0x00,0x71,0x00,0x62,0x00,0x62,0x00,0x78,0x00,0x78,0x00,0x7F,0x00,0x7F,0x00,0x80,0x00,0x80,0x00,
  0x9B,0x00,0x9B,0x00,0x46,0x00,0x46,0x00,0x45,0x00,0x45,0x00,0x9C,0x00,0x9C,0x00,0x9D,0x00,0x9D,0x00,0x9E,0x00,0x9E,0x00,0x73,0x00,0x73,0x00,0x8F,0x00,0x8F,0x00,
  0x54,0x00,0x54,0x00,0x9F,0x00,0x9F,0x00,0xA0,0x00,0xA0,0x00,0x62,0x00,0x37,0x04,0x00,0xA1,0x00,0x48,0x00,0x06,0x00,0xA1,0x00,0x38,0x38,0x00,0x19,0x00,0x1A,0x00,
  0x1A,0x00,0xA2,0x00,0xA2,0x00,0x5C,0x00,0x5C,0x00,0x2E,0x00,0x2E,0x00,0xA3,0x00,0xA3,0x00,0xA4,0x00,0xA4,0x00,0xA5,0x00,0xA5,0x00,0xA6,0x00,0xA6,0x00,0x35,0x00,
  0x35,0x00,0xA7,0x00,0xA7,0x00,0xA8,0x00,0xA8,0x00,0x24,0x00,0x24,0x00,0x25,0x00,0x25,0x00,0x26,0x00,0x26,0x00,0x05,0x00,0x05,0x00,0x02,0x00,0x02,0x00,0x49,0x00,
  0x49,0x00,0x62,0x00,0x62,0x00,0xA9,0x00,0xA9,0x00,0xAA,0x00,0xAA,0x00,0xAB,0x00,0xAB,0x00,0x90,0x00,0x90,0x00,0xAC,0x00,0xAC,0x00,0xAD,0x00,0xAD,0x00,0xAE,0x00,
  0xAE,0x00,0x17,0x00,0x17,0x00,0x18,0x00,0x18,0x00,0x19,0x00,0x39,0x2C,0x00,0xAF,0x00,0xB0,0x00,0xB0,0x00,0xB1,0x00,0xB1,0x00,0xB2,0x00,0xB2,0x00,0xB3,0x00,0xB3,
  0x00,0xB4,0x00,0xB4,0x00,0xB5,0x00,0xB5,0x00,0x07,0x00,0x07,0x00,0x5D,0x00,0x5D,0x00,0xA2,0x00,0xA2,0x00,0x60,0x00,0x60,0x00,0x7C,0x00,0x7C,0x00,0xB6,0x00,0xB6,
  0x00,0x50,0x00,0x50,0x00,0x9A,0x00,0x9A,0x00,0xAF,0x00,0xAF,0x00,0xA6,0x00,0xA6,0x00,0xB7,0x00,0xB7,0x00,0x46,0x00,0x46,0x00,0x9B,0x00,0x9B,0x00,0x26,0x00,0x26,
  0x00,0x05,0x00,0x05,0x00,0x78,0x00,0x3A,0x10,0x00,0x0E,0x00,0x61,0x00,0x61,0x00,0xA0,0x00,0xA0,0x00,0xB8,0x00,0xB8,0x00,0x0E,0x00,0x79,0x00,0x49,0x00,0x49,0x00,
  0x78,0x00,0x78,0x00,0x77,0x00,0x77,0x00,0x79,0x00,0x3B,0x14,0x00,0x0E,0x00,0x61,0x00,0x61,0x00,0xA0,0x00,0xA0,0x00,0xB8,0x00,0xB8,0x00,0x0E,0x00,0x77,0x00,0x78,
  0x00,0x78,0x00,0x49,0x00,0x49,0x00,0x79,0x00,0x79,0x00,0x77,0x00,0x77,0x00,0x7A,0x00,0x7A,0x00,0x29,0x00,0x3C,0x04,0x00,0xB9,0x00,0x75,0x00,0x75,0x00,0xBA,0x00,
  0x3D,0x04,0x00,0x71,0x00,0xBB,0x00,0x10,0x00,0xBC,0x00,0x3E,0x04,0x00,0x1B,0x00,0xBD,0x00,0xBD,0x00,0x29,0x00,0x3F,0x22,0x00,0x1C,0x00,0x87,0x00,0x87,0x00,0x59,
  0x00,0x59,0x00,0x1A,0x00,0x1A,0x00,0xBE,0x00,0xBE,0x00,0x08,0x00,0x08,0x00,0x50,0x00,0x50,0x00,0xBF,0x00,0xBF,0x00,0xC0,0x00,0xC0,0x00,0xC1,0x00,0xC1,0x00,0x99,
  0x00,0x99,0x00,0x73,0x00,0x73,0x00,0xC2,0x00,0xC2,0x00,0xC3,0x00,0x6B,0x00,0xC4,0x00,0xC4,0x00,0x80,0x00,0x80,0x00,0xC5,0x00,0xC5,0x00,0x6B,0x00,0x40,0x34,0x00,
  0x90,0x00,0xC6,0x00,0xC6,0x00,0xC7,0x00,0xC7,0x00,0xC8,0x00,0xC8,0x00,0xC9,0x00,0xC9,0x00,0x1D,0x00,0x1D,0x00,0x61,0x00,0x61,0x00,0xCA,0x00,0xCA,0x00,0xCB,0x00,
  0xCB,0x00,0xCC,0x00,0xCC,0x00,0xCD,0x00,0xCD,0x00,0xCE,0x00,0xCE,0x00,0xCF,0x00,0xC8,0x00,0x2E,0x00,0x2E,0x00,0xB5,0x00,0xB5,0x00,0x4A,0x00,0x4A,0x00,0xD0,0x00,
  0xD0,0x00,0xCC,0x00,0xD1,0x00,0xCF,0x00,0xCF,0x00,0xD2,0x00,0xD2,0x00,0xD3,0x00,0xD3,0x00,0xD4,0x00,0xD4,0x00,0x95,0x00,0x95,0x00,0xD5,0x00,0xD5,0x00,0xD6,0x00,
  0xD6,0x00,0xD7,0x00,0xD7,0x00,0xD8,0x00,0x41,0x06,0x00,0x08,0x00,0x29,0x00,0x08,0x00,0xBA,0x00,0xD9,0x00,0x9D,0x00,0x42,0x24,0x00,0x06,0x00,0x29,0x00,0x06,0x00,
  0x18,0x00,0x18,0x00,0x17,0x00,0x17,0x00,0x33,0x00,0x33,0x00,0xD8,0x00,0xD8,0x00,0xDA,0x00,0xDA,0x00,0xDB,0x00,0xDB,0x00,0x91,0x00,0x91,0x00,0xDC,0x00,0x61,0x00,
  0xDC,0x00,0xDC,0x00,0x9E,0x00,0x9E,0x00,0xA6,0x00,0xA6,0x00,0x35,0x00,0x35,0x00,0xA7,0x00,0xA7,0x00,0xA8,0x00,0xA8,0x00,0x24,0x00,0x24,0x00,0x25,0x00,0x25,0x00,
  0x29,0x00,0x43,0x22,0x00,0xDD,0x00,0x16,0x00,0x16,0x00,0x17,0x00,0x17,0x00,0x94,0x00,0x94,0x00,0x7C,0x00,0x7C,0x00,0x67,0x00,0x67,0x00,0x5B,0x00,0x5B,0x00,0x5C,
  0x00,0x5C,0x00,0xDE,0x00,0xDE,0x00,0xCA,0x00,0xCA,0x00,0x79,0x00,0x79,0x00,0xDF,0x00,0xDF,0x00,0xE0,0x00,0xE0,0x00,0x80,0x00,0x80,0x00,0x96,0x00,0x96,0x00,0x24,
  0x00,0x24,0x00,0x23,0x00,0x23,0x00,0xE1,0x00,0x44,0x18,0x00,0x06,0x00,0x29,0x00,0x06,0x00,0xB6,0x00,0xB6,0x00,0x50,0x00,0x50,0x00,0x9A,0x00,0x9A,0x00,0xAD,0x00,
  0xAD,0x00,0xE2,0x00,0xE2,0x00,0x93,0x00,0x93,0x00,0xD4,0x00,0xD4,0x00,0x45,0x00,0x45,0x00,0x46,0x00,0x46,0x00,0x9B,0x00,0x9B,0x00,0x29,0x00,0x45,0x08,0x00,0x06,
  0x00,0x29,0x00,0x06,0x00,0x8E,0x00,0x61,0x00,0xE3,0x00,0x29,0x00,0x39,0x00,0x46,0x06,0x00,0x06,0x00,0x29,0x00,0x06,0x00,0x8E,0x00,0x61,0x00,0xE3,0x00,0x47,0x26,
  0x00,0xDD,0x00,0x16,0x00,0x16,0x00,0x17,0x00,0x17,0x00,0x94,0x00,0x94,0x00,0x7C,0x00,0x7C,0x00,0x67,0x00,0x67,0x00,0x5B,0x00,0x5B,0x00,0x5C,0x00,0x5C,0x00,0xDE,
  0x00,0xDE,0x00,0xCA,0x00,0xCA,0x00,0x79,0x00,0x79,0x00,0xDF,0x00,0xDF,0x00,0xE0,0x00,0xE0,0x00,0x80,0x00,0x80,0x00,0x96,0x00,0x96,0x00,0x24,0x00,0x24,0x00,0x23,
  0x00,0x23,0x00,0xE1,0x00,0xE1,0x00,0xE4,0x00,0xE5,0x00,0xE4,0x00,0x48,0x06,0x00,0x06,0x00,0x29,0x00,0xA1,0x00,0x8C,0x00,0x61,0x00,0xE6,0x00,0x49,0x02,0x00,0x06,
  0x00,0x29,0x00,0x4A,0x12,0x00,0x94,0x00,0xE7,0x00,0xE7,0x00,0xE8,0x00,0xE8,0x00,0xE9,0x00,0xE9,0x00,0x80,0x00,0x80,0x00,0x48,0x00,0x48,0x00,0x05,0x00,0x05,0x00,
  0x02,0x00,0x02,0x00,0xEA,0x00,0xEA,0x00,0x62,0x00,0x4B,0x06,0x00,0x06,0x00,0x29,0x00,0xA1,0x00,0x62,0x00,0xEB,0x00,0x8C,0x00,0x4C,0x04,0x00,0x06,0x00,0x29,0x00,
  0x29,0x00,0xEC,0x00,0x4D,0x08,0x00,0x06,0x00,0x29,0x00,0x06,0x00,0x47,0x00,0xED,0x00,0x47,0x00,0xED,0x00,0xBA,0x00,0x4E,0x06,0x00,0x06,0x00,0x29,0x00,0x06,0x00,
  0x8C,0x00,0xA1,0x00,0x8C,0x00,0x4F,0x28,0x00,0x7C,0x00,0x67,0x00,0x67,0x00,0x5B,0x00,0x5B,0x00,0x5C,0x00,0x5C,0x00,0xDE,0x00,0xDE,0x00,0xCA,0x00,0xCA,0x00,0x79,
  0x00,0x79,0x00,0xDF,0x00,0xDF,0x00,0xE0,0x00,0xE0,0x00,0x80,0x00,0x80,0x00,0x96,0x00,0x96,0x00,0x24,0x00,0x24,0x00,0x23,0x00,0x23,0x00,0xE1,0x00,0xE1,0x00,0xEE,
  0x00,0xEE,0x00,0xEF,0x00,0xEF,0x00,0xDD,0x00,0xDD,0x00,0x16,0x00,0x16,0x00,0x17,0x00,0x17,0x00,0x94,0x00,0x94,0x00,0x7C,0x00,0x50,0x14,0x00,0x06,0x00,0x29,0x00,
  0x06,0x00,0x18,0x00,0x18,0x00,0x17,0x00,0x17,0x00,0x33,0x00,0x33,0x00,0xD8,0x00,0xD8,0x00,0xF0,0x00,0xF0,0x00,0xF1,0x00,0xF1,0x00,0xB0,0x00,0xB0,0x00,0xF2,0x00,
  0xF2,0x00,0xF3,0x00,0x51,0x2A,0x00,0x7C,0x00,0x67,0x00,0x67,0x00,0x5B,0x00,0x5B,0x00,0x5C,0x00,0x5C,0x00,0xDE,0x00,0xDE,0x00,0xCA,0x00,0xCA,0x00,0x79,0x00,0x79,
  0x00,0xDF,0x00,0xDF,0x00,0xE0,0x00,0xE0,0x00,0x80,0x00,0x80,0x00,0x96,0x00,0x96,0x00,0x24,0x00,0x24,0x00,0x23,0x00,0x23,0x00,0xE1,0x00,0xE1,0x00,0xEE,0x00,0xEE,
  0x00,0xEF,0x00,0xEF,0x00,0xDD,0x00,0xDD,0x00,0x16,0x00,0x16,0x00,0x17,0x00,0x17,0x00,0x94,0x00,0x94,0x00,0x7C,0x00,0xF4,0x00,0xF5,0x00,0x52,0x16,0x00,0x06,0x00,
  0x29,0x00,0x06,0x00,0x18,0x00,0x18,0x00,0x17,0x00,0x17,0x00,0x33,0x00,0x33,0x00,0xD8,0x00,0xD8,0x00,0xDA,0x00,0xDA,0x00,0xDB,0x00,0xDB,0x00,0x91,0x00,0x91,0x00,
  0xDC,0x00,0xDC,0x00,0x61,0x00,0x69,0x00,0x8C,0x00,0x53,0x26,0x00,0x16,0x00,0x17,0x00,0x17,0x00,0x18,0x00,0x18,0x00,0x19,0x00,0x19,0x00,0x1A,0x00,0x1A,0x00,0x1B,
  0x00,0x1B,0x00,0x1C,0x00,0x1C,0x00,0x1D,0x00,0x1D,0x00,0x1E,0x00,0x1E,0x00,0x1F,0x00,0x1F,0x00,0x20,0x00,0x20,0x00,0x21,0x00,0x21,0x00,0x22,0x00,0x22,0x00,0x11,
  0x00,0x11,0x00,0x23,0x00,0x23,0x00,0x24,0x00,0x24,0x00,0x25,0x00,0x25,0x00,0x26,0x00,0x26,0x00,0x05,0x00,0x05,0x00,0x27,0x00,0x54,0x04,0x00,0xB6,0x00,0x9B,0x00,
  0x06,0x00,0xA1,0x00,0x55,0x12,0x00,0x06,0x00,0x10,0x00,0x10,0x00,0x78,0x00,0x78,0x00,0x7F,0x00,0x7F,0x00,0x80,0x00,0x80,0x00,0x47,0x00,0x47,0x00,0x81,0x00,0x81,
  0x00,0x56,0x00,0x56,0x00,0x11,0x00,0x11,0x00,0xA1,0x00,0x56,0x04,0x00,0x06,0x00,0x47,0x00,0xED,0x00,0x47,0x00,0x57,0x08,0x00,0x06,0x00,0x26,0x00,0x94,0x00,0x26,
  0x00,0x94,0x00,0x3A,0x00,0xF6,0x00,0x3A,0x00,0x58,0x04,0x00,0x06,0x00,0x8C,0x00,0xA1,0x00,0x29,0x00,0x59,0x06,0x00,0x06,0x00,0xE3,0x00,0xE3,0x00,0x47,0x00,0xED,
  0x00,0xE3,0x00,0x5A,0x06,0x00,0xA1,0x00,0x29,0x00,0x06,0x00,0xA1,0x00,0x29,0x00,0x8C,0x00,0x5B,0x08,0x00,0x65,0x00,0x6E,0x00,0xF7,0x00,0x0B,0x00,0x65,0x00,0x5E,
  0x00,0x6E,0x00,0x0D,0x00,0x5C,0x02,0x00,0x06,0x00,0xF8,0x00,0x5D,0x08,0x00,0xF9,0x00,0xFA,0x00,0x5E,0x00,0x0D,0x00,0x65,0x00,0x5E,0x00,0x6E,0x00,0x0D,0x00,0x5E,
  0x04,0x00,0xFB,0x00,0x75,0x00,0xFB,0x00,0xBD,0x00,0x5F,0x02,0x00,0x6E,0x00,0xFC,0x00,0x60,0x0C,0x00,0xFD,0x00,0x07,0x00,0x07,0x00,0x71,0x00,0x71,0x00,0xB5,0x00,
  0xB5,0x00,0xFE,0x00,0xFE,0x00,0xFF,0x00,0xFF,0x00,0x71,0x00,0x61,0x1C,0x00,0xAC,0x00,0xEC,0x00,0xB0,0x00,0x90,0x00,0x90,0x00,0x09,0x00,0x09,0x00,0x98,0x00,0x98,
  0x00,0x00,0x01,0x00,0x01,0xB5,0x00,0xB5,0x00,0xCA,0x00,0xCA,0x00,0x10,0x00,0x10,0x00,0x78,0x00,0x78,0x00,0x7F,0x00,0x7F,0x00,0x26,0x00,0x26,0x00,0x47,0x00,0x47,
  0x00,0x46,0x00,0x46,0x00,0x45,0x00,0x62,0x1C,0x00,0x06,0x00,0x29,0x00,0x61,0x00,0x1E,0x00,0x1E,0x00,0x2D,0x00,0x2D,0x00,0x01,0x01,0x01,0x01,0x4C,0x00,0x4C,0x00,
  0xA5,0x00,0xA5,0x00,0x02,0x01,0x02,0x01,0x36,0x00,0x36,0x00,0x03,0x01,0x03,0x01,0x04,0x01,0x04,0x01,0x9B,0x00,0x9B,0x00,0x48,0x00,0x48,0x00,0x05,0x00,0x05,0x00,
  0x27,0x00,0x63,0x1A,0x00,0xB0,0x00,0x90,0x00,0x90,0x00,0x09,0x00,0x09,0x00,0x98,0x00,0x98,0x00,0x00,0x01,0x00,0x01,0xB5,0x00,0xB5,0x00,0xCA,0x00,0xCA,0x00,0x10,
  0x00,0x10,0x00,0x78,0x00,0x78,0x00,0x7F,0x00,0x7F,0x00,0x26,0x00,0x26,0x00,0x47,0x00,0x47,0x00,0x46,0x00,0x46,0x00,0x45,0x00,0x64,0x1C,0x00,0x97,0x00,0xEC,0x00,
  0xB0,0x00,0x90,0x00,0x90,0x00,0x09,0x00,0x09,0x00,0x98,0x00,0x98,0x00,0x00,0x01,0x00,0x01,0xB5,0x00,0xB5,0x00,0xCA,0x00,0xCA,0x00,0x10,0x00,0x10,0x00,0x78,0x00,
  0x78,0x00,0x7F,0x00,0x7F,0x00,0x26,0x00,0x26,0x00,0x47,0x00,0x47,0x00,0x46,0x00,0x46,0x00,0x45,0x00,0x65,0x20,0x00,0xCA,0x00,0x02,0x01,0x02,0x01,0x9E,0x00,0x9E,
  0x00,0x05,0x01,0x05,0x01,0x90,0x00,0x90,0x00,0x09,0x00,0x09,0x00,0x98,0x00,0x98,0x00,0x00,0x01,0x00,0x01,0xB5,0x00,0xB5,0x00,0xCA,0x00,0xCA,0x00,0x10,0x00,0x10,
  0x00,0x78,0x00,0x78,0x00,0x7F,0x00,0x7F,0x00,0x26,0x00,0x26,0x00,0x47,0x00,0x47,0x00,0x46,0x00,0x46,0x00,0x45,0x00,0x66,0x0A,0x00,0x08,0x00,0x7C,0x00,0x7C,0x00,
  0x67,0x00,0x67,0x00,0x06,0x01,0x06,0x01,0x07,0x01,0x07,0x00,0x01,0x01,0x67,0x26,0x00,0xAC,0x00,0x08,0x01,0x08,0x01,0x09,0x01,0x09,0x01,0x0A,0x01,0x0A,0x01,0x0B,
  0x01,0x0B,0x01,0x0C,0x01,0x0C,0x01,0x0D,0x01,0xB0,0x00,0x90,0x00,0x90,0x00,0x09,0x00,0x09,0x00,0x98,0x00,0x98,0x00,0x00,0x01,0x00,0x01,0xB5,0x00,0xB5,0x00,0xCA,
  0x00,0xCA,0x00,0x10,0x00,0x10,0x00,0x78,0x00,0x78,0x00,0x7F,0x00,0x7F,0x00,0x26,0x00,0x26,0x00,0x47,0x00,0x47,0x00,0x46,0x00,0x46,0x00,0x45,0x00,0x68,0x0E,0x00,
  0x06,0x00,0x29,0x00,0xF3,0x00,0x00,0x01,0x00,0x01,0x98,0x00,0x98,0x00,0x09,0x00,0x09,0x00,0x90,0x00,0x90,0x00,0x0E,0x01,0x0E,0x01,0x0F,0x01,0x69,0x0A,0x00,0x06,
  0x00,0x2F,0x00,0x2F,0x00,0x8D,0x00,0x8D,0x00,0x10,0x01,0x10,0x01,0x06,0x00,0x1D,0x00,0x04,0x00,0x6A,0x10,0x00,0xBE,0x00,0x11,0x01,0x11,0x01,0x7C,0x00,0x7C,0x00,
  0x12,0x01,0x12,0x01,0xBE,0x00,0x98,0x00,0x13,0x01,0x13,0x01,0x14,0x01,0x14,0x01,0x15,0x01,0x15,0x01,0x6E,0x00,0x6B,0x06,0x00,0x06,0x00,0x29,0x00,0x4D,0x00,0x49,
  0x00,0x16,0x01,0x0F,0x01,0x6C,0x02,0x00,0x06,0x00,0x29,0x00,0x6D,0x1A,0x00,0x07,0x00,0x29,0x00,0xF3,0x00,0x00,0x01,0x00,0x01,0x98,0x00,0x98,0x00,0x09,0x00,0x09,
  0x00,0x90,0x00,0x90,0x00,0x0E,0x01,0x0E,0x01,0x0F,0x01,0x0E,0x01,0xE2,0x00,0xE2,0x00,0x17,0x01,0x17,0x01,0x41,0x00,0x41,0x00,0x18,0x01,0x18,0x01,0x19,0x01,0x19,
  0x01,0x1A,0x01,0x6E,0x0E,0x00,0x07,0x00,0x29,0x00,0xF3,0x00,0x00,0x01,0x00,0x01,0x98,0x00,0x98,0x00,0x09,0x00,0x09,0x00,0x90,0x00,0x90,0x00,0x0E,0x01,0x0E,0x01,
  0x0F,0x01,0x6F,0x20,0x00,0x98,0x00,0x00,0x01,0x00,0x01,0xB5,0x00,0xB5,0x00,0xCA,0x00,0xCA,0x00,0x10,0x00,0x10,0x00,0x78,0x00,0x78,0x00,0x7F,0x00,0x7F,0x00,0x26,
  0x00,0x26,0x00,0x47,0x00,0x47,0x00,0x46,0x00,0x46,0x00,0x45,0x00,0x45,0x00,0x9C,0x00,0x9C,0x00,0x22,0x00,0x22,0x00,0xB0,0x00,0xB0,0x00,0x90,0x00,0x90,0x00,0x09,
  0x00,0x09,0x00,0x98,0x00,0x70,0x1C,0x00,0x07,0x00,0x6E,0x00,0x61,0x00,0x1E,0x00,0x1E,0x00,0x2D,0x00,0x2D,0x00,0x01,0x01,0x01,0x01,0x4C,0x00,0x4C,0x00,0xA5,0x00,
  0xA5,0x00,0x02,0x01,0x02,0x01,0x36,0x00,0x36,0x00,0x03,0x01,0x03,0x01,0x04,0x01,0x04,0x01,0x9B,0x00,0x9B,0x00,0x48,0x00,0x48,0x00,0x05,0x00,0x05,0x00,0x27,0x00,
  0x71,0x1C,0x00,0xAC,0x00,0x1B,0x01,0xB0,0x00,0x90,0x00,0x90,0x00,0x09,0x00,0x09,0x00,0x98,0x00,0x98,0x00,0x00,0x01,0x00,0x01,0xB5,0x00,0xB5,0x00,0xCA,0x00,0xCA,
  0x00,0x10,0x00,0x10,0x00,0x78,0x00,0x78,0x00,0x7F,0x00,0x7F,0x00,0x26,0x00,0x26,0x00,0x47,0x00,0x47,0x00,0x46,0x00,0x46,0x00,0x45,0x00,0x72,0x0A,0x00,0x07,0x00,
  0x29,0x00,0xCA,0x00,0xB5,0x00,0xB5,0x00,0x00,0x01,0x00,0x01,0x98,0x00,0x98,0x00,0x09,0x00,0x73,0x20,0x00,0xA5,0x00,0x90,0x00,0x90,0x00,0x01,0x01,0x01,0x01,0x2D,
  0x00,0x2D,0x00,0xFF,0x00,0xFF,0x00,0x61,0x00,0x61,0x00,0xA9,0x00,0xA9,0x00,0x1C,0x01,0x1C,0x01,0x1D,0x01,0x1D,0x01,0x72,0x00,0x72,0x00,0x37,0x00,0x37,0x00,0x03,
  0x01,0x03,0x01,0x46,0x00,0x46,0x00,0x9B,0x00,0x9B,0x00,0x48,0x00,0x48,0x00,0x1E,0x01,0x1E,0x01,0x27,0x00,0x74,0x0A,0x00,0x30,0x00,0x1F,0x01,0x1F,0x01,0xE0,0x00,
  0xE0,0x00,0x80,0x00,0x80,0x00,0x47,0x00,0x07,0x00,0x01,0x01,0x75,0x0E,0x00,0x07,0x00,0x49,0x00,0x49,0x00,0x1E,0x01,0x1E,0x01,0x07,0x01,0x07,0x01,0x80,0x00,0x80,
  0x00,0xE9,0x00,0xE9,0x00,0x37,0x00,0x20,0x01,0x0F,0x01,0x76,0x04,0x00,0x07,0x00,0x80,0x00,0xAC,0x00,0x80,0x00,0x77,0x08,0x00,0x07,0x00,0x48,0x00,0x09,0x00,0x48,
  0x00,0x09,0x00,0xEC,0x00,0x17,0x01,0xEC,0x00,0x78,0x04,0x00,0x07,0x00,0x0F,0x01,0x20,0x01,0x29,0x00,0x79,0x0C,0x00,0x1D,0x00,0x9B,0x00,0xAF,0x00,0x9B,0x00,0x9B,
  0x00,0x13,0x00,0x13,0x00,0x0D,0x01,0x0D,0x01,0x0B,0x00,0x0B,0x00,0x6E,0x00,0x7A,0x06,0x00,0x20,0x01,0x29,0x00,0x07,0x00,0x20,0x01,0x29,0x00,0x0F,0x01,0x7B,0x34,
  0x00,0x12,0x00,0x21,0x01,0x21,0x01,0x66,0x00,0x66,0x00,0x00,0x00,0x00,0x00,0x59,0x00,0x59,0x00,0x22,0x01,0x22,0x01,0x23,0x01,0x23,0x01,0x2D,0x00,0x2D,0x00,0x1F,
  0x00,0x1F,0x00,0x24,0x01,0x21,0x01,0x25,0x01,0x25,0x01,0x1A,0x00,0x1A,0x00,0x26,0x01,0x26,0x01,0x27,0x01,0x27,0x01,0x6F,0x00,0x6F,0x00,0x28,0x01,0x28,0x01,0x29,
  0x01,0x29,0x01,0x75,0x00,0x75,0x00,0x2A,0x01,0x2A,0x01,0x2B,0x01,0x2B,0x01,0x70,0x00,0x70,0x00,0xE0,0x00,0xE0,0x00,0x07,0x01,0x07,0x01,0x2C,0x01,0x2C,0x01,0x2D,
  0x01,0x2D,0x01,0x0D,0x01,0x2E,0x01,0x2F,0x01,0x7C,0x02,0x00,0x65,0x00,0x6E,0x00,0x7D,0x34,0x00,0x65,0x00,0x30,0x01,0x30,0x01,0x31,0x01,0x31,0x01,0xBE,0x00,0xBE,
  0x00,0x32,0x01,0x32,0x01,0x06,0x01,0x06,0x01,0xFD,0x00,0xFD,0x00,0x1D,0x00,0x1D,0x00,0x0E,0x00,0x0E,0x00,0x33,0x01,0x30,0x01,0x34,0x01,0x34,0x01,0x60,0x00,0x60,
  0x00,0x5B,0x00,0x5B,0x00,0x7D,0x00,0x7D,0x00,0x5D,0x00,0x5D,0x00,0xDE,0x00,0xDE,0x00,0xB5,0x00,0xB5,0x00,0x35,0x01,0x35,0x01,0x01,0x00,0x01,0x00,0xEA,0x00,0xEA,
  0x00,0x27,0x00,0x27,0x00,0x1E,0x01,0x1E,0x01,0x36,0x01,0x36,0x01,0x63,0x00,0x63,0x00,0x37,0x01,0x37,0x01,0x38,0x01,0x1C,0x01,0xCB,0x00,0x7E,0x28,0x00,0x10,0x00,
  0xCA,0x00,0xCA,0x00,0xB5,0x00,0xB5,0x00,0x9F,0x00,0x9F,0x00,0xEB,0x00,0xEB,0x00,0x69,0x00,0x69,0x00,0x39,0x01,0x39,0x01,0x9D,0x00,0x9D,0x00,0x95,0x00,0x95,0x00,
  0x3A,0x01,0x3A,0x01,0x3B,0x01,0xCA,0x00,0xA0,0x00,0xA0,0x00,0xAA,0x00,0xAA,0x00,0x3C,0x01,0x3C,0x01,0x3D,0x01,0x3D,0x01,0x3E,0x01,0x3E,0x01,0x9C,0x00,0x9C,0x00,
  0x3F,0x01,0x3F,0x01,0x40,0x01,0x40,0x01,0x3B,0x01,0x3B,0x01,0xBB,0x00
};

static bool isFirst=true;
static bool isBigEndian() { int i = 1; return *((char*)&i)==0; }

inline void Swap2Bytes(char* data)
{
	char one_byte;
	one_byte = data[0]; data[0] = data[1]; data[1] = one_byte;
}

inline void Swap4Bytes(char* data)
{
	char one_byte;
	one_byte = data[0]; data[0] = data[3]; data[3] = one_byte;
	one_byte = data[1]; data[1] = data[2]; data[2] = one_byte;
}

inline void Swap8Bytes(char* data)
{ 
	char one_byte;
	one_byte = data[0]; data[0] = data[7]; data[7] = one_byte;
	one_byte = data[1]; data[1] = data[6]; data[6] = one_byte;
	one_byte = data[2]; data[2] = data[5]; data[5] = one_byte;
	one_byte = data[3]; data[3] = data[4]; data[4] = one_byte;
}

static inline PxU8 * getUShort(PxU8 *data,unsigned short &v)
{
	unsigned short *src = (unsigned short *)data;
	if ( isBigEndian() && isFirst ) 
	{
		Swap2Bytes((char *)data);
	}
	v = src[0];
	data+=sizeof(unsigned short);
	return data;
}

static inline PxU8 * getUint(PxU8 *data,PxU32 &v)
{
	PxU32 *src = (PxU32 *)data;
	if ( isBigEndian() && isFirst )
	{
		Swap4Bytes((char *)data);
	}
	v = src[0];
	data+=sizeof(PxU32);
	return data;
}

class FontChar
{
public:
	FontChar(void)
	{
		mIndexCount = 0;
		mIndices   = 0;
		mX1 = mY1 = mX2 = mY2 = 0;
	}

	PxU8 * init(PxU8 *data,const PxF32 *vertices)
	{
		data = getUShort(data,mIndexCount);
		mIndices = (unsigned short *)data;

		if ( isBigEndian() && isFirst )
		{
			for (PxU16 i=0; i<mIndexCount; i++)
			{
				Swap2Bytes((char *)&mIndices[i]);
			}
		}

		data+=(mIndexCount*sizeof(unsigned short));
		for (PxU32 i=0; i<mIndexCount; i++)
		{
			PxU32 index = mIndices[i];
			const  PxF32 *vertex = &vertices[index*2];

			PX_ASSERT( physx::intrinsics::isFinite(vertex[0]));
			PX_ASSERT( physx::intrinsics::isFinite(vertex[1]));

			if ( i == 0 )
			{
				mX1 = mX2 = vertex[0];
				mY1 = mY2 = vertex[1];
			}
			else
			{
				if ( vertex[0] < mX1 ) mX1 = vertex[0];
				if ( vertex[1] < mY1 ) mY1 = vertex[1];

				if ( vertex[0] > mX2 ) mX2 = vertex[0];
				if ( vertex[1] > mY2 ) mY2 = vertex[1];

			}
		}

		PX_ASSERT( physx::intrinsics::isFinite(mX1));
		PX_ASSERT( physx::intrinsics::isFinite(mX2));
		PX_ASSERT( physx::intrinsics::isFinite(mY1));
		PX_ASSERT( physx::intrinsics::isFinite(mY2));

		return data;
	}

	void vputc(const PxF32 *vertices,PxProcessRenderDebugHelper *debug,PxF32 textScale,PxF32 &x,PxF32 &y)
	{
		if ( mIndices )
		{
			PxU32 lineCount = (physx::PxU32)mIndexCount/2;
			PxF32 spacing = (mX2-mX1)+0.05f;
			for (PxU32 i=0; i<lineCount; i++)
			{
				unsigned short i1 = mIndices[i*2+0];
				unsigned short i2 = mIndices[i*2+1];

				const PxF32 *v1 = &vertices[i1*2];
				const PxF32 *v2 = &vertices[i2*2];

				PxVec3 p1(v1[0]+x,v1[1]+y,0);
				PxVec3 p2(v2[0]+x,v2[1]+y,0);
				p1*=textScale;
				p2*=textScale;

				debug->indirectDebugLine(p1,p2);

			}
			x+=spacing;
		}
		else
		{
			x+=0.1f;
		}
	}

	PxF32 getWidth(void) const
	{
		PxF32 ret = 0.1f;
		if ( mIndexCount > 0 )
		{
			ret = (mX2-mX1)+0.05f;
		}
		return ret;
	}


	PxF32          mX1;
	PxF32          mX2;
	PxF32          mY1;
	PxF32          mY2;
	unsigned short mIndexCount;
	unsigned short *mIndices;
};


#define FONT_VERSION 1

class MyVectorFont : public UserAllocated
{
public:
	MyVectorFont(void)
	{
		mVersion = 0;
		mVcount = 0;
		mCount = 0;
		mVertices = 0;
		initFont(g_font);
	}

	virtual ~MyVectorFont(void)
	{
		release();
	}

	void release(void)
	{
		mVersion = 0;
		mVcount = 0;
		mCount = 0;
		mVertices = 0;
	}

	void initFont(PxU8 *font)
	{
		release();
		if ( font[0] == 'F' && font[1] == 'O' && font[2] == 'N' && font[3] == 'T' )
		{
			font+=4;
			font = getUint(font,mVersion);
			if ( mVersion == FONT_VERSION )
			{
				font = getUint(font,mVcount);
				font = getUint(font,mCount);
				font = getUint(font,mIcount);
				PxU32 vsize = sizeof(PxF32)*mVcount*2;
				mVertices = (PxF32 *)font;
				if ( isBigEndian() && isFirst )
				{
					for (PxU32 i=0; i<(mVcount*2); i++)
					{
						Swap4Bytes((char *) &mVertices[i] );
					}
				}
				font+=vsize;
				for (PxU32 i=0; i<mCount; i++)
				{
					PxU8 c = *font++;
					font = mCharacters[c].init(font,mVertices);
				}
			}
			isFirst = false;
		}
	}

	void vprint(const char *buffer,PxProcessRenderDebugHelper *debug,PxF32 textScale,bool centered)
	{
		const char *scan = buffer;
		PxF32 x = 0;
		PxF32 y = 0;
		if ( centered )
		{
			PxF32 wid=0;
			while ( *scan )
			{
				unsigned c = (unsigned)*scan++;
				wid+=mCharacters[c].getWidth();
			}
			x = -wid*0.5f;
			scan = buffer;
		}
		while ( *scan )
		{
			unsigned c = (unsigned)*scan++;
			mCharacters[c].vputc(mVertices,debug,textScale,x,y);
		}
	}

private:
	PxU32    mVersion;
	PxU32    mVcount;
	PxU32    mCount;
	PxF32   *mVertices;
	PxU32    mIcount;
	FontChar mCharacters[256];
};




class ProcessRenderDebug : public PxProcessRenderDebug, public UserAllocated, public PxProcessRenderDebugHelper
{
public:

	ProcessRenderDebug(void)
	{
		mViewMatrix = physx::PxMat44::createIdentity();
		mLines = NULL;
		mLineVertexCount = 0;
		mMaxLineVertexCount = 0;
		mTriangles = NULL;
		mSolidVertexCount = 0;
		mMaxSolidVertexCount = 0;
	}

	virtual ~ProcessRenderDebug(void)
	{
		PX_FREE(mLines);
		PX_FREE(mTriangles);
	}

	void flushLines(void)
	{
		if (mLines != NULL && mInterface != NULL && mLineVertexCount > 0)
		{
			mInterface->debugRenderLines(mLineVertexCount/2,mLines,mDisplayType!=WORLD_SPACE_NOZ,mDisplayType==SCREEN_SPACE);
		}
		if (mLines == NULL)
		{
			mLines = (RenderDebugVertex *)PX_ALLOC(sizeof(RenderDebugVertex)*MAX_LINE_VERTEX, PX_DEBUG_EXP("RenderDebugVertex"));
			mMaxLineVertexCount = MAX_LINE_VERTEX;
		}
		mLineVertexCount = 0;
	}

	void flushTriangles(void)
	{
		if (mTriangles != NULL && mInterface != NULL && mSolidVertexCount > 0)
		{
			mInterface->debugRenderTriangles(mSolidVertexCount/3,mTriangles,mDisplayType!=WORLD_SPACE_NOZ,mDisplayType==SCREEN_SPACE);
		}
		if (mTriangles == NULL)
		{
			mTriangles = (RenderDebugSolidVertex *)PX_ALLOC(sizeof(RenderDebugSolidVertex)*MAX_SOLID_VERTEX, PX_DEBUG_EXP("RenderDebugSolidVertex"));
			mMaxSolidVertexCount = MAX_SOLID_VERTEX;
		}
		mSolidVertexCount = 0;
	}

	virtual void flush(RenderDebugInterface *iface,DisplayType type)
	{
		mInterface = iface;
		mDisplayType = type;
		flushLines();
		flushTriangles();
		new ( &mCurrentState ) RenderState; // reset renderstate to inifial conditions.
	}

	bool isIdentity(const PxMat44 &t) const
	{
		PxMat44 id = PxMat44::createIdentity();
		const PxF32 *f1 = (const PxF32 *)t.front();
		const PxF32 *f2 = (const PxF32 *)id.front();
		for (PxU32 i=0; i<16; i++)
		{
			PxF32 diff = PxAbs( f1[i] - f2[i] );
			if ( diff > 0.000001f )
				return false;
		}
		return true;
	}

	virtual void processRenderDebug(const DebugPrimitive **plist,PxU32 pcount,RenderDebugInterface *iface,DisplayType type)
	{
		mInterface = iface;
		mDisplayType = type;
		for (PxU32 i=0; i<pcount; i++)
		{
			const DebugPrimitive &p = *plist[i];
			switch ( p.mCommand )
			{
				case DebugCommand::DEBUG_GRAPH:
					{
						const DebugGraphStream &dgs = static_cast< const DebugGraphStream &>(p);
						debugGraph(dgs);
					}
					break;
				case DebugCommand::DEBUG_GRADIENT_TRI:
					{
						const DebugGradientTri &dg = static_cast< const DebugGradientTri &>(p);
						debugGradientTri(dg);
					}
					break;
				case DebugCommand::SET_CURRENT_TRANSFORM:
					{
						const DebugSetCurrentTransform &dg = static_cast< const DebugSetCurrentTransform &>(p);
						if ( isIdentity(dg.mTransform ))
						{
							mCurrentState.mPose = NULL;
						}
						else
						{
							mCurrentState.mCurrentPose = dg.mTransform;
							mCurrentState.mPose = &mCurrentState.mCurrentPose;
						}
					}
					break;
				case DebugCommand::DEBUG_LINE:
					{
						const DebugLine &dg = static_cast< const DebugLine &>(p);
						debugLine(dg.mP1,dg.mP2,mCurrentState.mColor,mCurrentState.mColor);
					}
					break;
				case DebugCommand::DRAW_GRID:
					{
						const DrawGrid &dg = static_cast< const DrawGrid &>(p);
						drawGrid(dg);
					}
					break;
				case DebugCommand::SET_CURRENT_COLOR:
					{
						const DebugPrimitiveU32 &dg = static_cast< const DebugPrimitiveU32 &>(p);
						mCurrentState.mColor = dg.mValue;
					}
					break;
				case DebugCommand::SET_CURRENT_ARROW_COLOR:
					{
						const DebugPrimitiveU32 &dg = static_cast< const DebugPrimitiveU32 &>(p);
						mCurrentState.mArrowColor = dg.mValue;
					}
					break;
				case DebugCommand::SET_CURRENT_USER_ID:
					{
						const DebugPrimitiveU32 &dg = static_cast< const DebugPrimitiveU32 &>(p);
						mCurrentState.mUserId = (physx::PxI32)dg.mValue;
					}
					break;
				case DebugCommand::SET_CURRENT_USER_POINTER:
					{
						const DebugPrimitiveU64 &dg = static_cast< const DebugPrimitiveU64 &>(p);
						mCurrentState.mUserPtr = (void *)dg.mValue;
					}
					break;
				case DebugCommand::SET_CURRENT_RENDER_SCALE:
					{
						const DebugPrimitiveF32 &dg = static_cast< const DebugPrimitiveF32 &>(p);
						mCurrentState.mRenderScale = dg.mValue;
					}
					break;
				case DebugCommand::SET_CURRENT_ARROW_SIZE:
					{
						const DebugPrimitiveF32 &dg = static_cast< const DebugPrimitiveF32 &>(p);
						mCurrentState.mArrowSize = dg.mValue;
					}
					break;
				case DebugCommand::SET_CURRENT_RENDER_STATE:
					{
						const DebugPrimitiveU32 &dg = static_cast< const DebugPrimitiveU32 &>(p);
						mCurrentState.mStates = dg.mValue;
					}
					break;
				case DebugCommand::SET_CURRENT_TEXT_SCALE:
					{
						const DebugPrimitiveF32 &dg = static_cast< const DebugPrimitiveF32 &>(p);
						mCurrentState.mTextScale = dg.mValue;
					}
					break;
				case DebugCommand::DEBUG_TEXT:
					{
						const DebugText &dg = static_cast< const DebugText &>(p);
						debugText(dg);
					}
					break;
				case DebugCommand::DEBUG_BOUND:
					{
						const DebugBound &db = static_cast< const DebugBound &>(p);
						debugBound(db);
					}
					break;
				case DebugCommand::DEBUG_QUAD:
					{
						const DebugQuad &b = static_cast< const DebugQuad &>(p);
						debugQuad(b);
					}
					break;
				case DebugCommand::DEBUG_POINT:
					{
						const DebugPoint &b = static_cast< const DebugPoint &>(p);
						debugPoint(b);
					}
					break;
				case DebugCommand::DEBUG_POINT_SCALE:
					{
						const DebugPointScale &b = static_cast< const DebugPointScale &>(p);
						debugPoint(b);
					}
					break;
				case DebugCommand::DEBUG_RECT2D:
					{
						const DebugRect2d &d = static_cast<const DebugRect2d &>(p);
						debugRect2d(d);
					}
					break;
				case DebugCommand::DEBUG_GRADIENT_LINE:
					{
						const DebugGradientLine &d = static_cast< const DebugGradientLine &>(p);
						debugGradientLine(d);
					}
					break;
				case DebugCommand::DEBUG_RAY:
					{
						const DebugRay &d = static_cast< const DebugRay &>(p);
						debugRay(d);
					}
					break;
				case DebugCommand::DEBUG_CYLINDER:
					{
						const DebugCylinder &d = static_cast< const DebugCylinder &>(p);
						debugCylinder(d);
					}
					break;
				case DebugCommand::DEBUG_CIRCLE:
					{
						const DebugCircle &d = static_cast< const DebugCircle &>(p);
						debugCircle(d);
					}
					break;
				case DebugCommand::DEBUG_POINT_CYLINDER:
					{
						const DebugPointCylinder &d = static_cast< const DebugPointCylinder &>(p);
						debugPointCylinder(d);
					}
					break;
				case DebugCommand::DEBUG_THICK_RAY:
					{
						const DebugThickRay &d = static_cast< const DebugThickRay &>(p);
						debugThickRay(d);
					}
					break;
				case DebugCommand::DEBUG_PLANE:
					{
						const DebugPlane &d = static_cast< const DebugPlane &>(p);
						debugPlane(d);
					}
					break;
				case DebugCommand::DEBUG_TRI:
					{
						const DebugTri &d = static_cast< const DebugTri &>(p);
						debugTri(&d.mP1,&d.mP2,&d.mP3);
					}
					break;
				case DebugCommand::DEBUG_TRI_NORMALS:
					{
						const DebugTriNormals &d = static_cast< const DebugTriNormals &>(p);
						debugTriNormals(d);
					}
					break;
				case DebugCommand::DEBUG_GRADIENT_TRI_NORMALS:
					{
						const DebugGradientTriNormals &d = static_cast< const DebugGradientTriNormals &>(p);
						debugGradientTriNormals(d);
					}
					break;
				case DebugCommand::DEBUG_SPHERE:
					{
						const DebugSphere &d = static_cast< const DebugSphere &>(p);
						debugSphere(d);
					}
					break;
				case DebugCommand::DEBUG_SQUASHED_SPHERE:
					{
						const DebugSquashedSphere &d = static_cast< const DebugSquashedSphere &>(p);
						debugSphere(d);
					}
					break;
				case DebugCommand::DEBUG_CAPSULE:
					{
						const DebugCapsule &d = static_cast<const DebugCapsule &>(p);
						debugCapsule(d);
					}
					break;
				case DebugCommand::DEBUG_CAPSULE_TAPERED:
					{
						const DebugTaperedCapsule&d = static_cast<const DebugTaperedCapsule&>(p);
						debugTaperedCapsule(d);
					}
					break;
				case DebugCommand::DEBUG_AXES:
					{
						const DebugAxes &d = static_cast< const DebugAxes &>(p);
						debugAxes(d);
					}
					break;
				case DebugCommand::DEBUG_ARC:
					{
						const DebugArc &d = static_cast< const DebugArc &>(p);
						debugArc(d);
					}
					break;
				case DebugCommand::DEBUG_THICK_ARC:
					{
						const DebugThickArc &d = static_cast< const DebugThickArc &>(p);
						debugThickArc(d);
					}
					break;
				case DebugCommand::DEBUG_DETAILED_SPHERE:
					{
						const DebugDetailedSphere &d = static_cast< const DebugDetailedSphere &>(p);
						debugDetailedSphere(d);
					}
					break;
				default:
					PX_ASSERT(0);
					break;
			}
		}
	}

	virtual void release(void)
	{
		delete this;
	}

    PX_INLINE PxI32 clampColor(PxI32 c)
    {
    	if ( c < 0 )
    		c = 0;
    	else if ( c > 255 )
    		c = 255;
    	return c;
    };

	void debugText(const DebugText &dg)
	{
		PxMat44 *savePose = mCurrentState.mPose;
		mCurrentState.mPose = NULL;
		PxMat44 pose = dg.mPose;
		pose.setPosition( pose.getPosition()+dg.mPosition );
		if ( savePose )
		{
			pose = *savePose * pose;
		}
		
		if ( mCurrentState.isCameraFacing() )
		{
			physx::PxF32 *cameraWorldPose = (physx::PxF32 *)pose.front();
			const physx::PxF32 *viewMatrix = (const physx::PxF32 *)mViewMatrix.front();
			cameraWorldPose[0] = viewMatrix[0];
			cameraWorldPose[1] = viewMatrix[4];
			cameraWorldPose[2] = viewMatrix[8];
			cameraWorldPose[3] = 0;

			cameraWorldPose[4] = viewMatrix[1];
			cameraWorldPose[5] = viewMatrix[5];
			cameraWorldPose[6] = viewMatrix[9];
			cameraWorldPose[7] = 0;

			cameraWorldPose[8] = viewMatrix[2];
			cameraWorldPose[9] = viewMatrix[6];
			cameraWorldPose[10] = viewMatrix[10];
			cameraWorldPose[11] = 0;
		}
		mCurrentState.mPose = &pose;
		mVectorFont.vprint(dg.mText, this, mCurrentState.mTextScale, mCurrentState.isCentered() );
		mCurrentState.mPose = savePose;
	}

	PxU32 getColor(PxU32 r,PxU32 g,PxU32 b,PxF32 percent = 0.0f)
	{
		PxU32 dr = (PxU32)((PxF32)r*percent);
		PxU32 dg = (PxU32)((PxF32)g*percent);
		PxU32 db = (PxU32)((PxF32)b*percent);
		r-=dr;
		g-=dg;
		b-=db;

		const PxU32 c = 0xff000000 | (r<<16) | (g<<8) | b;
		return c;
	}


    PX_INLINE void swapYZ(PxVec3 &p)
    {
    	PxF32 y = p.y;
    	p.y = p.z;
    	p.z = y;
    }

    void drawGrid(const DrawGrid &dg)
    {
    	bool zup = dg.mZup;
    	PxU32 gridSize = dg.mGridSize;
    	PxI32  GRIDSIZE = (physx::PxI32)gridSize;

    	PxU32 c1 = getColor(133,153,181,0.1f);
    	PxU32 c2 = getColor(133,153,181,0.3f);
    	PxU32 c3 = getColor(133,153,181,0.5f);

    	const PxF32 TSCALE   = 1.0f;

    	PxF32 BASELOC = 0-0.05f;

    	for (PxI32 x=-GRIDSIZE; x<=GRIDSIZE; x++)
    	{
    		PxU32 c = c1;
    		if ( (x%10) == 0 ) c = c2;
    		if ( (x%GRIDSIZE) == 0 ) c = c3;

    		PxVec3 p1( (PxF32)x,(PxF32) -GRIDSIZE, BASELOC );
    		PxVec3 p2( (PxF32)x,(PxF32) +GRIDSIZE, BASELOC );

    		p1*=TSCALE;
    		p2*=TSCALE;

			if ( !zup )
			{
    			swapYZ(p1);
    			swapYZ(p2);
			}
    		debugLine(p1,p2,c,c);


    	}

    	for (PxI32 y=-GRIDSIZE; y<=GRIDSIZE; y++)
    	{
    		PxU32 c = c1;

    		if ( (y%10) == 0 ) c = c2;
    		if ( (y%GRIDSIZE) == 0 ) c = c3;

    		PxVec3 p1((PxF32) -GRIDSIZE, (PxF32)y, BASELOC );
    		PxVec3 p2( (PxF32)+GRIDSIZE, (PxF32)y, BASELOC );

    		p1*=TSCALE;
    		p2*=TSCALE;

			if ( !zup )
			{
    			swapYZ(p1);
    			swapYZ(p2);
			}

    		debugLine(p1,p2,c,c);
    	}
    }

	PX_INLINE void debugLine(const PxVec3 &p1,const PxVec3 &p2,PxU32 color1,PxU32 color2)
	{
		RenderDebugVertex *v = getDebugVertex(2);

		if ( mCurrentState.mPose )
		{
			PxVec3 _p1 = mCurrentState.mPose->transform(p1);
			PxVec3 _p2 = mCurrentState.mPose->transform(p2);
			v[0].mPos[0] = _p1.x*mCurrentState.mRenderScale;
			v[0].mPos[1] = _p1.y*mCurrentState.mRenderScale;
			v[0].mPos[2] = _p1.z*mCurrentState.mRenderScale;
			v[0].mColor  = color1;

			v[1].mPos[0] = _p2.x*mCurrentState.mRenderScale;
			v[1].mPos[1] = _p2.y*mCurrentState.mRenderScale;
			v[1].mPos[2] = _p2.z*mCurrentState.mRenderScale;
			v[1].mColor  = color2;
		}
		else
		{
			v[0].mPos[0] = p1.x*mCurrentState.mRenderScale;
			v[0].mPos[1] = p1.y*mCurrentState.mRenderScale;
			v[0].mPos[2] = p1.z*mCurrentState.mRenderScale;
			v[0].mColor  = color1;

			v[1].mPos[0] = p2.x*mCurrentState.mRenderScale;
			v[1].mPos[1] = p2.y*mCurrentState.mRenderScale;
			v[1].mPos[2] = p2.z*mCurrentState.mRenderScale;
			v[1].mColor  = color2;
		}
	}

	PX_INLINE PxVec3 rotate2d(const PxVec3 &p,PxF32 r)
	{
		PxVec3 ret;
		ret.x = p.x*cosf(r) - p.y*sinf(r);
		ret.y = p.x*sinf(r) + p.y*cosf(r);
		ret.z = 0;
		return ret;
	}

	PX_INLINE PxVec3 facing(const PxVec3 &p,const PxMat44 &inverseViewMatrix)
	{
		return inverseViewMatrix.rotate(p);
	}

	PX_INLINE void debugQuad(const DebugQuad &p)
	{
		PxVec3 points[4];

		physx::PxMat44 inverseViewMatrix;

		// get the inverse view matrix
		physx::PxF32 *cameraWorldPose = (physx::PxF32 *)inverseViewMatrix.front();
		const physx::PxF32 *viewMatrix = (const physx::PxF32 *)mViewMatrix.front();
		cameraWorldPose[0] = viewMatrix[0];
		cameraWorldPose[1] = viewMatrix[4];
		cameraWorldPose[2] = viewMatrix[8];
		cameraWorldPose[3] = 0;

		cameraWorldPose[4] = viewMatrix[1];
		cameraWorldPose[5] = viewMatrix[5];
		cameraWorldPose[6] = viewMatrix[9];
		cameraWorldPose[7] = 0;

		cameraWorldPose[8] = viewMatrix[2];
		cameraWorldPose[9] = viewMatrix[6];
		cameraWorldPose[10] = viewMatrix[10];
		cameraWorldPose[11] = 0;

		// apply scale, rotation, and make the quad face the camera.
		points[0] = facing(rotate2d(PxVec3(-p.mScale.x*0.5f,-p.mScale.y*0.5f,0),p.mRotation),inverseViewMatrix)+p.mPos;
		points[1] = facing(rotate2d(PxVec3(p.mScale.x*0.5f,-p.mScale.y*0.5f,0),p.mRotation),inverseViewMatrix)+p.mPos;
		points[2] = facing(rotate2d(PxVec3(p.mScale.x*0.5f,p.mScale.y*0.5f,0),p.mRotation),inverseViewMatrix)+p.mPos;
		points[3] = facing(rotate2d(PxVec3(-p.mScale.x*0.5f,p.mScale.y*0.5f,0),p.mRotation),inverseViewMatrix)+p.mPos;


		if ( mCurrentState.hasRenderState(DebugRenderState::SolidWireShaded) || mCurrentState.hasRenderState(DebugRenderState::SolidShaded) )
		{
			PxVec3 normal(1,1,0);
			PxU32 renderState = mCurrentState.mStates;
			mCurrentState.clearRenderState(DebugRenderState::SolidWireShaded);
			mCurrentState.setRenderState(DebugRenderState::SolidShaded);
			debugTri(&points[0],&points[1],&points[2],&normal,&normal,&normal);
			debugTri(&points[0],&points[2],&points[3],&normal,&normal,&normal);
			mCurrentState.mStates = renderState;
		}
		if ( mCurrentState.hasRenderState(DebugRenderState::SolidWireShaded) || !mCurrentState.hasRenderState(DebugRenderState::SolidShaded) )
		{
			PxU32 currentColor = mCurrentState.mColor;
			if ( mCurrentState.hasRenderState(DebugRenderState::SolidWireShaded))
			{
				mCurrentState.mColor = mCurrentState.mArrowColor;
			}
			debugLine(points[0], points[1] );
			debugLine(points[1], points[2] );
			debugLine(points[2], points[3] );
			debugLine(points[3], points[0] );
			mCurrentState.mColor = currentColor;
		}
	}


	PX_INLINE void debugPoint(const DebugPoint &p)
	{
    	const PxVec3 *source = debug_point;

    	for (PxI32 i=0; i<3; i++)
    	{
    		PxVec3 p1 = source[0]*p.mSize+p.mPos;
    		PxVec3 p2 = source[1]*p.mSize+p.mPos;
    		source+=2;

    		debugLine(p1,p2);
    	}
	}

	PX_INLINE void debugPoint(const DebugPointScale &p)
	{
		const PxVec3 *source = debug_point;

		for (PxI32 i=0; i<3; i++)
		{
			PxVec3 p1 = source[0]*p.mSize[i]+p.mPos;
			PxVec3 p2 = source[1]*p.mSize[i]+p.mPos;
			source+=2;
			debugLine(p1,p2);
		}
	}


	PX_INLINE void debugGradientTri(const DebugGradientTri &tri)
	{
		debugTri(&tri.mP1,&tri.mP2,&tri.mP3,NULL,NULL,NULL,tri.mC1,tri.mC2,tri.mC3,true);
	}

	PX_INLINE void debugLine(const PxVec3 &p1,const PxVec3 &p2)
	{
		debugLine(p1,p2,mCurrentState.mColor,mCurrentState.mColor);
	}

	virtual void indirectDebugLine(const PxVec3 &p1,const PxVec3 &p2)
	{
		debugLine(p1,p2,mCurrentState.mColor,mCurrentState.mColor);
	}

	RenderDebugVertex * getDebugVertex(PxU32 count)
	{
		if (( mLineVertexCount+count) > mMaxLineVertexCount )
		{
			flushLines();
		}
		PX_ASSERT( count < mMaxLineVertexCount );
		RenderDebugVertex *ret = &mLines[mLineVertexCount];
		mLineVertexCount+=count;
		return ret;
	}

	RenderDebugSolidVertex * getDebugSolidVertex(PxU32 count)
	{
		if (( mSolidVertexCount+count) > mMaxSolidVertexCount )
		{
			flushTriangles();
		}
		PX_ASSERT( count < mMaxSolidVertexCount );
		RenderDebugSolidVertex *ret = &mTriangles[mSolidVertexCount];
		mSolidVertexCount+=count;
		return ret;
	}

	virtual void flushFrame(RenderDebugInterface * /*iface*/)
	{
	}

	PX_INLINE void debugBound(const DebugBound &b)
	{
    	PxVec3 box[8];
    	box[0] = physx::PxVec3( b.mBmin.x, b.mBmin.y, b.mBmin.z );
    	box[1] = physx::PxVec3( b.mBmax.x, b.mBmin.y, b.mBmin.z );
    	box[2] = physx::PxVec3( b.mBmax.x, b.mBmax.y, b.mBmin.z );
    	box[3] = physx::PxVec3( b.mBmin.x, b.mBmax.y, b.mBmin.z );
    	box[4] = physx::PxVec3( b.mBmin.x, b.mBmin.y, b.mBmax.z );
    	box[5] = physx::PxVec3( b.mBmax.x, b.mBmin.y, b.mBmax.z );
    	box[6] = physx::PxVec3( b.mBmax.x, b.mBmax.y, b.mBmax.z );
    	box[7] = physx::PxVec3( b.mBmin.x, b.mBmax.y, b.mBmax.z );
        debugBound(box);
	}

	PxF32 computePlaneEquation(const PxVec3 &A,const PxVec3 &B,const PxVec3 &C,PxVec3 &normal)
	{
		PxVec3 v = B - C;
		PxVec3 w = A - B;

		PxVec3 vw;

    	vw.x = v.y * w.z - v.z * w.y;
    	vw.y = v.z * w.x - v.x * w.z;
    	vw.z = v.x * w.y - v.y * w.x;

		PxF32 mag = vw.magnitude();

    	if ( mag < 0.000001f )
    	{
    		mag = 0;
    	}
    	else
    	{
    		mag = 1.0f/mag;
    	}

		normal = vw*mag;

    	PxF32 D = 0.0f - ((normal.x*A.x)+(normal.y*A.y)+(normal.z*A.z));

    	return D;
	}

	void debugTri(const PxVec3 *_v1,const PxVec3 *_v2,const PxVec3 *_v3,const PxVec3 *_n1=NULL,const PxVec3 *_n2=NULL,const PxVec3 *_n3=NULL,PxU32 c1=0xFFFFFFFF,PxU32 c2=0xFFFFFFFF,PxU32 c3=0xFFFFFFFF,bool useGradientColors=false)
	{
		if (mCurrentState.hasRenderState(DebugRenderState::CounterClockwise))
		{
			const PxVec3 *temp = _v1;
			_v1 = _v3;
			_v3 = temp;
			if ( _n1 )
			{
				temp = _n1;
				_n1 = _n3;
				_n3 = temp;
			}
			// switch colors too
			{
				PxU32 temp = c1;
				c1 = c3;
				c3 = temp;
			}
		}

		if ( !useGradientColors )
		{
			c1 = mCurrentState.mColor;
			c2 = mCurrentState.mColor;
			c3 = mCurrentState.mColor;
		}

		PxVec3 v1 = *_v1;
		PxVec3 v2 = *_v2;
		PxVec3 v3 = *_v3;

		if (mCurrentState.mPose)
		{
			v1 = mCurrentState.mPose->transform(*_v1);
			v2 = mCurrentState.mPose->transform(*_v2);
			v3 = mCurrentState.mPose->transform(*_v3);
		}

		v1 *= mCurrentState.mRenderScale;
		v2 *= mCurrentState.mRenderScale;
		v3 *= mCurrentState.mRenderScale;

		if (mCurrentState.isSolid())
		{
			RenderDebugSolidVertex* verts = getDebugSolidVertex(3);

			PxVec3 n1, n2, n3;
			if (_n1 == NULL)
			{
				computePlaneEquation(v3, v2, v1, n1);
				if (mCurrentState.hasRenderState(DebugRenderState::CounterClockwise))
				{
					n1 = -n1;
				}
				n2 = n1;
				n3 = n1;
			}
			else
			{
				if (mCurrentState.mPose)
				{
					n1 = mCurrentState.mPose->rotate(*_n1);
					n2 = mCurrentState.mPose->rotate(*_n2);
					n3 = mCurrentState.mPose->rotate(*_n3);
				}
				else
				{
					n1 = *_n1;
					n2 = *_n2;
					n3 = *_n3;
				}
			}

			verts[0].mPos[0] = v1.x;
			verts[0].mPos[1] = v1.y;
			verts[0].mPos[2] = v1.z;
			verts[0].mColor  = c1;
			verts[0].mNormal[0] = n1.x;
			verts[0].mNormal[1] = n1.y;
			verts[0].mNormal[2] = n1.z;

			verts[1].mPos[0] = v2.x;
			verts[1].mPos[1] = v2.y;
			verts[1].mPos[2] = v2.z;
			verts[1].mColor  = c2;
			verts[1].mNormal[0] = n2.x;
			verts[1].mNormal[1] = n2.y;
			verts[1].mNormal[2] = n2.z;

			verts[2].mPos[0] = v3.x;
			verts[2].mPos[1] = v3.y;
			verts[2].mPos[2] = v3.z;
			verts[2].mColor  = c3;
			verts[2].mNormal[0] = n3.x;
			verts[2].mNormal[1] = n3.y;
			verts[2].mNormal[2] = n3.z;
		}

		if ( !mCurrentState.hasRenderState(DebugRenderState::SolidShaded) || mCurrentState.hasRenderState(DebugRenderState::SolidWireShaded) )
		{
			if ( mCurrentState.hasRenderState(DebugRenderState::SolidWireShaded) )
			{
				c1 = c2 = c3 = mCurrentState.mArrowColor;
			}
			RenderDebugVertex *lines = getDebugVertex(6);
			// first vertex (start of first segment, end of third)
			lines[0].mPos[0] = lines[5].mPos[0] = v1.x;
			lines[0].mPos[1] = lines[5].mPos[1] = v1.y;
			lines[0].mPos[2] = lines[5].mPos[2] = v1.z;
			lines[0].mColor = lines[5].mColor = c1;

			// second vertex (end of first segment, start of second)
			lines[1].mPos[0] = lines[2].mPos[0] = v2.x;
			lines[1].mPos[1] = lines[2].mPos[1] = v2.y;
			lines[1].mPos[2] = lines[2].mPos[2] = v2.z;
			lines[1].mColor = lines[2].mColor = c2;

			// third vertex (end of second segment, start of third)
			lines[3].mPos[0] = lines[4].mPos[0] = v3.x;
			lines[3].mPos[1] = lines[4].mPos[1] = v3.y;
			lines[3].mPos[2] = lines[4].mPos[2] = v3.z;
			lines[3].mColor = lines[4].mColor = c3;
		}
	}

    PX_INLINE void debugBound(const PxVec3 *box)
    {
		if ( mCurrentState.isSolid() )
        {
    		debugTri(&box[2],&box[1],&box[0]);
    		debugTri(&box[3],&box[2],&box[0]);

    		debugTri(&box[7],&box[2],&box[3]);
    		debugTri(&box[7],&box[6],&box[2]);

    		debugTri(&box[5],&box[1],&box[2]);
    		debugTri(&box[5],&box[2],&box[6]);

    		debugTri(&box[5],&box[4],&box[1]);
    		debugTri(&box[4],&box[0],&box[1]);

    		debugTri(&box[4],&box[6],&box[7]);
    		debugTri(&box[4],&box[5],&box[6]);

    		debugTri(&box[4],&box[7],&box[0]);
    		debugTri(&box[7],&box[3],&box[0]);
        }
        else
        {
    		debugLine(box[0], box[1]);
    		debugLine(box[1], box[2]);
    		debugLine(box[2], box[3]);
    		debugLine(box[3], box[0]);

    		debugLine(box[4], box[5]);
    		debugLine(box[5], box[6]);
    		debugLine(box[6], box[7]);
    		debugLine(box[7], box[4]);

    		debugLine(box[0], box[4]);
    		debugLine(box[1], box[5]);
    		debugLine(box[2], box[6]);
    		debugLine(box[3], box[7]);
    	}
    }


	PX_INLINE void debugRect2d(const DebugRect2d &d)
	{
		PxVec3 points[4];
		points[0] = physx::PxVec3(d.mX1,d.mY1,0.0f);
		points[1] = physx::PxVec3(d.mX2,d.mY1,0.0f);
		points[2] = physx::PxVec3(d.mX2,d.mY2,0.0f);
		points[3] = physx::PxVec3(d.mX1,d.mY2,0.0f);
		debugPolygon(4,points);
	}

	PX_INLINE void debugGradientLine(const DebugGradientLine &d)
	{
		debugLine(d.mP1,d.mP2,d.mC1,d.mC2);
	}

	PX_INLINE void debugRay(const DebugRay &d)
	{
		debugLine(d.mP1,d.mP2);
		PxVec3 dir  = d.mP2 - d.mP1;
		PxF32 mag = dir.normalize();
		PxF32 arrowSize = mCurrentState.mArrowSize;
		if ( arrowSize > (mag*0.2f ))
		{
			arrowSize = mag*0.2f;
		}
		PxVec3 ref(0,1,0);
		PxQuat quat;
		rotationArc(ref,dir,quat);
		PxMat44 matrix(quat);
		matrix.setPosition(d.mP2);

		PxU32 pcount = 0;
		PxVec3 points[24];
		PxVec3 *dest = points;

		for (PxF32 a=30; a<=360; a+=30)
		{
			PxF32 r = a*FM_DEG_TO_RAD;
			PxF32 x = PxCos(r)*arrowSize;
			PxF32 y = PxSin(r)*arrowSize;

			dest->x = x;
			dest->y = -3*arrowSize;
			dest->z = y;
			dest++;
			pcount++;
		}

		PxVec3 *prev = &points[(pcount-1)];
		PxVec3 *p = points;
		PxVec3 center(0, -2.5f*arrowSize, 0);
		PxVec3 top(0, 0, 0 );

		PxVec3 _center = matrix.transform(center);
		PxVec3 _top = matrix.transform(top);


		PxU32 saveState = mCurrentState.mStates;

		mCurrentState.setRenderState(DebugRenderState::SolidWireShaded);
		mCurrentState.mArrowColor = 0xFFFFFFFF;

		for (PxU32 i=0; i<pcount; i++)
		{
			PxVec3 _p = matrix.transform( *p );
			PxVec3 _prev = matrix.transform( *prev );

			debugTri(&_p,&_center,&_prev);
			debugTri(&_prev,&_top,&_p);

			prev = p;
			p++;
		}
		mCurrentState.mStates = saveState;

	}

	PX_INLINE void debugCylinder(const DebugCylinder &d)
	{
		const PxU32 numOfSegments = 4u << PxMin(d.mSubdivision, 6u); // this maxes out at 4^6 = 256 segments
		const PxReal segmentAngle = PxTwoPi / numOfSegments;
		const PxReal c = PxCos(segmentAngle);
		const PxReal s = PxSin(segmentAngle);
		const PxMat33 rotY(PxVec3(c, 0,-s), PxVec3(0, 1, 0), PxVec3(s, 0, c));

		const PxF32 radiusDiff = d.mRadius1 - d.mRadius2;
		PxVec3 heightVec(radiusDiff / 2.0f, d.mHeight / 2.0f, 0.0f);

		const PxF32 avgRadius = (d.mRadius1 + d.mRadius2) / 2.0f;
		PxVec3 currentVec(avgRadius, 0.0f, 0.0f);
		PxVec3 currentTangent(0.0f, 0.0f, 1.0f);
		PxVec3 currentNormal = heightVec.cross(currentTangent).getNormalized();

		const PxVec3 upperCenter(0.0f, d.mHeight / 2.0f, 0.0f);
		const PxVec3 lowerCenter(-upperCenter);


		if (mCurrentState.isSolid())
		{
			for( PxU32 i=0; i<numOfSegments; ++i )
			{
				const PxVec3 e0 = currentVec + heightVec;
				const PxVec3 e2 = currentVec - heightVec;
				const PxVec3 nC = currentNormal;

				currentVec = rotY.transform(currentVec);
				heightVec = rotY.transform(heightVec);
				currentTangent = rotY.transform(currentTangent);
				const PxVec3 e1 = currentVec + heightVec;
				const PxVec3 e3 = currentVec - heightVec;
				const PxVec3 nN = currentNormal = heightVec.cross(currentTangent).getNormalized();

				debugTri(&e0, &e2, &e3, &nC, &nC, &nN);
				debugTri(&e3, &e1, &e0, &nN, &nN, &nC);

				if (d.mCloseSides)
				{
					debugTri(&e0, &e1, &upperCenter);
					debugTri(&e2, &lowerCenter, &e3);
				}
			}
		}
		else
		{
			for( PxU32 i=0; i<numOfSegments; ++i )
			{
				const PxVec3 e0 = currentVec + heightVec;
				const PxVec3 e2 = currentVec - heightVec;

				const PxVec3 nextVec = rotY.transform(currentVec);
				heightVec = rotY.transform(heightVec);
				const PxVec3 e1 = nextVec + heightVec;
				const PxVec3 e3 = nextVec - heightVec;

				debugLine(e0, e2);
				debugLine(e0, e1);
				debugLine(e2, e3);

				if (d.mCloseSides)
				{
					debugLine(upperCenter, e0);
					debugLine(lowerCenter, e2);
				}
				currentVec = nextVec;
			}
		}
	}

	PX_INLINE void debugCircle(const DebugCircle &d)
	{
		const PxU32 numOfSegments = 4u << PxMin(d.mSubdivision, 6u); // this maxes out at 4^6 = 256 segments
		const PxReal segmentAngle = PxTwoPi / numOfSegments;
		const PxReal c = PxCos(segmentAngle);
		const PxReal s = PxSin(segmentAngle);
		const PxMat33 rotY(PxVec3(c, 0,-s), PxVec3(0, 1, 0), PxVec3(s, 0, c));

		PxVec3 currentVec(d.mRadius, 0.0f, 0.0f);
		for( PxU32 i=0; i<numOfSegments; ++i )
		{
			const PxVec3 p0 = currentVec;
			const PxVec3 p1 = rotY.transform(currentVec);

			debugLine(p0, p1);

			currentVec = p1;
		}
	}

	PX_INLINE void debugPolygon(PxU32 pcount,const PxVec3 *points)
	{
		if ( mCurrentState.isSolid() )
		{
			PX_ASSERT( pcount >= 3 );
			PX_ASSERT( pcount <= 256 );
			bool wasOverlay = mCurrentState.hasRenderState(DebugRenderState::SolidWireShaded);
			if( wasOverlay )
			{
				mCurrentState.clearRenderState(DebugRenderState::SolidWireShaded);
				mCurrentState.incrementChangeCount();
			}
			const PxVec3 *v1 = &points[0];
			const PxVec3 *v2 = &points[1];
			const PxVec3 *v3 = &points[2];
			debugTri(v1,v2,v3);
			for (PxU32 i=3; i<pcount; i++)
			{
				v2 = v3;
				v3 = &points[i];
				debugTri(v1,v2,v3);
			}
			if ( wasOverlay )
			{
				for (PxU32 i=0; i<(pcount-1); i++)
				{
					debugLine( points[i], points[i+1], mCurrentState.mArrowColor, mCurrentState.mArrowColor );
				}
				debugLine(points[pcount-1],points[0]);
				mCurrentState.setRenderState(DebugRenderState::SolidWireShaded);
				mCurrentState.incrementChangeCount();
			}
		}
		else
		{
			for (PxU32 i=0; i<(pcount-1); i++)
			{
				debugLine( points[i], points[i+1] );
			}
			debugLine(points[pcount-1],points[0]);
		}
	}

	// 
	PX_INLINE void debugPointCylinder(const DebugPointCylinder &d)
	{
		PxVec3 dir = d.mP2 - d.mP1;
		dir.normalize();

    	PxVec3 ref(0, 1, 0);

		PxQuat quat;

    	rotationArc(ref,dir,quat);

		PxMat44 matrix1(quat);
		PxMat44 matrix2(quat);

		matrix1.setPosition(d.mP2);
		matrix2.setPosition(d.mP1);


    	PxU32 pcount = 0;
    	PxVec3 points1[24];
    	PxVec3 points2[24];

    	PxVec3 *dest1 = points1;
    	PxVec3 *dest2 = points2;


    	for (PxF32 a=30; a<=360; a+=30)
    	{
    		PxF32 r = a*FM_DEG_TO_RAD;
    		PxF32 x = PxCos(r)*d.mRadius;
    		PxF32 y = PxSin(r)*d.mRadius;

    		PxVec3 p(x, 0, y);

			(*dest1) = matrix1.transform(p);
			(*dest2) = matrix2.transform(p);

			dest1++;
			dest2++;
    		pcount++;

    	}

		PX_ASSERT( pcount < 24 );

    	if ( mCurrentState.isSolid() )
    	{

			PxU32 saveState = mCurrentState.mStates;
			mCurrentState.clearRenderState(DebugRenderState::SolidWireShaded);
			mCurrentState.setRenderState(DebugRenderState::SolidShaded);
			mCurrentState.clearRenderState(DebugRenderState::CounterClockwise);

    		PxVec3 *prev1 = &points1[(pcount-1)];
    		PxVec3 *prev2 = &points2[(pcount-1)];

    		PxVec3 *scan1 = points1;
    		PxVec3 *scan2 = points2;

    		for (PxU32 i=0; i<pcount; i++)
    		{

    			debugTri(scan1,prev2,prev1);
    			debugTri(scan2,prev2,scan1);

    			prev1 = scan1;
    			prev2 = scan2;
    			scan1++;
    			scan2++;
    		}

			debugPolygon(pcount,points2);
			mCurrentState.setRenderState(DebugRenderState::CounterClockwise);
			debugPolygon(pcount,points1);

			mCurrentState.mStates = saveState;

    	}

		if ( !mCurrentState.hasRenderState(DebugRenderState::SolidShaded) || mCurrentState.hasRenderState(DebugRenderState::SolidWireShaded) )
    	{

			PxU32 color = mCurrentState.hasRenderState(DebugRenderState::SolidWireShaded) ? mCurrentState.mArrowColor : mCurrentState.mColor;
    		PxVec3 *prev1 = &points1[(pcount-1)];
    		PxVec3 *prev2 = &points2[(pcount-1)];

    		PxVec3 *scan1 = points1;
    		PxVec3 *scan2 = points2;
    		for (PxU32 i=0; i<pcount; i++)
    		{
    			debugLine(*scan1,*scan2,color,color);

    			debugLine(d.mP2,*scan1,color,color);
    			debugLine(d.mP1,*scan2,color,color);

    			debugLine(*prev1,*scan1,color,color);
    			debugLine(*prev2,*scan2,color,color);

    			prev1 = scan1;
    			prev2 = scan2;

    			scan1++;
    			scan2++;
    		}
    	}
	}

	PX_INLINE void debugThickRay(const DebugThickRay &d)
	{
		RenderState save = mCurrentState;

		mCurrentState.clearRenderState(DebugRenderState::SolidWireShaded);
		mCurrentState.setRenderState(DebugRenderState::SolidShaded);

		PxVec3 dir = d.mP2 - d.mP1;
		PxF32 mag = dir.normalize();
		PxF32 arrowSize = PxMin(PxMax(mCurrentState.mArrowSize, d.mRaySize * 1.3f), mag * 0.2f);

		PxVec3 ref(0,1,0);
		PxQuat quat;

		rotationArc(ref,dir,quat);

		PxMat44 matrix(quat);
		matrix.setPosition(d.mP2);


		PxU32 pcount = 0;
		PxVec3 points[24];
		PxVec3 *dest = points;

		for (PxF32 a=30; a<=360; a+=30)
		{
			PxF32 r = a*FM_DEG_TO_RAD;
			PxF32 x = PxCos(r)*arrowSize;
			PxF32 y = PxSin(r)*arrowSize;

			dest->x = x;
			dest->y = -3*arrowSize;
			dest->z = y;

			dest++;
			pcount++;
		}

		PxVec3 *prev = &points[(pcount-1)];
		PxVec3 *p = points;
		PxVec3 center(0, -2.5f*arrowSize, 0);
		PxVec3 top(0,0,0);

		PxVec3 _center;
		PxVec3 _top;

		_center = matrix.transform(center);
		_top	= matrix.transform(top);

		DebugPointCylinder dc(d.mP1,_center,d.mRaySize);
		debugPointCylinder(dc);
		
		mCurrentState = save;
		
		mCurrentState.setRenderState(DebugRenderState::SolidShaded);
		mCurrentState.mColor = mCurrentState.mArrowColor;
		mCurrentState.mArrowColor = 0xFFFFFFFF;

		for (PxU32 i=0; i<pcount; i++)
		{

			PxVec3 _p;
			PxVec3 _prev;

			_p = matrix.transform(*p);
			_prev = matrix.transform(*prev);

			debugTri(&_p,&_center,&_prev);
			debugTri(&_prev,&_top,&_p);

			prev = p;
			p++;
		}
		mCurrentState = save;

	}

	void debugPlane(const physx::PxVec3 &normal,physx::PxF32 dCoff,physx::PxF32 radius1,physx::PxF32 radius2)
	{
		physx::PxVec3 ref(0,1,0);
		physx::PxQuat quat;
		rotationArc(ref,normal,quat);
		physx::PxMat44 matrix(quat);

		physx::PxF32 stepsize = 360/20;

		physx::PxVec3 prev(0,0,0);

		physx::PxVec3 origin(0,-dCoff,0);
		physx::PxVec3 pos(origin), first(origin), center(origin);

		center = matrix.transform(origin);
		matrix.setPosition(center);

		for (physx::PxF32 d=0; d<360; d+=stepsize)
		{
			physx::PxF32 a = physx::degToRad(d);
			physx::PxVec3 _pos(PxCos(a)*radius1,0,PxSin(a)*radius2);
			pos = matrix.transform(_pos);

			debugLine(center,pos);

			if ( d == 0  )
			{
				first = pos;
			}
			else
			{
				debugLine(prev,pos);
			}
			prev = pos;
		}

		debugLine(first,pos);
	}



	PX_INLINE void debugPlane(const DebugPlane &d)
	{
		debugPlane(d.mNormal,d.mD,d.mRadius1*0.25f, d.mRadius2*0.25f);
		debugPlane(d.mNormal,d.mD,d.mRadius1*0.5f,  d.mRadius2*0.5f);
		debugPlane(d.mNormal,d.mD,d.mRadius1*0.75f, d.mRadius2*0.75f);
		debugPlane(d.mNormal,d.mD,d.mRadius1*1.0f,  d.mRadius2*1.0f);
	}

	PX_INLINE void debugTriNormals(const DebugTriNormals &d)
	{
		debugTri(&d.mP1,&d.mP2,&d.mP3,&d.mN1,&d.mN2,&d.mN3);
	}

	PX_INLINE void debugGradientTriNormals(const DebugGradientTriNormals &d)
	{
		debugTri(&d.mP1,&d.mP2,&d.mP3,&d.mN1,&d.mN2,&d.mN3,d.mC1,d.mC2,d.mC3,true);
	}

	PX_INLINE void debugSphere(const DebugSquashedSphere &d)
	{
		for (physx::PxU32 i = 0; i < 8; i++)
		{
			const PxVec3 p0 = simpleSpherePosition[simpleSphereIndices[i*3+0]];
			const PxVec3 p1 = simpleSpherePosition[simpleSphereIndices[i*3+1]];
			const PxVec3 p2 = simpleSpherePosition[simpleSphereIndices[i*3+2]];
			subdivideOnSphere((physx::PxI32)d.mSubdivision, p0, p1, p2, d.mRadius, 0.0f, 0.0f);
		}
	}


	PX_INLINE void debugSphere(const DebugSphere &d)
	{
		for (physx::PxU32 i = 0; i < 8; i++)
		{
			const PxVec3 p0 = simpleSpherePosition[simpleSphereIndices[i*3+0]];
			const PxVec3 p1 = simpleSpherePosition[simpleSphereIndices[i*3+1]];
			const PxVec3 p2 = simpleSpherePosition[simpleSphereIndices[i*3+2]];
			subdivideOnSphere((physx::PxI32)d.mSubdivision, p0, p1, p2, d.mRadius, 0.0f, 0.0f);
		}
	}

	void subdivideOnSphere(int subdivision, const PxVec3& p0, const PxVec3& p1, const PxVec3& p2, PxF32 radius, PxF32 height, PxF32 skew)
	{
		if (subdivision <= 0)
		{
			PxVec3 t[3];
			PxVec3 n[3] = { p0, p1, p2 };

			if (height > 0.0f || skew != 0.0f)
			{
				const PxF32 upper = PxSign(p0.y + p1.y + p2.y);

				const PxVec3 offset(0.0f, upper * height, 0.0f);
				if (skew != 0.0f)
				{
					const PxF32 scale = upper - skew;
					for (PxU32 i = 0; i < 3; i++)
					{
						const PxF32 ny = n[i].y;
						//const PxF32 sny =((ny - 1.0f) * scale) + upper;
						const PxF32 sny = upper > 0.0f ? (1.0f - (1.0f - ny) * scale) : (-1.0f + (1.0f + ny) * -scale);
						PX_ASSERT(PxAbs(sny) <= 1.0f);
						n[i].y = 0.0f;
						n[i].normalize();
						n[i] *= PxSqrt(1.0f - (sny * sny));
						n[i].y = sny;
						t[i] = n[i] * radius + offset;
					}
				}
				else
				{
					t[0] = p0 * radius + offset;
					t[1] = p1 * radius + offset;
					t[2] = p2 * radius + offset;
				}
			}
			else
			{
				t[0] = p0 * radius;
				t[1] = p1 * radius;
				t[2] = p2 * radius;
			}

			debugTri(t+0, t+1, t+2, n+0, n+1, n+2);
		}
		else
		{
			PxVec3 p01 = p0 + p1; p01.normalize();
			PxVec3 p12 = p1 + p2; p12.normalize();
			PxVec3 p20 = p2 + p0; p20.normalize();

			subdivideOnSphere(subdivision-1, p0, p01, p20, radius, height, skew);
			subdivideOnSphere(subdivision-1, p1, p12, p01, radius, height, skew);
			subdivideOnSphere(subdivision-1, p2, p20, p12, radius, height, skew);
			subdivideOnSphere(subdivision-1, p01, p12, p20, radius, height, skew);
		}
	}


	void subdivideOnSphere(int subdivision, const PxVec3& p0, const PxVec3& p1, const PxVec3& p2, const PxVec3 &radius, PxF32 height, PxF32 skew)
	{
		if (subdivision <= 0)
		{
			PxVec3 t[3];
			PxVec3 n[3] = { p0, p1, p2 };

			if (height > 0.0f || skew != 0.0f)
			{
				const PxF32 upper = PxSign(p0.y + p1.y + p2.y);

				const PxVec3 offset(0.0f, upper * height, 0.0f);
				if (skew != 0.0f)
				{
					const PxF32 scale = upper - skew;
					for (PxU32 i = 0; i < 3; i++)
					{
						const PxF32 ny = n[i].y;
						//const PxF32 sny =((ny - 1.0f) * scale) + upper;
						const PxF32 sny = upper > 0.0f ? (1.0f - (1.0f - ny) * scale) : (-1.0f + (1.0f + ny) * -scale);
						PX_ASSERT(PxAbs(sny) <= 1.0f);
						n[i].y = 0.0f;
						n[i].normalize();
						n[i] *= PxSqrt(1.0f - (sny * sny));
						n[i].y = sny;
						t[i] = n[i].multiply(radius) + offset;
					}
				}
				else
				{
					t[0] = p0.multiply(radius) + offset;
					t[1] = p1.multiply(radius) + offset;
					t[2] = p2.multiply(radius) + offset;
				}
			}
			else
			{
				t[0] = p0.multiply(radius);
				t[1] = p1.multiply(radius);
				t[2] = p2.multiply(radius);
			}

			debugTri(t+0, t+1, t+2, n+0, n+1, n+2);
		}
		else
		{
			PxVec3 p01 = p0 + p1; p01.normalize();
			PxVec3 p12 = p1 + p2; p12.normalize();
			PxVec3 p20 = p2 + p0; p20.normalize();

			subdivideOnSphere(subdivision-1, p0, p01, p20, radius, height, skew);
			subdivideOnSphere(subdivision-1, p1, p12, p01, radius, height, skew);
			subdivideOnSphere(subdivision-1, p2, p20, p12, radius, height, skew);
			subdivideOnSphere(subdivision-1, p01, p12, p20, radius, height, skew);
		}
	}



	PX_INLINE void debugCapsule(const DebugCapsule &d)
	{
		DebugCylinder c(d.mRadius,d.mHeight,d.mSubdivision,false);
		debugCylinder(c);

		const PxF32 height = d.mHeight * 0.5f;
		for (physx::PxU32 i = 0; i < 8; i++)
		{
			const PxVec3 p0 = simpleSpherePosition[simpleSphereIndices[i*3+0]];
			const PxVec3 p1 = simpleSpherePosition[simpleSphereIndices[i*3+1]];
			const PxVec3 p2 = simpleSpherePosition[simpleSphereIndices[i*3+2]];
			subdivideOnSphere((physx::PxI32)d.mSubdivision, p0, p1, p2, d.mRadius, height, 0.0f);
		}
	}

	void debugTaperedCapsule(const DebugTaperedCapsule& d)
	{
		PxMat44* oldPose = mCurrentState.mPose;
		PxMat44 newPose = PxMat44::createIdentity();

		PxU32 subdivision = d.mSubdivision;

		PxF32 radDiff = d.mRadius2 - d.mRadius1;
		const PxF32 sinAlpha = radDiff / PxSqrt(radDiff * radDiff + d.mHeight * d.mHeight); 

		PxF32 sphereSeparation = 0;
		PxF32 skew = 0;
		PxF32 radius[] = { d.mRadius1, d.mRadius2 };

		const PxU32 oldColor = mCurrentState.mColor;

		if (PxAbs(sinAlpha) < 1.0f)
		{
			const PxF32 cosAlpha = PxSqrt(1.0f - sinAlpha * sinAlpha);

			const PxU32 minSubdivision = (PxU32)(sinAlpha * sinAlpha * 4.0f) + 1;
			const PxU32 maxSubdivision = 6;
			subdivision = PxMin(PxMax(minSubdivision, d.mSubdivision), maxSubdivision);

			const PxF32 heightOffset = sinAlpha * (d.mRadius1 + d.mRadius2) / 2.0f;
			newPose.setPosition(newPose.getPosition() + PxVec3(0.0f, heightOffset, 0.0f));
			if (oldPose != NULL)
			{
				newPose = *oldPose * newPose;
			}

			// move the cylinder
			mCurrentState.mPose = &newPose;

			// shrink the cylinder
			const PxF32 height = d.mHeight - PxAbs(sinAlpha * (d.mRadius1 - d.mRadius2));

			DebugCylinder c(d.mRadius1 * cosAlpha, d.mRadius2 * cosAlpha, height, subdivision, false);
			debugCylinder(c);

			// reset current pose
			mCurrentState.mPose = oldPose;

			sphereSeparation = d.mHeight * 0.5f;
			skew = sinAlpha;
		}
		else
		{
			mCurrentState.mColor = 0x7f7fff; // light blue
			radius[0] = radius[1] = PxMax(d.mRadius1, d.mRadius2);
		}


		for (PxU32 i = 0; i < 8; i++)
		{
			PxVec3 p[] = 
			{
				simpleSpherePosition[simpleSphereIndices[i*3+0]],
				simpleSpherePosition[simpleSphereIndices[i*3+1]],
				simpleSpherePosition[simpleSphereIndices[i*3+2]]
			};

			subdivideOnSphere((physx::PxI32)subdivision, p[0], p[1], p[2], radius[i >> 2], sphereSeparation, skew);
		}

		mCurrentState.mColor = oldColor;
	}

	PX_INLINE void debugAxes(const DebugAxes &d)
	{

		PxU32 red    = getColor(255,  0,  0, 1.0f - d.mBrightness);
		PxU32 green  = getColor(  0,255,  0, 1.0f - d.mBrightness);
		PxU32 blue   = getColor(  0,  0,255, 1.0f - d.mBrightness);
		PxU32 yellow = getColor(255,255,  0, 1.0f - d.mBrightness);

		PxVec3 px(d.mDistance*4,0,0);
		PxVec3 py(0,d.mDistance*1.5f,0);
		PxVec3 pz(0,0,d.mDistance);

		px = d.mTransform.transform(px);
		py = d.mTransform.transform(py);
		pz = d.mTransform.transform(pz);
		PxVec3 t = d.mTransform.getPosition();

		RenderState save = mCurrentState;

		mCurrentState.mArrowSize = d.mDistance*0.1f;
		mCurrentState.mColor = yellow;
		mCurrentState.mArrowColor = yellow;
		mCurrentState.mStates = (mCurrentState.mStates & ~DebugRenderState::SolidWireShaded) | DebugRenderState::SolidShaded;
		DebugDetailedSphere ds(t, d.mDistance * 0.1f, 2);
		debugDetailedSphere(ds);

		mCurrentState.mStates = (mCurrentState.mStates & ~DebugRenderState::SolidShaded) | DebugRenderState::SolidWireShaded;

		{
			mCurrentState.mColor = red;
			mCurrentState.mArrowColor = red;
			DebugThickRay dr(t,px,d.mDistance*0.02f);
			debugThickRay(dr);
		}
		{
			mCurrentState.mColor = green;
			mCurrentState.mArrowColor = green;
			DebugThickRay dr(t,py,d.mDistance*0.02f);
			debugThickRay(dr);
		}
		{
			mCurrentState.mColor = blue;
			mCurrentState.mArrowColor = blue;
			DebugThickRay dr(t,pz,d.mDistance*0.02f);
			debugThickRay(dr);
		}

		mCurrentState = save;
	}

	PX_INLINE void debugArc(const DebugArc &d)
	{
		if ( d.mShowRoot )
		{
			debugLine(d.mCenter,d.mP1,0xFFFFFFFF,0xFFFFFFFF);
			debugLine(d.mCenter,d.mP2,0xFFFFFFFF,0xFFFFFFFF);
		}

		physx::PxVec3 v1 = d.mP1-d.mCenter;
		physx::PxF32 d1 = v1.normalize();
		physx::PxVec3 v2 = d.mP2-d.mCenter;
		physx::PxF32 d2 = v2.normalize();

		physx::PxQuat quat;
		rotationArc(v1,v2,quat);

		physx::PxQuat q1 = PxQuat::createIdentity();
		physx::PxQuat q2 = quat;

		physx::PxVec3 prev(0.0f);

		physx::PxI32 count = 0;
		for (physx::PxF32 st=0; st<=(1.01f); st+=0.05f)
		{
			physx::PxF32 dst = ((d2-d1)*st)+d1;
			physx::PxQuat q;
			q = physx::slerp(st,q1,q2);
			PxMat44 m(q);
			m.setPosition(d.mCenter);
			PxVec3 t = v1*dst;
			t = m.transform(t);
			if ( st != 0 )
			{
				if ( count == 20 )
				{
					DebugRay dr(prev,t);
					debugRay(dr);
				}
				else
					debugLine(prev,t);
			}
			prev = t;
			count++;
		}

	}

	PX_INLINE void debugThickArc(const DebugThickArc &d)
	{
		if ( d.mShowRoot )
		{
			debugLine(d.mCenter,d.mP1,0xFFFFFFFF,0xFFFFFFFF);
			debugLine(d.mCenter,d.mP2,0xFFFFFFFF,0xFFFFFFFF);
		}

		physx::PxVec3 v1 = d.mP1-d.mCenter;
		physx::PxF32 d1 = v1.normalize();
		physx::PxVec3 v2 = d.mP2-d.mCenter;
		physx::PxF32 d2 = v2.normalize();

		physx::PxQuat quat;
		rotationArc(v1,v2,quat);

		physx::PxQuat q1 = PxQuat::createIdentity();
		physx::PxQuat q2 = quat;

		physx::PxVec3 prev(0.0f);

		physx::PxI32 count = 0;
		for (physx::PxF32 st=0; st<=(1.01f); st+=0.05f)
		{
			physx::PxF32 dst = ((d2-d1)*st)+d1;
			physx::PxQuat q;
			q = physx::slerp(st,q1,q2);
			PxMat44 m(q);
			m.setPosition(d.mCenter);
			PxVec3 t = v1*dst;
			t = m.transform(t);
			if ( st != 0 )
			{
				if ( count == 20 )
				{
					physx::PxF32 asave = mCurrentState.mArrowSize;
					mCurrentState.mArrowSize = d.mThickness*4;
					DebugThickRay dr(prev,t,d.mThickness);
					debugThickRay(dr);
					mCurrentState.mArrowSize = asave;
				}
				else
				{
					physx::PxU32 save = mCurrentState.mStates;

					mCurrentState.clearRenderState(DebugRenderState::SolidWireShaded);
					mCurrentState.setRenderState(DebugRenderState::SolidShaded);

					DebugPointCylinder dc(prev,t,d.mThickness);
					debugPointCylinder(dc);

					mCurrentState.mStates = save;
				}
			}
			prev = t;
			count++;
		}
	}

	PX_INLINE void debugDetailedSphere(const DebugDetailedSphere &d)
	{
		PxMat44* save = mCurrentState.mPose;
		PxMat44 myPose = PxMat44::createIdentity();
		myPose.setPosition(d.mPos);
		if (save != NULL)
		{
			myPose = *save * myPose;
		}
		mCurrentState.mPose = &myPose;

		DebugSphere d2(d.mRadius, d.mStepCount);
		debugSphere(d2);

		mCurrentState.mPose = save;
	}

	void skipString(PxMemoryBuffer &mb)
	{
		char c;
		physx::PxU32 r = mb.read(&c,1);
		while ( r && c )
		{
			r = mb.read(&c,1);
		}
	}

	void debugGraph(const DebugGraphStream &dgs)
	{
		const void *data = (const void *)&dgs;
		PxMemoryBuffer mb(data,dgs.mSize);
		mb.setEndianMode(PxFileBuf::ENDIAN_NONE);
		PxIOStream stream(mb,dgs.mSize);
		physx::PxU32 cmd,size;
		stream >> cmd;
		stream >> size;
		PX_ASSERT(cmd==DebugCommand::DEBUG_GRAPH);
		PX_ASSERT(size==dgs.mSize);

		DebugGraphDesc d;

		stream >> d.mNumPoints;
		d.mGraphXLabel = (const char *) mb.getReadLoc();
		skipString(mb);
		d.mGraphYLabel = (const char *) mb.getReadLoc();
		skipString(mb);

		mb.alignRead(4);

		d.mPoints = (const physx::PxF32 *)mb.getReadLoc();
		mb.advanceReadLoc(sizeof(physx::PxU32)*d.mNumPoints);
		stream >> d.mCutOffLevel;
		stream >> d.mGraphMax;
		stream >> d.mGraphXPos;
		stream >> d.mGraphYPos;
		stream >> d.mGraphWidth;
		stream >> d.mGraphHeight;
		stream >> d.mGraphColor;
		stream >> d.mArrowColor;
		stream >> d.mColorSwitchIndex;
		debugGraph(d);
	}

	void debugGraph(DebugGraphDesc& graphDesc)
	{
		// todo where should colors go???
		const PxU32 black = getColor(0,   0,   0);
		const PxU32 blue  = getColor(0,   0, 255);
		const PxU32 green = getColor(0, 255,   0);

		RenderState saveState = mCurrentState;

		mCurrentState.setRenderState(DebugRenderState::ScreenSpace);
		mCurrentState.setRenderState(DebugRenderState::NoZbuffer);
		mCurrentState.clearRenderState(DebugRenderState::SolidShaded);

		mCurrentState.mTextScale = 0.1f;
		PxF32 textHeight = 0.04f;	//in screen space -- would be nice to know this!

		if(graphDesc.mCutOffLevel != 0.0f)
		{
			mCurrentState.setCurrentColor(blue, black);
			debugLine(
				PxVec3(graphDesc.mGraphXPos,							graphDesc.mGraphYPos + graphDesc.mCutOffLevel, 0.0f),
				PxVec3(graphDesc.mGraphXPos + graphDesc.mGraphWidth,	graphDesc.mGraphYPos + graphDesc.mCutOffLevel, 0.0f));
		}

		mCurrentState.setCurrentColor(graphDesc.mGraphColor, graphDesc.mArrowColor);	//set the draw colors
		if( strlen(graphDesc.mGraphXLabel) > 0 )
		{
			DebugText txt( physx::PxVec3(graphDesc.mGraphXPos, graphDesc.mGraphYPos - textHeight,0),physx::PxMat44::createIdentity(),graphDesc.mGraphXLabel);
			debugText(txt);
		}
		if( graphDesc.mGraphYLabel[0] )
		{
			DebugText txt(physx::PxVec3(graphDesc.mGraphXPos, graphDesc.mGraphYPos + graphDesc.mGraphHeight,	0), physx::PxMat44::createIdentity(), graphDesc.mGraphYLabel);
			debugText(txt);
		}

		PxF32 lastX = graphDesc.mGraphXPos;
		PxF32 lastY = graphDesc.mGraphYPos;
		for (PxU32 i = 0; i < graphDesc.mNumPoints; i++)
		{
			PxF32 pointY = graphDesc.mPoints[i];
			pointY = graphDesc.mGraphYPos + pointY * graphDesc.mGraphHeight / graphDesc.mGraphMax;	//scale to screen
			PxF32 x = graphDesc.mGraphXPos + graphDesc.mGraphWidth * i / graphDesc.mNumPoints;

			if (graphDesc.mColorSwitchIndex == i)
				mCurrentState.setCurrentColor(	graphDesc.mArrowColor,
				graphDesc.mGraphColor);	//swap the colors

			debugLine(PxVec3(lastX,lastY,0), PxVec3(x,pointY,0));
			lastY = pointY;
			lastX = x;
		}

		//graph axes
		mCurrentState.setCurrentColor(green, green);
		//screen space test line
		debugLine(	PxVec3(graphDesc.mGraphXPos,  graphDesc.mGraphYPos,0),
			PxVec3(graphDesc.mGraphXPos,  graphDesc.mGraphYPos + graphDesc.mGraphHeight,0));
		debugLine(	PxVec3(graphDesc.mGraphXPos,  graphDesc.mGraphYPos,0),
			PxVec3(graphDesc.mGraphXPos + graphDesc.mGraphWidth, graphDesc.mGraphYPos,0));

		mCurrentState = saveState;
	}


	virtual void setViewMatrix(const physx::PxMat44 &view)
	{
		mViewMatrix = view;
	}

private:

PxU32					 mLineVertexCount;
PxU32					 mMaxLineVertexCount;
RenderDebugVertex		*mLines;

PxU32					mSolidVertexCount;
PxU32					mMaxSolidVertexCount;
RenderDebugSolidVertex	*mTriangles;

RenderDebugInterface	*mInterface;
DisplayType				 mDisplayType;
RenderState				mCurrentState;
MyVectorFont			mVectorFont;
PxMat44					mViewMatrix;

};

//

PxProcessRenderDebug * createProcessRenderDebug(void)
{
	ProcessRenderDebug *m = PX_NEW(ProcessRenderDebug);
	return static_cast< PxProcessRenderDebug *>(m);
}


};
};
#endif
