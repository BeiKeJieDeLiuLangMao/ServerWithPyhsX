/*
 * Copyright (c) 2008-2015, NVIDIA CORPORATION.  All rights reserved.
 *
 * NVIDIA CORPORATION and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA CORPORATION is strictly prohibited.
 */


// This file was generated by NxParameterized/scripts/GenParameterized.pl
// Created: 2015.10.22 17:26:30

#include "ClothingAssetParameters_0p4.h"
#include <string.h>
#include <stdlib.h>

using namespace NxParameterized;

namespace physx
{
namespace apex
{

using namespace ClothingAssetParameters_0p4NS;

const char* const ClothingAssetParameters_0p4Factory::vptr =
    NxParameterized::getVptr<ClothingAssetParameters_0p4, ClothingAssetParameters_0p4::ClassAlignment>();

const physx::PxU32 NumParamDefs = 43;
static NxParameterized::DefinitionImpl* ParamDefTable; // now allocated in buildTree [NumParamDefs];


static const size_t ParamLookupChildrenTable[] =
{
	1, 3, 5, 15, 24, 25, 26, 34, 36, 40, 41, 42, 2, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14,
	16, 17, 18, 19, 20, 21, 22, 23, 27, 28, 29, 30, 31, 32, 33, 35, 37, 38, 39,
};

#define TENUM(type) physx::##type
#define CHILDREN(index) &ParamLookupChildrenTable[index]
static const NxParameterized::ParamLookupNode ParamLookupTable[NumParamDefs] =
{
	{ TYPE_STRUCT, false, 0, CHILDREN(0), 12 },
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->physicalMeshes), CHILDREN(12), 1 }, // physicalMeshes
	{ TYPE_REF, false, 1 * sizeof(NxParameterized::Interface*), NULL, 0 }, // physicalMeshes[]
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->graphicalLods), CHILDREN(13), 1 }, // graphicalLods
	{ TYPE_REF, false, 1 * sizeof(NxParameterized::Interface*), NULL, 0 }, // graphicalLods[]
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->simulation), CHILDREN(14), 9 }, // simulation
	{ TYPE_U32, false, (size_t)(&((SimulationParams_Type*)0)->hierarchicalLevels), NULL, 0 }, // simulation.hierarchicalLevels
	{ TYPE_F32, false, (size_t)(&((SimulationParams_Type*)0)->thickness), NULL, 0 }, // simulation.thickness
	{ TYPE_F32, false, (size_t)(&((SimulationParams_Type*)0)->selfcollisionThickness), NULL, 0 }, // simulation.selfcollisionThickness
	{ TYPE_VEC3, false, (size_t)(&((SimulationParams_Type*)0)->gravityDirection), NULL, 0 }, // simulation.gravityDirection
	{ TYPE_F32, false, (size_t)(&((SimulationParams_Type*)0)->sleepLinearVelocity), NULL, 0 }, // simulation.sleepLinearVelocity
	{ TYPE_BOOL, false, (size_t)(&((SimulationParams_Type*)0)->disableCCD), NULL, 0 }, // simulation.disableCCD
	{ TYPE_BOOL, false, (size_t)(&((SimulationParams_Type*)0)->untangling), NULL, 0 }, // simulation.untangling
	{ TYPE_BOOL, false, (size_t)(&((SimulationParams_Type*)0)->selfcollision), NULL, 0 }, // simulation.selfcollision
	{ TYPE_BOOL, false, (size_t)(&((SimulationParams_Type*)0)->twowayInteraction), NULL, 0 }, // simulation.twowayInteraction
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->bones), CHILDREN(23), 1 }, // bones
	{ TYPE_STRUCT, false, 1 * sizeof(BoneEntry_Type), CHILDREN(24), 7 }, // bones[]
	{ TYPE_I32, false, (size_t)(&((BoneEntry_Type*)0)->internalIndex), NULL, 0 }, // bones[].internalIndex
	{ TYPE_I32, false, (size_t)(&((BoneEntry_Type*)0)->externalIndex), NULL, 0 }, // bones[].externalIndex
	{ TYPE_U32, false, (size_t)(&((BoneEntry_Type*)0)->numMeshReferenced), NULL, 0 }, // bones[].numMeshReferenced
	{ TYPE_U32, false, (size_t)(&((BoneEntry_Type*)0)->numRigidBodiesReferenced), NULL, 0 }, // bones[].numRigidBodiesReferenced
	{ TYPE_I32, false, (size_t)(&((BoneEntry_Type*)0)->parentIndex), NULL, 0 }, // bones[].parentIndex
	{ TYPE_MAT34, false, (size_t)(&((BoneEntry_Type*)0)->bindPose), NULL, 0 }, // bones[].bindPose
	{ TYPE_STRING, false, (size_t)(&((BoneEntry_Type*)0)->name), NULL, 0 }, // bones[].name
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->bonesReferenced), NULL, 0 }, // bonesReferenced
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->bonesReferencedByMesh), NULL, 0 }, // bonesReferencedByMesh
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->boneActors), CHILDREN(31), 1 }, // boneActors
	{ TYPE_STRUCT, false, 1 * sizeof(ActorEntry_Type), CHILDREN(32), 6 }, // boneActors[]
	{ TYPE_I32, false, (size_t)(&((ActorEntry_Type*)0)->boneIndex), NULL, 0 }, // boneActors[].boneIndex
	{ TYPE_U32, false, (size_t)(&((ActorEntry_Type*)0)->convexVerticesStart), NULL, 0 }, // boneActors[].convexVerticesStart
	{ TYPE_U32, false, (size_t)(&((ActorEntry_Type*)0)->convexVerticesCount), NULL, 0 }, // boneActors[].convexVerticesCount
	{ TYPE_F32, false, (size_t)(&((ActorEntry_Type*)0)->capsuleRadius), NULL, 0 }, // boneActors[].capsuleRadius
	{ TYPE_F32, false, (size_t)(&((ActorEntry_Type*)0)->capsuleHeight), NULL, 0 }, // boneActors[].capsuleHeight
	{ TYPE_MAT34, false, (size_t)(&((ActorEntry_Type*)0)->localPose), NULL, 0 }, // boneActors[].localPose
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->boneVertices), CHILDREN(38), 1 }, // boneVertices
	{ TYPE_VEC3, false, 1 * sizeof(physx::PxVec3), NULL, 0 }, // boneVertices[]
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->cookedData), CHILDREN(39), 1 }, // cookedData
	{ TYPE_STRUCT, false, 1 * sizeof(CookedEntry_Type), CHILDREN(40), 2 }, // cookedData[]
	{ TYPE_F32, false, (size_t)(&((CookedEntry_Type*)0)->scale), NULL, 0 }, // cookedData[].scale
	{ TYPE_REF, false, (size_t)(&((CookedEntry_Type*)0)->cookedData), NULL, 0 }, // cookedData[].cookedData
	{ TYPE_BOUNDS3, false, (size_t)(&((ParametersStruct*)0)->boundingBox), NULL, 0 }, // boundingBox
	{ TYPE_REF, false, (size_t)(&((ParametersStruct*)0)->materialLibrary), NULL, 0 }, // materialLibrary
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->materialIndex), NULL, 0 }, // materialIndex
};


bool ClothingAssetParameters_0p4::mBuiltFlag = false;
NxParameterized::MutexType ClothingAssetParameters_0p4::mBuiltFlagMutex;

ClothingAssetParameters_0p4::ClothingAssetParameters_0p4(NxParameterized::Traits* traits, void* buf, PxI32* refCount) :
	NxParameters(traits, buf, refCount)
{
	//mParameterizedTraits->registerFactory(className(), &ClothingAssetParameters_0p4FactoryInst);

	if (!buf) //Do not init data if it is inplace-deserialized
	{
		initDynamicArrays();
		initStrings();
		initReferences();
		initDefaults();
	}
}

ClothingAssetParameters_0p4::~ClothingAssetParameters_0p4()
{
	freeStrings();
	freeReferences();
	freeDynamicArrays();
}

void ClothingAssetParameters_0p4::destroy()
{
	// We cache these fields here to avoid overwrite in destructor
	bool doDeallocateSelf = mDoDeallocateSelf;
	NxParameterized::Traits* traits = mParameterizedTraits;
	physx::PxI32* refCount = mRefCount;
	void* buf = mBuffer;

	this->~ClothingAssetParameters_0p4();

	NxParameters::destroy(this, traits, doDeallocateSelf, refCount, buf);
}

const NxParameterized::DefinitionImpl* ClothingAssetParameters_0p4::getParameterDefinitionTree(void)
{
	if (!mBuiltFlag) // Double-checked lock
	{
		NxParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

const NxParameterized::DefinitionImpl* ClothingAssetParameters_0p4::getParameterDefinitionTree(void) const
{
	ClothingAssetParameters_0p4* tmpParam = const_cast<ClothingAssetParameters_0p4*>(this);

	if (!mBuiltFlag) // Double-checked lock
	{
		NxParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			tmpParam->buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

NxParameterized::ErrorType ClothingAssetParameters_0p4::getParameterHandle(const char* long_name, Handle& handle) const
{
	ErrorType Ret = NxParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

NxParameterized::ErrorType ClothingAssetParameters_0p4::getParameterHandle(const char* long_name, Handle& handle)
{
	ErrorType Ret = NxParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

void ClothingAssetParameters_0p4::getVarPtr(const Handle& handle, void*& ptr, size_t& offset) const
{
	ptr = getVarPtrHelper(&ParamLookupTable[0], const_cast<ClothingAssetParameters_0p4::ParametersStruct*>(&parameters()), handle, offset);
}


/* Dynamic Handle Indices */
/* [0] - physicalMeshes (not an array of structs) */
/* [0] - graphicalLods (not an array of structs) */
/* [1,6] - bones.name */
/* [1,1] - cookedData.cookedData */

void ClothingAssetParameters_0p4::freeParameterDefinitionTable(NxParameterized::Traits* traits)
{
	if (!traits)
	{
		return;
	}

	if (!mBuiltFlag) // Double-checked lock
	{
		return;
	}

	NxParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);

	if (!mBuiltFlag)
	{
		return;
	}

	for (physx::PxU32 i = 0; i < NumParamDefs; ++i)
	{
		ParamDefTable[i].~DefinitionImpl();
	}

	traits->free(ParamDefTable);

	mBuiltFlag = false;
}

#define PDEF_PTR(index) (&ParamDefTable[index])

void ClothingAssetParameters_0p4::buildTree(void)
{

	physx::PxU32 allocSize = sizeof(NxParameterized::DefinitionImpl) * NumParamDefs;
	ParamDefTable = (NxParameterized::DefinitionImpl*)(mParameterizedTraits->alloc(allocSize));
	memset(static_cast<void*>(ParamDefTable), 0, allocSize);

	for (physx::PxU32 i = 0; i < NumParamDefs; ++i)
	{
		NX_PARAM_PLACEMENT_NEW(ParamDefTable + i, NxParameterized::DefinitionImpl)(*mParameterizedTraits);
	}

	// Initialize DefinitionImpl node: nodeIndex=0, longName=""
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[0];
		ParamDef->init("", TYPE_STRUCT, "STRUCT", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=1, longName="physicalMeshes"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[1];
		ParamDef->init("physicalMeshes", TYPE_ARRAY, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		ParamDefTable[1].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		HintTable[1].init("longDescription", "These are used for multiple graphical LoDs.", true);
		HintTable[2].init("shortDescription", "An Array of physical meshes", true);
		ParamDefTable[1].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "ClothingPhysicalMeshParameters" };
		ParamDefTable[1].setRefVariantVals((const char**)RefVariantVals, 1);


		ParamDef->setArraySize(-1);
		static const physx::PxU8 dynHandleIndices[1] = { 0, };
		ParamDef->setDynamicHandleIndicesMap(dynHandleIndices, 1);

	}

	// Initialize DefinitionImpl node: nodeIndex=2, longName="physicalMeshes[]"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[2];
		ParamDef->init("physicalMeshes", TYPE_REF, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		ParamDefTable[2].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		HintTable[1].init("longDescription", "These are used for multiple graphical LoDs.", true);
		HintTable[2].init("shortDescription", "An Array of physical meshes", true);
		ParamDefTable[2].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "ClothingPhysicalMeshParameters" };
		ParamDefTable[2].setRefVariantVals((const char**)RefVariantVals, 1);



	}

	// Initialize DefinitionImpl node: nodeIndex=3, longName="graphicalLods"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[3];
		ParamDef->init("graphicalLods", TYPE_ARRAY, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		ParamDefTable[3].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		HintTable[1].init("longDescription", "Each LoD contains a graphical mesh and a reference to a physical mesh.", true);
		HintTable[2].init("shortDescription", "An array of graphical Lods.", true);
		ParamDefTable[3].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "ClothingGraphicalLodParameters" };
		ParamDefTable[3].setRefVariantVals((const char**)RefVariantVals, 1);


		ParamDef->setArraySize(-1);
		static const physx::PxU8 dynHandleIndices[1] = { 0, };
		ParamDef->setDynamicHandleIndicesMap(dynHandleIndices, 1);

	}

	// Initialize DefinitionImpl node: nodeIndex=4, longName="graphicalLods[]"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[4];
		ParamDef->init("graphicalLods", TYPE_REF, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		ParamDefTable[4].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		HintTable[1].init("longDescription", "Each LoD contains a graphical mesh and a reference to a physical mesh.", true);
		HintTable[2].init("shortDescription", "An array of graphical Lods.", true);
		ParamDefTable[4].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "ClothingGraphicalLodParameters" };
		ParamDefTable[4].setRefVariantVals((const char**)RefVariantVals, 1);



	}

	// Initialize DefinitionImpl node: nodeIndex=5, longName="simulation"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[5];
		ParamDef->init("simulation", TYPE_STRUCT, "SimulationParams", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=6, longName="simulation.hierarchicalLevels"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[6];
		ParamDef->init("hierarchicalLevels", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Corresponds to NxClothMeshDesc::numHierarchyLevels.\nThis is orthogonal to the Hard Stretch Limitation in the Clothing Material.\n", true);
		HintTable[1].init("shortDescription", "The number of cloth hierarhies. Only used to prevent stretching", true);
		ParamDefTable[6].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=7, longName="simulation.thickness"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[7];
		ParamDef->init("thickness", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Each cloth particle will minimaly have as much distance to any collision volume.\nMost stable when this value corresponds roughly half the average edge length.\nCan be increased to prevent penetration artifacts.\n", true);
		HintTable[1].init("shortDescription", "Minimal amount of separation between cloth particles and collision volumes.", true);
		ParamDefTable[7].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=8, longName="simulation.selfcollisionThickness"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[8];
		ParamDef->init("selfcollisionThickness", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This feature prevents meshes from self-intersecting. Only works properly when configured properly.", true);
		HintTable[1].init("shortDescription", "Minimal amount of distance particles will keep of each other.", true);
		ParamDefTable[8].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=9, longName="simulation.gravityDirection"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[9];
		ParamDef->init("gravityDirection", TYPE_VEC3, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Direction of gravity for this asset.", true);
		ParamDefTable[9].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=10, longName="simulation.sleepLinearVelocity"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[10];
		ParamDef->init("sleepLinearVelocity", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Most clothing doesn't need it, but it might be useful for smaller assets like flags and the like.", true);
		HintTable[1].init("shortDescription", "Clothing will fall asleep if every vertex is slower than this velocity", true);
		ParamDefTable[10].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=11, longName="simulation.disableCCD"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[11];
		ParamDef->init("disableCCD", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "When turning off CCD, cloth particles can tunnel through fast moving collision volumes. But sometimes\nill turning collision volumes can excert large velocities on particles. This can help prevent it.\n", true);
		HintTable[1].init("shortDescription", "Turn off CCD when colliding cloth particles with collision volumes", true);
		ParamDefTable[11].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=12, longName="simulation.untangling"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[12];
		ParamDef->init("untangling", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This feature is highly experimental and still rather slow. Only use when self-collision could not\nhelp adequately.\n", true);
		HintTable[1].init("shortDescription", "EXPERIMENTAL: Untangle Cloth when it's entangled.", true);
		ParamDefTable[12].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=13, longName="simulation.selfcollision"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[13];
		ParamDef->init("selfcollision", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Turn self-collision on/off", true);
		ParamDefTable[13].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=14, longName="simulation.twowayInteraction"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[14];
		ParamDef->init("twowayInteraction", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "For clothing this is normally not needed, as clothing should only follow the kinematic shapes. Needed when interacting\nwith dynamic rigid bodies that need to be influenced by clothing.\n", true);
		HintTable[1].init("shortDescription", "Make use of twoway interaction", true);
		ParamDefTable[14].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=15, longName="bones"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[15];
		ParamDef->init("bones", TYPE_ARRAY, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Each bone contains a bind pose and reference counters.", true);
		HintTable[1].init("shortDescription", "Array of Bones", true);
		ParamDefTable[15].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
		static const physx::PxU8 dynHandleIndices[2] = { 1, 6, };
		ParamDef->setDynamicHandleIndicesMap(dynHandleIndices, 2);

	}

	// Initialize DefinitionImpl node: nodeIndex=16, longName="bones[]"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[16];
		ParamDef->init("bones", TYPE_STRUCT, "BoneEntry", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Each bone contains a bind pose and reference counters.", true);
		HintTable[1].init("shortDescription", "Array of Bones", true);
		ParamDefTable[16].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=17, longName="bones[].internalIndex"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[17];
		ParamDef->init("internalIndex", TYPE_I32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This usually corresponds to the array position this element is at.", true);
		HintTable[1].init("shortDescription", "The index used internally for this bone.", true);
		ParamDefTable[17].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=18, longName="bones[].externalIndex"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[18];
		ParamDef->init("externalIndex", TYPE_I32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The index that was given by the application", true);
		ParamDefTable[18].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=19, longName="bones[].numMeshReferenced"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[19];
		ParamDef->init("numMeshReferenced", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The number of mesh vertices that have a non-zero weight to this bone.", true);
		ParamDefTable[19].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=20, longName="bones[].numRigidBodiesReferenced"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[20];
		ParamDef->init("numRigidBodiesReferenced", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The number of collision volumes attached to this bone", true);
		ParamDefTable[20].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=21, longName="bones[].parentIndex"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[21];
		ParamDef->init("parentIndex", TYPE_I32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The (internal) index of the parent bone", true);
		ParamDefTable[21].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=22, longName="bones[].bindPose"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[22];
		ParamDef->init("bindPose", TYPE_MAT34, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The matrix this bone has in the default pose", true);
		ParamDefTable[22].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=23, longName="bones[].name"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[23];
		ParamDef->init("name", TYPE_STRING, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The name of this bone", true);
		ParamDefTable[23].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=24, longName="bonesReferenced"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[24];
		ParamDef->init("bonesReferenced", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Any bone in the bones array beyond this number is completely useless.", true);
		HintTable[1].init("shortDescription", "Number of bones actually used by any of the meshes or collision volumes.", true);
		ParamDefTable[24].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=25, longName="bonesReferencedByMesh"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[25];
		ParamDef->init("bonesReferencedByMesh", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Bones beyond this index can be used for collision volumes or not at all. This number is smaller or\nequal the 'bonesReferenced' number.\n", true);
		HintTable[1].init("shortDescription", "Number of bones actually used by any of the meshes", true);
		ParamDefTable[25].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=26, longName="boneActors"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[26];
		ParamDef->init("boneActors", TYPE_ARRAY, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Each collision volume belongs to a bone and contains a description of its shape.", true);
		HintTable[1].init("shortDescription", "Array of collision volumes", true);
		ParamDefTable[26].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=27, longName="boneActors[]"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[27];
		ParamDef->init("boneActors", TYPE_STRUCT, "ActorEntry", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Each collision volume belongs to a bone and contains a description of its shape.", true);
		HintTable[1].init("shortDescription", "Array of collision volumes", true);
		ParamDefTable[27].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=28, longName="boneActors[].boneIndex"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[28];
		ParamDef->init("boneIndex", TYPE_I32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The (internal) index this collision volume is attached to", true);
		ParamDefTable[28].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=29, longName="boneActors[].convexVerticesStart"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[29];
		ParamDef->init("convexVerticesStart", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Index into the boneVertices array where the list of vertices for this shape starts.", true);
		ParamDefTable[29].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=30, longName="boneActors[].convexVerticesCount"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[30];
		ParamDef->init("convexVerticesCount", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The number vertices that make up this convex.", true);
		ParamDefTable[30].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=31, longName="boneActors[].capsuleRadius"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[31];
		ParamDef->init("capsuleRadius", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The radius of the capsule that describes this collision volume.", true);
		ParamDefTable[31].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=32, longName="boneActors[].capsuleHeight"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[32];
		ParamDef->init("capsuleHeight", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The height of the capsule that describes this collision volume.", true);
		ParamDefTable[32].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=33, longName="boneActors[].localPose"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[33];
		ParamDef->init("localPose", TYPE_MAT34, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The pose this collision volume has relative to the bone.", true);
		ParamDefTable[33].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=34, longName="boneVertices"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[34];
		ParamDef->init("boneVertices", TYPE_ARRAY, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "All convexes use the same array but different parts of it.", true);
		HintTable[1].init("shortDescription", "Array of vertices that belong to one or more convex collision volumes", true);
		ParamDefTable[34].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=35, longName="boneVertices[]"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[35];
		ParamDef->init("boneVertices", TYPE_VEC3, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "All convexes use the same array but different parts of it.", true);
		HintTable[1].init("shortDescription", "Array of vertices that belong to one or more convex collision volumes", true);
		ParamDefTable[35].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=36, longName="cookedData"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[36];
		ParamDef->init("cookedData", TYPE_ARRAY, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Various versions of cooked data", true);
		ParamDefTable[36].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
		static const physx::PxU8 dynHandleIndices[2] = { 1, 1, };
		ParamDef->setDynamicHandleIndicesMap(dynHandleIndices, 2);

	}

	// Initialize DefinitionImpl node: nodeIndex=37, longName="cookedData[]"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[37];
		ParamDef->init("cookedData", TYPE_STRUCT, "CookedEntry", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Various versions of cooked data", true);
		ParamDefTable[37].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=38, longName="cookedData[].scale"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[38];
		ParamDef->init("scale", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "", true);
		ParamDefTable[38].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=39, longName="cookedData[].cookedData"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[39];
		ParamDef->init("cookedData", TYPE_REF, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		ParamDefTable[39].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		HintTable[1].init("shortDescription", "Data cooked at runtime", true);
		ParamDefTable[39].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "ClothingCookedParam" };
		ParamDefTable[39].setRefVariantVals((const char**)RefVariantVals, 1);



	}

	// Initialize DefinitionImpl node: nodeIndex=40, longName="boundingBox"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[40];
		ParamDef->init("boundingBox", TYPE_BOUNDS3, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This contains the simulated as well as the animated vertices.", true);
		HintTable[1].init("shortDescription", "The Bounding-Box of the Asset", true);
		ParamDefTable[40].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=41, longName="materialLibrary"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[41];
		ParamDef->init("materialLibrary", TYPE_REF, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		ParamDefTable[41].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		HintTable[1].init("shortDescription", "The Material Library for this asset", true);
		ParamDefTable[41].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "ClothingMaterialLibraryParameters" };
		ParamDefTable[41].setRefVariantVals((const char**)RefVariantVals, 1);



	}

	// Initialize DefinitionImpl node: nodeIndex=42, longName="materialIndex"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[42];
		ParamDef->init("materialIndex", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Default index for the material in the library", true);
		ParamDefTable[42].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// SetChildren for: nodeIndex=0, longName=""
	{
		static Definition* Children[12];
		Children[0] = PDEF_PTR(1);
		Children[1] = PDEF_PTR(3);
		Children[2] = PDEF_PTR(5);
		Children[3] = PDEF_PTR(15);
		Children[4] = PDEF_PTR(24);
		Children[5] = PDEF_PTR(25);
		Children[6] = PDEF_PTR(26);
		Children[7] = PDEF_PTR(34);
		Children[8] = PDEF_PTR(36);
		Children[9] = PDEF_PTR(40);
		Children[10] = PDEF_PTR(41);
		Children[11] = PDEF_PTR(42);

		ParamDefTable[0].setChildren(Children, 12);
	}

	// SetChildren for: nodeIndex=1, longName="physicalMeshes"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(2);

		ParamDefTable[1].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=3, longName="graphicalLods"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(4);

		ParamDefTable[3].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=5, longName="simulation"
	{
		static Definition* Children[9];
		Children[0] = PDEF_PTR(6);
		Children[1] = PDEF_PTR(7);
		Children[2] = PDEF_PTR(8);
		Children[3] = PDEF_PTR(9);
		Children[4] = PDEF_PTR(10);
		Children[5] = PDEF_PTR(11);
		Children[6] = PDEF_PTR(12);
		Children[7] = PDEF_PTR(13);
		Children[8] = PDEF_PTR(14);

		ParamDefTable[5].setChildren(Children, 9);
	}

	// SetChildren for: nodeIndex=15, longName="bones"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(16);

		ParamDefTable[15].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=16, longName="bones[]"
	{
		static Definition* Children[7];
		Children[0] = PDEF_PTR(17);
		Children[1] = PDEF_PTR(18);
		Children[2] = PDEF_PTR(19);
		Children[3] = PDEF_PTR(20);
		Children[4] = PDEF_PTR(21);
		Children[5] = PDEF_PTR(22);
		Children[6] = PDEF_PTR(23);

		ParamDefTable[16].setChildren(Children, 7);
	}

	// SetChildren for: nodeIndex=26, longName="boneActors"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(27);

		ParamDefTable[26].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=27, longName="boneActors[]"
	{
		static Definition* Children[6];
		Children[0] = PDEF_PTR(28);
		Children[1] = PDEF_PTR(29);
		Children[2] = PDEF_PTR(30);
		Children[3] = PDEF_PTR(31);
		Children[4] = PDEF_PTR(32);
		Children[5] = PDEF_PTR(33);

		ParamDefTable[27].setChildren(Children, 6);
	}

	// SetChildren for: nodeIndex=34, longName="boneVertices"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(35);

		ParamDefTable[34].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=36, longName="cookedData"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(37);

		ParamDefTable[36].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=37, longName="cookedData[]"
	{
		static Definition* Children[2];
		Children[0] = PDEF_PTR(38);
		Children[1] = PDEF_PTR(39);

		ParamDefTable[37].setChildren(Children, 2);
	}

	mBuiltFlag = true;

}
void ClothingAssetParameters_0p4::initStrings(void)
{
}

void ClothingAssetParameters_0p4::initDynamicArrays(void)
{
	physicalMeshes.buf = NULL;
	physicalMeshes.isAllocated = true;
	physicalMeshes.elementSize = sizeof(NxParameterized::Interface*);
	physicalMeshes.arraySizes[0] = 0;
	graphicalLods.buf = NULL;
	graphicalLods.isAllocated = true;
	graphicalLods.elementSize = sizeof(NxParameterized::Interface*);
	graphicalLods.arraySizes[0] = 0;
	bones.buf = NULL;
	bones.isAllocated = true;
	bones.elementSize = sizeof(BoneEntry_Type);
	bones.arraySizes[0] = 0;
	boneActors.buf = NULL;
	boneActors.isAllocated = true;
	boneActors.elementSize = sizeof(ActorEntry_Type);
	boneActors.arraySizes[0] = 0;
	boneVertices.buf = NULL;
	boneVertices.isAllocated = true;
	boneVertices.elementSize = sizeof(physx::PxVec3);
	boneVertices.arraySizes[0] = 0;
	cookedData.buf = NULL;
	cookedData.isAllocated = true;
	cookedData.elementSize = sizeof(CookedEntry_Type);
	cookedData.arraySizes[0] = 0;
}

void ClothingAssetParameters_0p4::initDefaults(void)
{

	freeStrings();
	freeReferences();
	freeDynamicArrays();
	simulation.hierarchicalLevels = physx::PxU32(0);
	simulation.thickness = physx::PxF32(0.01);
	simulation.selfcollisionThickness = physx::PxF32(0.01);
	simulation.gravityDirection = physx::PxVec3(PxVec3(0.0f));
	simulation.sleepLinearVelocity = physx::PxF32(-1.0);
	simulation.disableCCD = bool(false);
	simulation.untangling = bool(false);
	simulation.selfcollision = bool(false);
	simulation.twowayInteraction = bool(false);
	bonesReferenced = physx::PxU32(0);
	bonesReferencedByMesh = physx::PxU32(0);
	boundingBox = physx::PxBounds3(physx::PxVec3(0.0f), physx::PxVec3(0.0f));
	materialIndex = physx::PxU32(0);

	initDynamicArrays();
	initStrings();
	initReferences();
}

void ClothingAssetParameters_0p4::initReferences(void)
{
	materialLibrary = NULL;

}

void ClothingAssetParameters_0p4::freeDynamicArrays(void)
{
	if (physicalMeshes.isAllocated && physicalMeshes.buf)
	{
		mParameterizedTraits->free(physicalMeshes.buf);
	}
	if (graphicalLods.isAllocated && graphicalLods.buf)
	{
		mParameterizedTraits->free(graphicalLods.buf);
	}
	if (bones.isAllocated && bones.buf)
	{
		mParameterizedTraits->free(bones.buf);
	}
	if (boneActors.isAllocated && boneActors.buf)
	{
		mParameterizedTraits->free(boneActors.buf);
	}
	if (boneVertices.isAllocated && boneVertices.buf)
	{
		mParameterizedTraits->free(boneVertices.buf);
	}
	if (cookedData.isAllocated && cookedData.buf)
	{
		mParameterizedTraits->free(cookedData.buf);
	}
}

void ClothingAssetParameters_0p4::freeStrings(void)
{

	for (int i = 0; i < bones.arraySizes[0]; ++i)
	{
		if (bones.buf[i].name.isAllocated && bones.buf[i].name.buf)
		{
			mParameterizedTraits->strfree((char*)bones.buf[i].name.buf);
		}
	}
}

void ClothingAssetParameters_0p4::freeReferences(void)
{

	for (int i = 0; i < physicalMeshes.arraySizes[0]; ++i)
	{
		if (physicalMeshes.buf[i])
		{
			physicalMeshes.buf[i]->destroy();
		}
	}

	for (int i = 0; i < graphicalLods.arraySizes[0]; ++i)
	{
		if (graphicalLods.buf[i])
		{
			graphicalLods.buf[i]->destroy();
		}
	}

	for (int i = 0; i < cookedData.arraySizes[0]; i++)
	{
		if (cookedData.buf[i].cookedData)
		{
			cookedData.buf[i].cookedData->destroy();
		}
	}
	if (materialLibrary)
	{
		materialLibrary->destroy();
	}

}

} // namespace apex
} // namespace physx
