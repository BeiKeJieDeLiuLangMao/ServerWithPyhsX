/*
 * Copyright (c) 2008-2015, NVIDIA CORPORATION.  All rights reserved.
 *
 * NVIDIA CORPORATION and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA CORPORATION is strictly prohibited.
 */


// This file was generated by NxParameterized/scripts/GenParameterized.pl
// Created: 2015.10.22 17:26:30

#include "DestructibleAssetParameters_0p17.h"
#include <string.h>
#include <stdlib.h>

using namespace NxParameterized;

namespace physx
{
namespace apex
{

using namespace DestructibleAssetParameters_0p17NS;

const char* const DestructibleAssetParameters_0p17Factory::vptr =
    NxParameterized::getVptr<DestructibleAssetParameters_0p17, DestructibleAssetParameters_0p17::ClassAlignment>();

const physx::PxU32 NumParamDefs = 119;
static NxParameterized::DefinitionImpl* ParamDefTable; // now allocated in buildTree [NumParamDefs];


static const size_t ParamLookupChildrenTable[] =
{
	1, 2, 3, 4, 5, 21, 38, 39, 49, 51, 53, 85, 96, 97, 98, 99, 100, 101, 106, 108, 109,
	111, 113, 114, 115, 116, 117, 6, 7, 8, 9, 13, 17, 18, 19, 20, 10, 11, 12, 14, 15,
	16, 22, 23, 24, 25, 26, 30, 34, 35, 36, 37, 27, 28, 29, 31, 32, 33, 40, 41, 42, 43,
	44, 45, 46, 47, 48, 50, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
	68, 76, 77, 78, 79, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 86, 87, 88, 89,
	90, 91, 92, 93, 94, 95, 102, 103, 104, 105, 107, 110, 112, 118,
};

#define TENUM(type) physx::##type
#define CHILDREN(index) &ParamLookupChildrenTable[index]
static const NxParameterized::ParamLookupNode ParamLookupTable[NumParamDefs] =
{
	{ TYPE_STRUCT, false, 0, CHILDREN(0), 27 },
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->comments), NULL, 0 }, // comments
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->depthCount), NULL, 0 }, // depthCount
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->originalDepthCount), NULL, 0 }, // originalDepthCount
	{ TYPE_BOUNDS3, false, (size_t)(&((ParametersStruct*)0)->bounds), NULL, 0 }, // bounds
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->defaultBehaviorGroup), CHILDREN(27), 9 }, // defaultBehaviorGroup
	{ TYPE_STRING, false, (size_t)(&((BehaviorGroup_Type*)0)->name), NULL, 0 }, // defaultBehaviorGroup.name
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->damageThreshold), NULL, 0 }, // defaultBehaviorGroup.damageThreshold
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->damageToRadius), NULL, 0 }, // defaultBehaviorGroup.damageToRadius
	{ TYPE_STRUCT, false, (size_t)(&((BehaviorGroup_Type*)0)->damageSpread), CHILDREN(36), 3 }, // defaultBehaviorGroup.damageSpread
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->minimumRadius), NULL, 0 }, // defaultBehaviorGroup.damageSpread.minimumRadius
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->radiusMultiplier), NULL, 0 }, // defaultBehaviorGroup.damageSpread.radiusMultiplier
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->falloffExponent), NULL, 0 }, // defaultBehaviorGroup.damageSpread.falloffExponent
	{ TYPE_STRUCT, false, (size_t)(&((BehaviorGroup_Type*)0)->damageColorSpread), CHILDREN(39), 3 }, // defaultBehaviorGroup.damageColorSpread
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->minimumRadius), NULL, 0 }, // defaultBehaviorGroup.damageColorSpread.minimumRadius
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->radiusMultiplier), NULL, 0 }, // defaultBehaviorGroup.damageColorSpread.radiusMultiplier
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->falloffExponent), NULL, 0 }, // defaultBehaviorGroup.damageColorSpread.falloffExponent
	{ TYPE_VEC4, false, (size_t)(&((BehaviorGroup_Type*)0)->damageColorChange), NULL, 0 }, // defaultBehaviorGroup.damageColorChange
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->materialStrength), NULL, 0 }, // defaultBehaviorGroup.materialStrength
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->density), NULL, 0 }, // defaultBehaviorGroup.density
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->fadeOut), NULL, 0 }, // defaultBehaviorGroup.fadeOut
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->behaviorGroups), CHILDREN(42), 1 }, // behaviorGroups
	{ TYPE_STRUCT, false, 1 * sizeof(BehaviorGroup_Type), CHILDREN(43), 9 }, // behaviorGroups[]
	{ TYPE_STRING, false, (size_t)(&((BehaviorGroup_Type*)0)->name), NULL, 0 }, // behaviorGroups[].name
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->damageThreshold), NULL, 0 }, // behaviorGroups[].damageThreshold
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->damageToRadius), NULL, 0 }, // behaviorGroups[].damageToRadius
	{ TYPE_STRUCT, false, (size_t)(&((BehaviorGroup_Type*)0)->damageSpread), CHILDREN(52), 3 }, // behaviorGroups[].damageSpread
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->minimumRadius), NULL, 0 }, // behaviorGroups[].damageSpread.minimumRadius
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->radiusMultiplier), NULL, 0 }, // behaviorGroups[].damageSpread.radiusMultiplier
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->falloffExponent), NULL, 0 }, // behaviorGroups[].damageSpread.falloffExponent
	{ TYPE_STRUCT, false, (size_t)(&((BehaviorGroup_Type*)0)->damageColorSpread), CHILDREN(55), 3 }, // behaviorGroups[].damageColorSpread
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->minimumRadius), NULL, 0 }, // behaviorGroups[].damageColorSpread.minimumRadius
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->radiusMultiplier), NULL, 0 }, // behaviorGroups[].damageColorSpread.radiusMultiplier
	{ TYPE_F32, false, (size_t)(&((DamageSpreadFunction_Type*)0)->falloffExponent), NULL, 0 }, // behaviorGroups[].damageColorSpread.falloffExponent
	{ TYPE_VEC4, false, (size_t)(&((BehaviorGroup_Type*)0)->damageColorChange), NULL, 0 }, // behaviorGroups[].damageColorChange
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->materialStrength), NULL, 0 }, // behaviorGroups[].materialStrength
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->density), NULL, 0 }, // behaviorGroups[].density
	{ TYPE_F32, false, (size_t)(&((BehaviorGroup_Type*)0)->fadeOut), NULL, 0 }, // behaviorGroups[].fadeOut
	{ TYPE_I8, false, (size_t)(&((ParametersStruct*)0)->RTFractureBehaviorGroup), NULL, 0 }, // RTFractureBehaviorGroup
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->chunks), CHILDREN(58), 1 }, // chunks
	{ TYPE_STRUCT, false, 1 * sizeof(Chunk_Type), CHILDREN(59), 8 }, // chunks[]
	{ TYPE_U16, false, (size_t)(&((Chunk_Type*)0)->depth), NULL, 0 }, // chunks[].depth
	{ TYPE_U16, false, (size_t)(&((Chunk_Type*)0)->parentIndex), NULL, 0 }, // chunks[].parentIndex
	{ TYPE_U16, false, (size_t)(&((Chunk_Type*)0)->firstChildIndex), NULL, 0 }, // chunks[].firstChildIndex
	{ TYPE_U16, false, (size_t)(&((Chunk_Type*)0)->numChildren), NULL, 0 }, // chunks[].numChildren
	{ TYPE_U16, false, (size_t)(&((Chunk_Type*)0)->meshPartIndex), NULL, 0 }, // chunks[].meshPartIndex
	{ TYPE_U16, false, (size_t)(&((Chunk_Type*)0)->flags), NULL, 0 }, // chunks[].flags
	{ TYPE_VEC3, false, (size_t)(&((Chunk_Type*)0)->surfaceNormal), NULL, 0 }, // chunks[].surfaceNormal
	{ TYPE_I8, false, (size_t)(&((Chunk_Type*)0)->behaviorGroupIndex), NULL, 0 }, // chunks[].behaviorGroupIndex
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->chunkConvexHulls), CHILDREN(67), 1 }, // chunkConvexHulls
	{ TYPE_REF, false, 1 * sizeof(NxParameterized::Interface*), NULL, 0 }, // chunkConvexHulls[]
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->chunkConvexHullStartIndices), CHILDREN(68), 1 }, // chunkConvexHullStartIndices
	{ TYPE_U32, false, 1 * sizeof(physx::PxU32), NULL, 0 }, // chunkConvexHullStartIndices[]
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->destructibleParameters), CHILDREN(69), 19 }, // destructibleParameters
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->damageCap), NULL, 0 }, // destructibleParameters.damageCap
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->forceToDamage), NULL, 0 }, // destructibleParameters.forceToDamage
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->impactVelocityThreshold), NULL, 0 }, // destructibleParameters.impactVelocityThreshold
	{ TYPE_U32, false, (size_t)(&((DestructibleParameters_Type*)0)->minimumFractureDepth), NULL, 0 }, // destructibleParameters.minimumFractureDepth
	{ TYPE_I32, false, (size_t)(&((DestructibleParameters_Type*)0)->impactDamageDefaultDepth), NULL, 0 }, // destructibleParameters.impactDamageDefaultDepth
	{ TYPE_I32, false, (size_t)(&((DestructibleParameters_Type*)0)->debrisDepth), NULL, 0 }, // destructibleParameters.debrisDepth
	{ TYPE_U32, false, (size_t)(&((DestructibleParameters_Type*)0)->essentialDepth), NULL, 0 }, // destructibleParameters.essentialDepth
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->debrisLifetimeMin), NULL, 0 }, // destructibleParameters.debrisLifetimeMin
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->debrisLifetimeMax), NULL, 0 }, // destructibleParameters.debrisLifetimeMax
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->debrisMaxSeparationMin), NULL, 0 }, // destructibleParameters.debrisMaxSeparationMin
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->debrisMaxSeparationMax), NULL, 0 }, // destructibleParameters.debrisMaxSeparationMax
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->debrisDestructionProbability), NULL, 0 }, // destructibleParameters.debrisDestructionProbability
	{ TYPE_BOUNDS3, false, (size_t)(&((DestructibleParameters_Type*)0)->validBounds), NULL, 0 }, // destructibleParameters.validBounds
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->maxChunkSpeed), NULL, 0 }, // destructibleParameters.maxChunkSpeed
	{ TYPE_STRUCT, false, (size_t)(&((DestructibleParameters_Type*)0)->flags), CHILDREN(88), 7 }, // destructibleParameters.flags
	{ TYPE_BOOL, false, (size_t)(&((DestructibleParametersFlag_Type*)0)->ACCUMULATE_DAMAGE), NULL, 0 }, // destructibleParameters.flags.ACCUMULATE_DAMAGE
	{ TYPE_BOOL, false, (size_t)(&((DestructibleParametersFlag_Type*)0)->DEBRIS_TIMEOUT), NULL, 0 }, // destructibleParameters.flags.DEBRIS_TIMEOUT
	{ TYPE_BOOL, false, (size_t)(&((DestructibleParametersFlag_Type*)0)->DEBRIS_MAX_SEPARATION), NULL, 0 }, // destructibleParameters.flags.DEBRIS_MAX_SEPARATION
	{ TYPE_BOOL, false, (size_t)(&((DestructibleParametersFlag_Type*)0)->CRUMBLE_SMALLEST_CHUNKS), NULL, 0 }, // destructibleParameters.flags.CRUMBLE_SMALLEST_CHUNKS
	{ TYPE_BOOL, false, (size_t)(&((DestructibleParametersFlag_Type*)0)->ACCURATE_RAYCASTS), NULL, 0 }, // destructibleParameters.flags.ACCURATE_RAYCASTS
	{ TYPE_BOOL, false, (size_t)(&((DestructibleParametersFlag_Type*)0)->USE_VALID_BOUNDS), NULL, 0 }, // destructibleParameters.flags.USE_VALID_BOUNDS
	{ TYPE_BOOL, false, (size_t)(&((DestructibleParametersFlag_Type*)0)->CRUMBLE_VIA_RUNTIME_FRACTURE), NULL, 0 }, // destructibleParameters.flags.CRUMBLE_VIA_RUNTIME_FRACTURE
	{ TYPE_F32, false, (size_t)(&((DestructibleParameters_Type*)0)->fractureImpulseScale), NULL, 0 }, // destructibleParameters.fractureImpulseScale
	{ TYPE_U16, false, (size_t)(&((DestructibleParameters_Type*)0)->damageDepthLimit), NULL, 0 }, // destructibleParameters.damageDepthLimit
	{ TYPE_U16, false, (size_t)(&((DestructibleParameters_Type*)0)->dynamicChunkDominanceGroup), NULL, 0 }, // destructibleParameters.dynamicChunkDominanceGroup
	{ TYPE_STRUCT, false, (size_t)(&((DestructibleParameters_Type*)0)->dynamicChunksGroupsMask), CHILDREN(95), 5 }, // destructibleParameters.dynamicChunksGroupsMask
	{ TYPE_BOOL, false, (size_t)(&((GroupsMask_Type*)0)->useGroupsMask), NULL, 0 }, // destructibleParameters.dynamicChunksGroupsMask.useGroupsMask
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits0), NULL, 0 }, // destructibleParameters.dynamicChunksGroupsMask.bits0
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits1), NULL, 0 }, // destructibleParameters.dynamicChunksGroupsMask.bits1
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits2), NULL, 0 }, // destructibleParameters.dynamicChunksGroupsMask.bits2
	{ TYPE_U32, false, (size_t)(&((GroupsMask_Type*)0)->bits3), NULL, 0 }, // destructibleParameters.dynamicChunksGroupsMask.bits3
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->depthParameters), CHILDREN(100), 1 }, // depthParameters
	{ TYPE_STRUCT, false, 1 * sizeof(DestructibleDepthParameters_Type), CHILDREN(101), 9 }, // depthParameters[]
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->OVERRIDE_IMPACT_DAMAGE), NULL, 0 }, // depthParameters[].OVERRIDE_IMPACT_DAMAGE
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->OVERRIDE_IMPACT_DAMAGE_VALUE), NULL, 0 }, // depthParameters[].OVERRIDE_IMPACT_DAMAGE_VALUE
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->IGNORE_POSE_UPDATES), NULL, 0 }, // depthParameters[].IGNORE_POSE_UPDATES
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->IGNORE_RAYCAST_CALLBACKS), NULL, 0 }, // depthParameters[].IGNORE_RAYCAST_CALLBACKS
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->IGNORE_CONTACT_CALLBACKS), NULL, 0 }, // depthParameters[].IGNORE_CONTACT_CALLBACKS
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->USER_FLAG_0), NULL, 0 }, // depthParameters[].USER_FLAG_0
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->USER_FLAG_1), NULL, 0 }, // depthParameters[].USER_FLAG_1
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->USER_FLAG_2), NULL, 0 }, // depthParameters[].USER_FLAG_2
	{ TYPE_BOOL, false, (size_t)(&((DestructibleDepthParameters_Type*)0)->USER_FLAG_3), NULL, 0 }, // depthParameters[].USER_FLAG_3
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->crumbleEmitterName), NULL, 0 }, // crumbleEmitterName
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->dustEmitterName), NULL, 0 }, // dustEmitterName
	{ TYPE_REF, false, (size_t)(&((ParametersStruct*)0)->collisionData), NULL, 0 }, // collisionData
	{ TYPE_REF, false, (size_t)(&((ParametersStruct*)0)->renderMeshAsset), NULL, 0 }, // renderMeshAsset
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->initialDestructibleActorAllowanceForInstancing), NULL, 0 }, // initialDestructibleActorAllowanceForInstancing
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->chunkInstanceInfo), CHILDREN(110), 1 }, // chunkInstanceInfo
	{ TYPE_STRUCT, false, 1 * sizeof(InstanceInfo_Type), CHILDREN(111), 3 }, // chunkInstanceInfo[]
	{ TYPE_U16, false, (size_t)(&((InstanceInfo_Type*)0)->partIndex), NULL, 0 }, // chunkInstanceInfo[].partIndex
	{ TYPE_VEC3, false, (size_t)(&((InstanceInfo_Type*)0)->chunkPositionOffset), NULL, 0 }, // chunkInstanceInfo[].chunkPositionOffset
	{ TYPE_VEC2, false, (size_t)(&((InstanceInfo_Type*)0)->chunkUVOffset), NULL, 0 }, // chunkInstanceInfo[].chunkUVOffset
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->staticMaterialNames), CHILDREN(114), 1 }, // staticMaterialNames
	{ TYPE_STRING, false, 1 * sizeof(NxParameterized::DummyStringStruct), NULL, 0 }, // staticMaterialNames[]
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->neighborPadding), NULL, 0 }, // neighborPadding
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->overlapsAtDepth), CHILDREN(115), 1 }, // overlapsAtDepth
	{ TYPE_REF, false, 1 * sizeof(NxParameterized::Interface*), NULL, 0 }, // overlapsAtDepth[]
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->firstChunkAtDepth), CHILDREN(116), 1 }, // firstChunkAtDepth
	{ TYPE_U32, false, 1 * sizeof(physx::PxU32), NULL, 0 }, // firstChunkAtDepth[]
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->supportDepth), NULL, 0 }, // supportDepth
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->formExtendedStructures), NULL, 0 }, // formExtendedStructures
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->useAssetDefinedSupport), NULL, 0 }, // useAssetDefinedSupport
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->useWorldSupport), NULL, 0 }, // useWorldSupport
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->actorTransforms), CHILDREN(117), 1 }, // actorTransforms
	{ TYPE_MAT44, false, 1 * sizeof(physx::PxMat44), NULL, 0 }, // actorTransforms[]
};


bool DestructibleAssetParameters_0p17::mBuiltFlag = false;
NxParameterized::MutexType DestructibleAssetParameters_0p17::mBuiltFlagMutex;

DestructibleAssetParameters_0p17::DestructibleAssetParameters_0p17(NxParameterized::Traits* traits, void* buf, PxI32* refCount) :
	NxParameters(traits, buf, refCount)
{
	//mParameterizedTraits->registerFactory(className(), &DestructibleAssetParameters_0p17FactoryInst);

	if (!buf) //Do not init data if it is inplace-deserialized
	{
		initDynamicArrays();
		initStrings();
		initReferences();
		initDefaults();
	}
}

DestructibleAssetParameters_0p17::~DestructibleAssetParameters_0p17()
{
	freeStrings();
	freeReferences();
	freeDynamicArrays();
}

void DestructibleAssetParameters_0p17::destroy()
{
	// We cache these fields here to avoid overwrite in destructor
	bool doDeallocateSelf = mDoDeallocateSelf;
	NxParameterized::Traits* traits = mParameterizedTraits;
	physx::PxI32* refCount = mRefCount;
	void* buf = mBuffer;

	this->~DestructibleAssetParameters_0p17();

	NxParameters::destroy(this, traits, doDeallocateSelf, refCount, buf);
}

const NxParameterized::DefinitionImpl* DestructibleAssetParameters_0p17::getParameterDefinitionTree(void)
{
	if (!mBuiltFlag) // Double-checked lock
	{
		NxParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

const NxParameterized::DefinitionImpl* DestructibleAssetParameters_0p17::getParameterDefinitionTree(void) const
{
	DestructibleAssetParameters_0p17* tmpParam = const_cast<DestructibleAssetParameters_0p17*>(this);

	if (!mBuiltFlag) // Double-checked lock
	{
		NxParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			tmpParam->buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

NxParameterized::ErrorType DestructibleAssetParameters_0p17::getParameterHandle(const char* long_name, Handle& handle) const
{
	ErrorType Ret = NxParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

NxParameterized::ErrorType DestructibleAssetParameters_0p17::getParameterHandle(const char* long_name, Handle& handle)
{
	ErrorType Ret = NxParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

void DestructibleAssetParameters_0p17::getVarPtr(const Handle& handle, void*& ptr, size_t& offset) const
{
	ptr = getVarPtrHelper(&ParamLookupTable[0], const_cast<DestructibleAssetParameters_0p17::ParametersStruct*>(&parameters()), handle, offset);
}


/* Dynamic Handle Indices */
/* [1,0] - behaviorGroups.name */
/* [0] - chunkConvexHulls (not an array of structs) */
/* [0] - staticMaterialNames (not an array of structs) */
/* [0] - overlapsAtDepth (not an array of structs) */

void DestructibleAssetParameters_0p17::freeParameterDefinitionTable(NxParameterized::Traits* traits)
{
	if (!traits)
	{
		return;
	}

	if (!mBuiltFlag) // Double-checked lock
	{
		return;
	}

	NxParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);

	if (!mBuiltFlag)
	{
		return;
	}

	for (physx::PxU32 i = 0; i < NumParamDefs; ++i)
	{
		ParamDefTable[i].~DefinitionImpl();
	}

	traits->free(ParamDefTable);

	mBuiltFlag = false;
}

#define PDEF_PTR(index) (&ParamDefTable[index])

void DestructibleAssetParameters_0p17::buildTree(void)
{

	physx::PxU32 allocSize = sizeof(NxParameterized::DefinitionImpl) * NumParamDefs;
	ParamDefTable = (NxParameterized::DefinitionImpl*)(mParameterizedTraits->alloc(allocSize));
	memset(static_cast<void*>(ParamDefTable), 0, allocSize);

	for (physx::PxU32 i = 0; i < NumParamDefs; ++i)
	{
		NX_PARAM_PLACEMENT_NEW(ParamDefTable + i, NxParameterized::DefinitionImpl)(*mParameterizedTraits);
	}

	// Initialize DefinitionImpl node: nodeIndex=0, longName=""
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[0];
		ParamDef->init("", TYPE_STRUCT, "STRUCT", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=1, longName="comments"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[1];
		ParamDef->init("comments", TYPE_STRING, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Human-readable string which describes which tool created this asset, its version, etc.", true);
		HintTable[1].init("shortDescription", "Human-readable string which describes which tool created this asset, its version, etc.", true);
		ParamDefTable[1].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=2, longName="depthCount"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[2];
		ParamDef->init("depthCount", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The number of chunk depth levels.  This is 1 for an unfractured mesh.", true);
		HintTable[1].init("shortDescription", "The number of chunk depth levels", true);
		ParamDefTable[2].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=3, longName="originalDepthCount"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[3];
		ParamDef->init("originalDepthCount", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The depth count when authored - this way we can tell how far it's been reduced.", true);
		HintTable[1].init("shortDescription", "The depth count when authored", true);
		ParamDefTable[3].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=4, longName="bounds"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[4];
		ParamDef->init("bounds", TYPE_BOUNDS3, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The axis-aligned bounding box of the destructible asset.  This is the smallest AABB\n					which contains all chunk AABBs.", true);
		HintTable[1].init("shortDescription", "The AABB of the destructible asset", true);
		ParamDefTable[4].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=5, longName="defaultBehaviorGroup"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[5];
		ParamDef->init("defaultBehaviorGroup", TYPE_STRUCT, "BehaviorGroup", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The default behavior group referenced by chunks. Each chunk references a behavior group for chunk-specific reactions.", true);
		HintTable[1].init("shortDescription", "The default behavior group referenced by chunks", true);
		ParamDefTable[5].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=6, longName="defaultBehaviorGroup.name"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[6];
		ParamDef->init("name", TYPE_STRING, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Name of behavior group, eg Concrete or Glass.", true);
		HintTable[1].init("shortDescription", "Name of behavior group", true);
		ParamDefTable[6].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=7, longName="defaultBehaviorGroup.damageThreshold"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[7];
		ParamDef->init("damageThreshold", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The damage amount which will cause a chunk to fracture (break free) from the destructible.\n							This is obtained from the damage value passed into the NxDestructibleActor::applyDamage,\n							or NxDestructibleActor::applyRadiusDamage, or via impact (see 'forceToDamage', below).", true);
		HintTable[1].init("shortDescription", "The damage amount which will cause a chunk to fracture (break free) from the destructible.", true);
		ParamDefTable[7].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=8, longName="defaultBehaviorGroup.damageToRadius"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[8];
		ParamDef->init("damageToRadius", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Controls the distance into the destructible to propagate damage.  The damage applied to the chunk\n							is multiplied by damageToRadius, to get the propagation distance.  All chunks within the radius\n							will have damage applied to them.  The damage applied to each chunk varies with distance to the damage\n							application position.  Full damage is taken at zero distance, and zero damage at the damage radius.\n							NOTE: This parameter is deprecated for point and radius damage.  It will be used for those types of damage if legacy damage\n							behavior is enabled with NxModuleDestructible::setUseLegacyDamageRadiusSpread.  Otherwise, the new parameters\n							damageSpread.minimumRadius, damageSpread.radiusMultiplier, and damageSpread.falloffExponent are used.  For impact damage, this parameter\n							will continue to be used, however the radius will no longer scale with object size.  The radius will continue\n							to scale with the damage as a fraction of damageThreshold, however.  If legacy damage behavior is used, this parameter\n							will behave as before with respect to impact damage as well (scaling with object size).", true);
		HintTable[1].init("shortDescription", "Controls the distance into the destructible to propagate damage.", true);
		ParamDefTable[8].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=9, longName="defaultBehaviorGroup.damageSpread"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[9];
		ParamDef->init("damageSpread", TYPE_STRUCT, "DamageSpreadFunction", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Describes the radius and damage envelope function for damage applied to the destructible.", true);
		HintTable[1].init("shortDescription", "Describes the radius and damage envelope function for damage applied to the destructible.", true);
		ParamDefTable[9].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=10, longName="defaultBehaviorGroup.damageSpread.minimumRadius"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[10];
		ParamDef->init("minimumRadius", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The minimum radius of damage spread when damage is applied.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.", true);
		HintTable[1].init("shortDescription", "The minimum radius of damage spread when damage is applied.", true);
		ParamDefTable[10].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=11, longName="defaultBehaviorGroup.damageSpread.radiusMultiplier"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[11];
		ParamDef->init("radiusMultiplier", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "A scale to apply to the input damage radius when damage is applied.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.", true);
		HintTable[1].init("shortDescription", "A scale to apply to the input damage radius when damage is applied.", true);
		ParamDefTable[11].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=12, longName="defaultBehaviorGroup.damageSpread.falloffExponent"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[12];
		ParamDef->init("falloffExponent", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "How damage varies between the minimum radius and the calculated damage radius.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.\n						Within the minimumRadius, the full damage is applied to chunks.  Past the minimumRadius, the formla for damage is:\n						damage = (input damage) * ((radius - distance)/(radius - minimumRadius))^falloffExponent.\n						Note: falloffExponent = 0.0 gives no falloff, so that damage = (input damage) over the entire range [0, radius).\n						falloffExponent = 1.0 gives linear falloff.", true);
		HintTable[1].init("shortDescription", "How damage varies between the minimum radius and the calculated damage radius.", true);
		ParamDefTable[12].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=13, longName="defaultBehaviorGroup.damageColorSpread"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[13];
		ParamDef->init("damageColorSpread", TYPE_STRUCT, "DamageSpreadFunction", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Describes the radius and damage envelope function for color channel damage modification applied to the destructible.", true);
		HintTable[1].init("shortDescription", "Describes the radius and damage envelope function for color channel damage modification applied to the destructible.", true);
		ParamDefTable[13].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=14, longName="defaultBehaviorGroup.damageColorSpread.minimumRadius"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[14];
		ParamDef->init("minimumRadius", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The minimum radius of damage spread when damage is applied.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.", true);
		HintTable[1].init("shortDescription", "The minimum radius of damage spread when damage is applied.", true);
		ParamDefTable[14].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=15, longName="defaultBehaviorGroup.damageColorSpread.radiusMultiplier"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[15];
		ParamDef->init("radiusMultiplier", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "A scale to apply to the input damage radius when damage is applied.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.", true);
		HintTable[1].init("shortDescription", "A scale to apply to the input damage radius when damage is applied.", true);
		ParamDefTable[15].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=16, longName="defaultBehaviorGroup.damageColorSpread.falloffExponent"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[16];
		ParamDef->init("falloffExponent", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "How damage varies between the minimum radius and the calculated damage radius.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.\n						Within the minimumRadius, the full damage is applied to chunks.  Past the minimumRadius, the formla for damage is:\n						damage = (input damage) * ((radius - distance)/(radius - minimumRadius))^falloffExponent.\n						Note: falloffExponent = 0.0 gives no falloff, so that damage = (input damage) over the entire range [0, radius).\n						falloffExponent = 1.0 gives linear falloff.", true);
		HintTable[1].init("shortDescription", "How damage varies between the minimum radius and the calculated damage radius.", true);
		ParamDefTable[16].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=17, longName="defaultBehaviorGroup.damageColorChange"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[17];
		ParamDef->init("damageColorChange", TYPE_VEC4, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Describes how damage changes the color of vertices in the render mesh.  If this vector is non-zero, then a dynamic\n							(per-actor) color channel will be created and initialized to the asset's color channel, if it exists.  Damage taken will go through\n							the spread and envelope function described by damageColoring, and each color will be modified by the resulting damage, scaled\n							by the values in damageColorChange.  The change to color channel C is given by\n							color[C] = clamp(color[C] + damageColorChange[C]*255*min(1.0, damage/damageThreshold), 0, 255).", true);
		HintTable[1].init("shortDescription", "Describes how damage changes the color of vertices in the render mesh.", true);
		ParamDefTable[17].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=18, longName="defaultBehaviorGroup.materialStrength"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[18];
		ParamDef->init("materialStrength", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "When a chunk takes impact damage due to physical contact (see see NxDestructibleDepthParameters), this parameter\n							is the maximum impulse the contact can generate.  Weak materials such as glass may have this set to a low value, so that\n							heavier objects will pass through them during fracture.\n							N.B.: Setting this parameter to 0 disables the impulse cap; that is, zero is interpreted as infinite.\n							Default value = 0.0f.", true);
		HintTable[1].init("shortDescription", "When a chunk takes impact, this is the maximum impulse the contact can generate.", true);
		ParamDefTable[18].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=19, longName="defaultBehaviorGroup.density"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[19];
		ParamDef->init("density", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunk density. (TODO: better description)", true);
		HintTable[1].init("shortDescription", "Chunk density", true);
		ParamDefTable[19].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=20, longName="defaultBehaviorGroup.fadeOut"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[20];
		ParamDef->init("fadeOut", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunk fade out.  (TODO: better description)", true);
		HintTable[1].init("shortDescription", "Chunk fade out", true);
		ParamDefTable[20].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=21, longName="behaviorGroups"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[21];
		ParamDef->init("behaviorGroups", TYPE_ARRAY, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The array of behavior groups referenced by chunks. Each chunk references a behavior group for chunk-specific reactions.", true);
		HintTable[1].init("shortDescription", "The array of behavior groups referenced by chunks", true);
		ParamDefTable[21].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
		static const physx::PxU8 dynHandleIndices[2] = { 1, 0, };
		ParamDef->setDynamicHandleIndicesMap(dynHandleIndices, 2);

	}

	// Initialize DefinitionImpl node: nodeIndex=22, longName="behaviorGroups[]"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[22];
		ParamDef->init("behaviorGroups", TYPE_STRUCT, "BehaviorGroup", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The array of behavior groups referenced by chunks. Each chunk references a behavior group for chunk-specific reactions.", true);
		HintTable[1].init("shortDescription", "The array of behavior groups referenced by chunks", true);
		ParamDefTable[22].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=23, longName="behaviorGroups[].name"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[23];
		ParamDef->init("name", TYPE_STRING, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Name of behavior group, eg Concrete or Glass.", true);
		HintTable[1].init("shortDescription", "Name of behavior group", true);
		ParamDefTable[23].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=24, longName="behaviorGroups[].damageThreshold"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[24];
		ParamDef->init("damageThreshold", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The damage amount which will cause a chunk to fracture (break free) from the destructible.\n							This is obtained from the damage value passed into the NxDestructibleActor::applyDamage,\n							or NxDestructibleActor::applyRadiusDamage, or via impact (see 'forceToDamage', below).", true);
		HintTable[1].init("shortDescription", "The damage amount which will cause a chunk to fracture (break free) from the destructible.", true);
		ParamDefTable[24].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=25, longName="behaviorGroups[].damageToRadius"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[25];
		ParamDef->init("damageToRadius", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Controls the distance into the destructible to propagate damage.  The damage applied to the chunk\n							is multiplied by damageToRadius, to get the propagation distance.  All chunks within the radius\n							will have damage applied to them.  The damage applied to each chunk varies with distance to the damage\n							application position.  Full damage is taken at zero distance, and zero damage at the damage radius.\n							NOTE: This parameter is deprecated for point and radius damage.  It will be used for those types of damage if legacy damage\n							behavior is enabled with NxModuleDestructible::setUseLegacyDamageRadiusSpread.  Otherwise, the new parameters\n							damageSpread.minimumRadius, damageSpread.radiusMultiplier, and damageSpread.falloffExponent are used.  For impact damage, this parameter\n							will continue to be used, however the radius will no longer scale with object size.  The radius will continue\n							to scale with the damage as a fraction of damageThreshold, however.  If legacy damage behavior is used, this parameter\n							will behave as before with respect to impact damage as well (scaling with object size).", true);
		HintTable[1].init("shortDescription", "Controls the distance into the destructible to propagate damage.", true);
		ParamDefTable[25].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=26, longName="behaviorGroups[].damageSpread"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[26];
		ParamDef->init("damageSpread", TYPE_STRUCT, "DamageSpreadFunction", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Describes the radius and damage envelope function for damage applied to the destructible.", true);
		HintTable[1].init("shortDescription", "Describes the radius and damage envelope function for damage applied to the destructible.", true);
		ParamDefTable[26].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=27, longName="behaviorGroups[].damageSpread.minimumRadius"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[27];
		ParamDef->init("minimumRadius", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The minimum radius of damage spread when damage is applied.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.", true);
		HintTable[1].init("shortDescription", "The minimum radius of damage spread when damage is applied.", true);
		ParamDefTable[27].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=28, longName="behaviorGroups[].damageSpread.radiusMultiplier"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[28];
		ParamDef->init("radiusMultiplier", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "A scale to apply to the input damage radius when damage is applied.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.", true);
		HintTable[1].init("shortDescription", "A scale to apply to the input damage radius when damage is applied.", true);
		ParamDefTable[28].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=29, longName="behaviorGroups[].damageSpread.falloffExponent"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[29];
		ParamDef->init("falloffExponent", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "How damage varies between the minimum radius and the calculated damage radius.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.\n						Within the minimumRadius, the full damage is applied to chunks.  Past the minimumRadius, the formla for damage is:\n						damage = (input damage) * ((radius - distance)/(radius - minimumRadius))^falloffExponent.\n						Note: falloffExponent = 0.0 gives no falloff, so that damage = (input damage) over the entire range [0, radius).\n						falloffExponent = 1.0 gives linear falloff.", true);
		HintTable[1].init("shortDescription", "How damage varies between the minimum radius and the calculated damage radius.", true);
		ParamDefTable[29].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=30, longName="behaviorGroups[].damageColorSpread"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[30];
		ParamDef->init("damageColorSpread", TYPE_STRUCT, "DamageSpreadFunction", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Describes the radius and damage envelope function for color channel damage modification applied to the destructible.", true);
		HintTable[1].init("shortDescription", "Describes the radius and damage envelope function for color channel damage modification applied to the destructible.", true);
		ParamDefTable[30].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=31, longName="behaviorGroups[].damageColorSpread.minimumRadius"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[31];
		ParamDef->init("minimumRadius", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The minimum radius of damage spread when damage is applied.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.", true);
		HintTable[1].init("shortDescription", "The minimum radius of damage spread when damage is applied.", true);
		ParamDefTable[31].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=32, longName="behaviorGroups[].damageColorSpread.radiusMultiplier"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[32];
		ParamDef->init("radiusMultiplier", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "A scale to apply to the input damage radius when damage is applied.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.", true);
		HintTable[1].init("shortDescription", "A scale to apply to the input damage radius when damage is applied.", true);
		ParamDefTable[32].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=33, longName="behaviorGroups[].damageColorSpread.falloffExponent"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[33];
		ParamDef->init("falloffExponent", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "How damage varies between the minimum radius and the calculated damage radius.  The formula for the damage radius is\n						radius = minimumRadius + (input radius) * radiusMultiplier.\n						Within the minimumRadius, the full damage is applied to chunks.  Past the minimumRadius, the formla for damage is:\n						damage = (input damage) * ((radius - distance)/(radius - minimumRadius))^falloffExponent.\n						Note: falloffExponent = 0.0 gives no falloff, so that damage = (input damage) over the entire range [0, radius).\n						falloffExponent = 1.0 gives linear falloff.", true);
		HintTable[1].init("shortDescription", "How damage varies between the minimum radius and the calculated damage radius.", true);
		ParamDefTable[33].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=34, longName="behaviorGroups[].damageColorChange"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[34];
		ParamDef->init("damageColorChange", TYPE_VEC4, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Describes how damage changes the color of vertices in the render mesh.  If this vector is non-zero, then a dynamic\n							(per-actor) color channel will be created and initialized to the asset's color channel, if it exists.  Damage taken will go through\n							the spread and envelope function described by damageColoring, and each color will be modified by the resulting damage, scaled\n							by the values in damageColorChange.  The change to color channel C is given by\n							color[C] = clamp(color[C] + damageColorChange[C]*255*min(1.0, damage/damageThreshold), 0, 255).", true);
		HintTable[1].init("shortDescription", "Describes how damage changes the color of vertices in the render mesh.", true);
		ParamDefTable[34].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=35, longName="behaviorGroups[].materialStrength"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[35];
		ParamDef->init("materialStrength", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "When a chunk takes impact damage due to physical contact (see see NxDestructibleDepthParameters), this parameter\n							is the maximum impulse the contact can generate.  Weak materials such as glass may have this set to a low value, so that\n							heavier objects will pass through them during fracture.\n							N.B.: Setting this parameter to 0 disables the impulse cap; that is, zero is interpreted as infinite.\n							Default value = 0.0f.", true);
		HintTable[1].init("shortDescription", "When a chunk takes impact, this is the maximum impulse the contact can generate.", true);
		ParamDefTable[35].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=36, longName="behaviorGroups[].density"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[36];
		ParamDef->init("density", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunk density. (TODO: better description)", true);
		HintTable[1].init("shortDescription", "Chunk density", true);
		ParamDefTable[36].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=37, longName="behaviorGroups[].fadeOut"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[37];
		ParamDef->init("fadeOut", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunk fade out.  (TODO: better description)", true);
		HintTable[1].init("shortDescription", "Chunk fade out", true);
		ParamDefTable[37].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=38, longName="RTFractureBehaviorGroup"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[38];
		ParamDef->init("RTFractureBehaviorGroup", TYPE_I8, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The array of behavior groups referenced by chunks. Each chunk references a behavior group for chunk-specific reactions.", true);
		HintTable[1].init("shortDescription", "The array of behavior groups referenced by chunks", true);
		ParamDefTable[38].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=39, longName="chunks"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[39];
		ParamDef->init("chunks", TYPE_ARRAY, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The array of chunks.  Chunks are stored breadth-first in their hierarchy.", true);
		HintTable[1].init("shortDescription", "The array of chunks", true);
		ParamDefTable[39].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=40, longName="chunks[]"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[40];
		ParamDef->init("chunks", TYPE_STRUCT, "Chunk", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The array of chunks.  Chunks are stored breadth-first in their hierarchy.", true);
		HintTable[1].init("shortDescription", "The array of chunks", true);
		ParamDefTable[40].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=41, longName="chunks[].depth"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[41];
		ParamDef->init("depth", TYPE_U16, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The depth of the chunk in the hierarchy.\n							Level 0 chunks correspond to the unfractured (original) mesh.  Level 1 chunks\n							are their children, formed by splitting level 0 chunks, etc.", true);
		HintTable[1].init("shortDescription", "The depth of the chunk in the hierarchy", true);
		ParamDefTable[41].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=42, longName="chunks[].parentIndex"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[42];
		ParamDef->init("parentIndex", TYPE_U16, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The index of the chunk's parent in the hierarchy.\n							If the chunk has no parent (its depth is 0), then the parentIndex is -1.", true);
		HintTable[1].init("shortDescription", "The index of the chunk's parent in the hierarchy", true);
		ParamDefTable[42].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=43, longName="chunks[].firstChildIndex"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[43];
		ParamDef->init("firstChildIndex", TYPE_U16, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The index of this chunk's first child in the hierarchy.\n							All children have contiguous chunk indices, and lie in the range\n							[firstChildIndex,firstChildIndex+numChildren-1].  If the chunk has no children,\n							this value is undefined.", true);
		HintTable[1].init("shortDescription", "The index of this chunk's first child in the hierarchy", true);
		ParamDefTable[43].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=44, longName="chunks[].numChildren"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[44];
		ParamDef->init("numChildren", TYPE_U16, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This chunk's number of children.  If not 0, firstChildIndex\n							is valid (see firstChildIndex).", true);
		HintTable[1].init("shortDescription", "This chunk's number of children", true);
		ParamDefTable[44].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=45, longName="chunks[].meshPartIndex"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[45];
		ParamDef->init("meshPartIndex", TYPE_U16, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If this chunk is not instanced, this is the corresponding mesh part for this chunk,\n							in the NxApexRenderMeshAsset included within this destructible asset.  If this chunk is instanced,\n							this refers to the InstanceInfo in the asset (see InstanceInfo).", true);
		HintTable[1].init("shortDescription", "The corresponding mesh part for this chunk", true);
		ParamDefTable[45].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=46, longName="chunks[].flags"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[46];
		ParamDef->init("flags", TYPE_U16, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("editorDisplay", "false", true);
		ParamDefTable[46].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("editorDisplay", "false", true);
		HintTable[1].init("longDescription", "Flags which define individual chunk attributes, such as support,\n							fractureability, etc.", true);
		HintTable[2].init("shortDescription", "Flags which define individual chunk attributes", true);
		ParamDefTable[46].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=47, longName="chunks[].surfaceNormal"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[47];
		ParamDef->init("surfaceNormal", TYPE_VEC3, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The average surface normal of this chunk.  This is the normalized\n							average of all triangle normals which are part of the original (unfractured) mesh.", true);
		HintTable[1].init("shortDescription", "The average surface normal of this chunk", true);
		ParamDefTable[47].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=48, longName="chunks[].behaviorGroupIndex"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[48];
		ParamDef->init("behaviorGroupIndex", TYPE_I8, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Behavior group this chunk is associated with. This includes flags, damage threshold, density, impact\n							resistance, and collision mask.", true);
		HintTable[1].init("shortDescription", "Behavior group this chunk is associated with", true);
		ParamDefTable[48].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=49, longName="chunkConvexHulls"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[49];
		ParamDef->init("chunkConvexHulls", TYPE_ARRAY, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		ParamDefTable[49].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		HintTable[1].init("longDescription", "Convex hull data for each chunk.  This is not cooked convex hull data\n					used for PhysX collision.  These hulls are used to (a) create cooked PhysX convex hulls, and (b)\n					for APEX scene queries.", true);
		HintTable[2].init("shortDescription", "Convex hull data for each chunk", true);
		ParamDefTable[49].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "ConvexHullParameters" };
		ParamDefTable[49].setRefVariantVals((const char**)RefVariantVals, 1);


		ParamDef->setArraySize(-1);
		static const physx::PxU8 dynHandleIndices[1] = { 0, };
		ParamDef->setDynamicHandleIndicesMap(dynHandleIndices, 1);

	}

	// Initialize DefinitionImpl node: nodeIndex=50, longName="chunkConvexHulls[]"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[50];
		ParamDef->init("chunkConvexHulls", TYPE_REF, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		ParamDefTable[50].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		HintTable[1].init("longDescription", "Convex hull data for each chunk.  This is not cooked convex hull data\n					used for PhysX collision.  These hulls are used to (a) create cooked PhysX convex hulls, and (b)\n					for APEX scene queries.", true);
		HintTable[2].init("shortDescription", "Convex hull data for each chunk", true);
		ParamDefTable[50].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "ConvexHullParameters" };
		ParamDefTable[50].setRefVariantVals((const char**)RefVariantVals, 1);



	}

	// Initialize DefinitionImpl node: nodeIndex=51, longName="chunkConvexHullStartIndices"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[51];
		ParamDef->init("chunkConvexHullStartIndices", TYPE_ARRAY, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Map into array of convex hulls.  The convex hulls for chunk i are in\n					the chunkConvexHulls array, starting at chunkConvexHulls[i], and ending at chunkConvexHulls[i+1]-1.\n					The array length is one greater than that of chunkConvexHulls.", true);
		HintTable[1].init("shortDescription", "Map into array of convex hulls", true);
		ParamDefTable[51].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=52, longName="chunkConvexHullStartIndices[]"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[52];
		ParamDef->init("chunkConvexHullStartIndices", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Map into array of convex hulls.  The convex hulls for chunk i are in\n					the chunkConvexHulls array, starting at chunkConvexHulls[i], and ending at chunkConvexHulls[i+1]-1.\n					The array length is one greater than that of chunkConvexHulls.", true);
		HintTable[1].init("shortDescription", "Map into array of convex hulls", true);
		ParamDefTable[52].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=53, longName="destructibleParameters"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[53];
		ParamDef->init("destructibleParameters", TYPE_STRUCT, "DestructibleParameters", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The default destructible properties for this asset.  These may be overridden\n					for an instance (destructible actor), as a copy of the parameters is also stored in the actor.", true);
		HintTable[1].init("shortDescription", "The default destructible properties for this asset", true);
		ParamDefTable[53].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=54, longName="destructibleParameters.damageCap"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[54];
		ParamDef->init("damageCap", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Limits the amount of damage applied to a chunk.  This is useful for preventing the entire destructible\nfrom getting pulverized by a very large application of damage.  This can easily happen when impact damage is\nused, and the damage amount is proportional to the impact force (see forceToDamage).\n", true);
		HintTable[1].init("shortDescription", "Limits the amount of damage applied to a chunk.", true);
		ParamDefTable[54].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=55, longName="destructibleParameters.forceToDamage"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[55];
		ParamDef->init("forceToDamage", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If a chunk is at a depth which takes impact damage (see NxDestructibleDepthParameters),\nthen when a chunk has a collision in the NxScene, it will take damage equal to forceToDamage mulitplied by\nthe impact force.\nThe default value is zero, which effectively disables impact damage.\n", true);
		HintTable[1].init("shortDescription", "Multiplier to calculate applied damage from an impact.", true);
		ParamDefTable[55].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=56, longName="destructibleParameters.impactVelocityThreshold"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[56];
		ParamDef->init("impactVelocityThreshold", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Large impact force may be reported if rigid bodies are spawned inside one another.  In this case the relative velocity of the two\nobjects will be low.  This variable allows the user to set a minimum velocity threshold for impacts to ensure that the objects are\nmoving at a min velocity in order for the impact force to be considered.\n", true);
		HintTable[1].init("shortDescription", "Large impact force may be reported if rigid bodies are spawned inside one another.", true);
		ParamDefTable[56].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=57, longName="destructibleParameters.minimumFractureDepth"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[57];
		ParamDef->init("minimumFractureDepth", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunks will not be broken free below this depth.\n", true);
		HintTable[1].init("shortDescription", "The chunks will not be broken free below this depth.", true);
		ParamDefTable[57].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=58, longName="destructibleParameters.impactDamageDefaultDepth"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[58];
		ParamDef->init("impactDamageDefaultDepth", TYPE_I32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The default depth to which chunks will take impact damage.  This default may be overridden in the depth settings.\n", true);
		HintTable[1].init("shortDescription", "The default depth to which chunks will take impact damage.", true);
		ParamDefTable[58].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=59, longName="destructibleParameters.debrisDepth"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[59];
		ParamDef->init("debrisDepth", TYPE_I32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The chunk hierarchy depth at which chunks are considered to be 'debris.'  Chunks at this depth or\nbelow will be considered for various debris settings, such as debrisLifetime.\nNegative values indicate that no chunk depth is considered debris.\nDefault value is -1.\n", true);
		HintTable[1].init("shortDescription", "The chunk hierarchy depth at which chunks are considered to be 'debris.'", true);
		ParamDefTable[59].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=60, longName="destructibleParameters.essentialDepth"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[60];
		ParamDef->init("essentialDepth", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The chunk hierarchy depth up to which chunks will always be processed.  These chunks are considered\nto be essential either for gameplay or visually.\nThe minimum value is 0, meaning the level 0 chunk is always considered essential.\nDefault value is 0.\n", true);
		HintTable[1].init("shortDescription", "The chunk hierarchy depth up to which chunks will always be processed", true);
		ParamDefTable[60].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=61, longName="destructibleParameters.debrisLifetimeMin"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[61];
		ParamDef->init("debrisLifetimeMin", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "'Debris chunks' (see debrisDepth, above) will be destroyed after a time (in seconds)\nseparated from non-debris chunks.  The actual lifetime is interpolated between\ndebrisLifetimeMin and debrisLifetimeMax (see below), based upon the module\'s LOD setting.\nTo disable lifetime, clear the NxDestructibleDepthParametersFlag::DEBRIS_TIMEOUT\nflag in the flags field.  If debrisLifetimeMax < debrisLifetimeMin, the mean of the two\nis used for both.\nDefault debrisLifetimeMin = 1.0, debrisLifetimeMax = 10.0f.\n", true);
		HintTable[1].init("shortDescription", "Minimum time to destroy debris", true);
		ParamDefTable[61].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=62, longName="destructibleParameters.debrisLifetimeMax"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[62];
		ParamDef->init("debrisLifetimeMax", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "'Debris chunks' (see debrisDepth, above) will be destroyed after a time (in seconds)\nseparated from non-debris chunks.  The actual lifetime is interpolated between\ndebrisLifetimeMin (see above) and debrisLifetimeMax, based upon the module\'s LOD setting.\nTo disable lifetime, clear the NxDestructibleDepthParametersFlag::DEBRIS_TIMEOUT\nflag in the flags field.  If debrisLifetimeMax < debrisLifetimeMin, the mean of the two\nis used for both.\nDefault debrisLifetimeMin = 1.0, debrisLifetimeMax = 10.0f.\n", true);
		HintTable[1].init("shortDescription", "Maximum time to destroy debris", true);
		ParamDefTable[62].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=63, longName="destructibleParameters.debrisMaxSeparationMin"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[63];
		ParamDef->init("debrisMaxSeparationMin", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "'Debris chunks' (see debrisDepth, above) will be destroyed if they are separated from\ntheir origin by a distance greater than maxSeparation.  The actual maxSeparation is\ninterpolated between debrisMaxSeparationMin and debrisMaxSeparationMax (see below),\nbased upon the module\'s LOD setting.  To disable maxSeparation, clear the\nNX_DESTRUCTIBLE_DEBRIS_MAX_SEPARATION flag in the flags field.\nIf debrisMaxSeparationMax < debrisMaxSeparationMin, the mean of the two is used for both.\nDefault debrisMaxSeparationMin = 1.0, debrisMaxSeparationMax = 10.0f.\n", true);
		HintTable[1].init("shortDescription", "Minimum separation distance", true);
		ParamDefTable[63].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=64, longName="destructibleParameters.debrisMaxSeparationMax"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[64];
		ParamDef->init("debrisMaxSeparationMax", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "'Debris chunks' (see debrisDepth, above) will be destroyed if they are separated from\ntheir origin by a distance greater than maxSeparation.  The actual maxSeparation is\ninterpolated between debrisMaxSeparationMin (see above) and debrisMaxSeparationMax,\nbased upon the module\'s LOD setting.  To disable maxSeparation, clear the\nNX_DESTRUCTIBLE_DEBRIS_MAX_SEPARATION flag in the flags field.\nIf debrisMaxSeparationMax < debrisMaxSeparationMin, the mean of the two is used for both.\nDefault debrisMaxSeparationMin = 1.0, debrisMaxSeparationMax = 10.0f.\n", true);
		HintTable[1].init("shortDescription", "Minimum separation distance", true);
		ParamDefTable[64].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=65, longName="destructibleParameters.debrisDestructionProbability"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[65];
		ParamDef->init("debrisDestructionProbability", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The probablity that a debris chunk, when fractured, will simply be destroyed instead of becoming dynamic or breaking down\n						further into child chunks.  Valid range = [0.0,1.0].  Default value = 0.0.", true);
		HintTable[1].init("shortDescription", "The probablity that a debris chunk, when fractured, will simply be destroyed", true);
		ParamDefTable[65].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=66, longName="destructibleParameters.validBounds"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[66];
		ParamDef->init("validBounds", TYPE_BOUNDS3, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "A bounding box around each NxDestructibleActor created, defining a range of validity\nfor chunks that break free.  These bounds are scaled and translated with the\nNxDestructibleActor\'s scale and position, but they are not rotated with the\nNxDestructibleActor.\n", true);
		HintTable[1].init("shortDescription", "valid bounding region for debris", true);
		ParamDefTable[66].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=67, longName="destructibleParameters.maxChunkSpeed"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[67];
		ParamDef->init("maxChunkSpeed", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If greater than 0, the chunks' speeds will not be allowed to exceed this value.  Use 0\nto disable this feature (this is the default).\n", true);
		HintTable[1].init("shortDescription", "Maximum speed of a chunk", true);
		ParamDefTable[67].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=68, longName="destructibleParameters.flags"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[68];
		ParamDef->init("flags", TYPE_STRUCT, "DestructibleParametersFlag", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "A collection of flags defined in NxDestructibleParametersFlag.\n", true);
		HintTable[1].init("shortDescription", "A collection of flags defined in DestructibleParametersFlag.", true);
		ParamDefTable[68].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=69, longName="destructibleParameters.flags.ACCUMULATE_DAMAGE"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[69];
		ParamDef->init("ACCUMULATE_DAMAGE", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If set, chunks will 'remember' damage applied to them, so that many applications of a damage amount\nbelow damageThreshold will eventually fracture the chunk.  If not set, a single application of\ndamage must exceed damageThreshold in order to fracture the chunk.\n", true);
		HintTable[1].init("shortDescription", "Determines if chunks accumulate damage", true);
		ParamDefTable[69].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=70, longName="destructibleParameters.flags.DEBRIS_TIMEOUT"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[70];
		ParamDef->init("DEBRIS_TIMEOUT", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Whether or not chunks at or deeper than the 'debris' depth (see NxDestructibleParameters::debrisDepth)\nwill time out.  The lifetime is a value between NxDestructibleParameters::debrisLifetimeMin and\nNxDestructibleParameters::debrisLifetimeMax, based upon the destructible module\'s LOD setting.\n", true);
		HintTable[1].init("shortDescription", "Whether or not chunks at or deeper than the 'debris' depth will timeout", true);
		ParamDefTable[70].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=71, longName="destructibleParameters.flags.DEBRIS_MAX_SEPARATION"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[71];
		ParamDef->init("DEBRIS_MAX_SEPARATION", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Whether or not chunks at or deeper than the 'debris' depth (see NxDestructibleParameters::debrisDepth)\nwill be removed if they separate too far from their origins.  The maxSeparation is a value between\nNxDestructibleParameters::debrisMaxSeparationMin and NxDestructibleParameters::debrisMaxSeparationMax,\nbased upon the destructible module\'s LOD setting.\n", true);
		HintTable[1].init("shortDescription", "Whether or not chunks at or deeper than the 'debris' depth will be removed if separated too far", true);
		ParamDefTable[71].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=72, longName="destructibleParameters.flags.CRUMBLE_SMALLEST_CHUNKS"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[72];
		ParamDef->init("CRUMBLE_SMALLEST_CHUNKS", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If set, the smallest chunks may be further broken down, either by fluid crumbles (if a crumble particle\nsystem is specified in the NxDestructibleActorDesc), or by simply removing the chunk if no crumble\nparticle system is specified.  Note: the 'smallest chunks' are normally defined to be the deepest level\nof the fracture hierarchy.  However, they may be taken from higher levels of the hierarchy if\nNxModuleDestructible::setMaxChunkDepthOffset is called with a non-zero value.\n", true);
		HintTable[1].init("shortDescription", "If set, the smallest chunks may be further broken down", true);
		ParamDefTable[72].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=73, longName="destructibleParameters.flags.ACCURATE_RAYCASTS"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[73];
		ParamDef->init("ACCURATE_RAYCASTS", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If set, the NxDestructibleActor::rayCast function will search within the nearest visible chunk hit\nfor collisions with child chunks.  This is used to get a better raycast position and normal, in\ncase the parent collision volume does not tightly fit the graphics mesh.  The returned chunk index\nwill always be that of the visible parent that is intersected, however.\n", true);
		HintTable[1].init("shortDescription", "If set, the NxDestructibleActor::rayCast function will search within the nearest visible chunk hit", true);
		ParamDefTable[73].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=74, longName="destructibleParameters.flags.USE_VALID_BOUNDS"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[74];
		ParamDef->init("USE_VALID_BOUNDS", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If set, the validBounds field of NxDestructibleParameters will be used.  These bounds are translated\n(but not scaled or rotated) to the origin of the destructible actor.  If a chunk or chunk island moves\noutside of those bounds, it is destroyed.\n", true);
		HintTable[1].init("shortDescription", "If set, the validBounds field of NxDestructibleParameters will be used.", true);
		ParamDefTable[74].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=75, longName="destructibleParameters.flags.CRUMBLE_VIA_RUNTIME_FRACTURE"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[75];
		ParamDef->init("CRUMBLE_VIA_RUNTIME_FRACTURE", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If set, crumbled chunks will use the runtime fracture pipeline. The chunk will be procedurally broken\ndestroyed using either the default or a specified fracture pattern.\n", true);
		HintTable[1].init("shortDescription", "If set, crumbled chunks will use the runtime fracture pipeline.", true);
		ParamDefTable[75].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=76, longName="destructibleParameters.fractureImpulseScale"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[76];
		ParamDef->init("fractureImpulseScale", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Scale factor used to apply an impulse force along the normal of chunk when fractured.  This is used\nin order to 'push' the pieces out as they fracture.\n", true);
		HintTable[1].init("shortDescription", "Scale factor used to apply an impulse force along the normal of chunk when fractured.", true);
		ParamDefTable[76].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=77, longName="destructibleParameters.damageDepthLimit"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[77];
		ParamDef->init("damageDepthLimit", TYPE_U16, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "How deep in the hierarchy damage will be propagated, relative to the chunk hit.", true);
		HintTable[1].init("shortDescription", "How deep in the hierarchy damage will be propagated, relative to the chunk hit.", true);
		ParamDefTable[77].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=78, longName="destructibleParameters.dynamicChunkDominanceGroup"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[78];
		ParamDef->init("dynamicChunkDominanceGroup", TYPE_U16, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Optional dominance group for dynamic chunks created when fractured. (ignored if > 31)\n", true);
		HintTable[1].init("shortDescription", "Optional dominance group for dynamic chunks created when fractured.", true);
		ParamDefTable[78].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=79, longName="destructibleParameters.dynamicChunksGroupsMask"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[79];
		ParamDef->init("dynamicChunksGroupsMask", TYPE_STRUCT, "GroupsMask", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Optional groups mask for dynamic chunks created when fractured.\n", true);
		HintTable[1].init("shortDescription", "Optional groups mask for dynamic chunks created when fractured.", true);
		ParamDefTable[79].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=80, longName="destructibleParameters.dynamicChunksGroupsMask.useGroupsMask"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[80];
		ParamDef->init("useGroupsMask", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Whether or not the groupsMask should be used.  If so, then this will be applied to all NxShapes\n						created to represent this destructible's chunks.", true);
		HintTable[1].init("shortDescription", "Whether or not the groupsMask should be used", true);
		ParamDefTable[80].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=81, longName="destructibleParameters.dynamicChunksGroupsMask.bits0"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[81];
		ParamDef->init("bits0", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits0 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits0 of the groups mask", true);
		ParamDefTable[81].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=82, longName="destructibleParameters.dynamicChunksGroupsMask.bits1"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[82];
		ParamDef->init("bits1", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits1 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits1 of the groups mask", true);
		ParamDefTable[82].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=83, longName="destructibleParameters.dynamicChunksGroupsMask.bits2"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[83];
		ParamDef->init("bits2", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits2 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits2 of the groups mask", true);
		ParamDefTable[83].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=84, longName="destructibleParameters.dynamicChunksGroupsMask.bits3"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[84];
		ParamDef->init("bits3", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If useGroupsMask is true, this is bits3 of the groups mask.  See the PhysX documentation for more on groups masks.", true);
		HintTable[1].init("shortDescription", "bits3 of the groups mask", true);
		ParamDefTable[84].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=85, longName="depthParameters"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[85];
		ParamDef->init("depthParameters", TYPE_ARRAY, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The default destructible depth parameters for this asset.  These\n					are properties that apply to all chunks at a particular level of the hierarchy.  These may be overridden\n					for an instance (destructible actor), as a copy of the parameters is also stored in the actor.", true);
		HintTable[1].init("shortDescription", "The default destructible depth parameters for this asset", true);
		ParamDefTable[85].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=86, longName="depthParameters[]"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[86];
		ParamDef->init("depthParameters", TYPE_STRUCT, "DestructibleDepthParameters", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The default destructible depth parameters for this asset.  These\n					are properties that apply to all chunks at a particular level of the hierarchy.  These may be overridden\n					for an instance (destructible actor), as a copy of the parameters is also stored in the actor.", true);
		HintTable[1].init("shortDescription", "The default destructible depth parameters for this asset", true);
		ParamDefTable[86].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=87, longName="depthParameters[].OVERRIDE_IMPACT_DAMAGE"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[87];
		ParamDef->init("OVERRIDE_IMPACT_DAMAGE", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunks at this hierarchy depth level will take impact damage iff OVERRIDE_IMPACT_DAMAGE_VALUE = TRUE, no matter the setting of impactDamageDefaultDepth.\n", true);
		HintTable[1].init("shortDescription", "If true, chunks at this hierarchy depth level will take impact damage iff OVERRIDE_IMPACT_DAMAGE_VALUE = TRUE, no matter the setting of impactDamageDefaultDepth.", true);
		ParamDefTable[87].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=88, longName="depthParameters[].OVERRIDE_IMPACT_DAMAGE_VALUE"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[88];
		ParamDef->init("OVERRIDE_IMPACT_DAMAGE_VALUE", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If OVERRIDE_IMPACT_DAMAGE = TRUE, chunks at this hierarchy depth level will take impact damage iff OVERRIDE_IMPACT_DAMAGE_VALUE = TRUE.\n", true);
		HintTable[1].init("shortDescription", "If OVERRIDE_IMPACT_DAMAGE = TRUE, chunks at this hierarchy depth level will take impact damage iff OVERRIDE_IMPACT_DAMAGE_VALUE = TRUE.", true);
		ParamDefTable[88].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=89, longName="depthParameters[].IGNORE_POSE_UPDATES"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[89];
		ParamDef->init("IGNORE_POSE_UPDATES", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunks at this depth should have pose updates ignored.\n", true);
		HintTable[1].init("shortDescription", "Chunks at this depth should have pose updates ignored.", true);
		ParamDefTable[89].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=90, longName="depthParameters[].IGNORE_RAYCAST_CALLBACKS"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[90];
		ParamDef->init("IGNORE_RAYCAST_CALLBACKS", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunks at this depth should be ignored in raycast callbacks.\n", true);
		HintTable[1].init("shortDescription", "Chunks at this depth should be ignored in raycast callbacks.", true);
		ParamDefTable[90].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=91, longName="depthParameters[].IGNORE_CONTACT_CALLBACKS"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[91];
		ParamDef->init("IGNORE_CONTACT_CALLBACKS", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Chunks at this depth should be ignored in contact callbacks.\n", true);
		HintTable[1].init("shortDescription", "Chunks at this depth should be ignored in contact callbacks.", true);
		ParamDefTable[91].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=92, longName="depthParameters[].USER_FLAG_0"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[92];
		ParamDef->init("USER_FLAG_0", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "User defined flag.\n", true);
		HintTable[1].init("shortDescription", "User defined flag.", true);
		ParamDefTable[92].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=93, longName="depthParameters[].USER_FLAG_1"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[93];
		ParamDef->init("USER_FLAG_1", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "User defined flag.\n", true);
		HintTable[1].init("shortDescription", "User defined flag.", true);
		ParamDefTable[93].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=94, longName="depthParameters[].USER_FLAG_2"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[94];
		ParamDef->init("USER_FLAG_2", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "User defined flag.\n", true);
		HintTable[1].init("shortDescription", "User defined flag.", true);
		ParamDefTable[94].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=95, longName="depthParameters[].USER_FLAG_3"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[95];
		ParamDef->init("USER_FLAG_3", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "User defined flag.\n", true);
		HintTable[1].init("shortDescription", "User defined flag.", true);
		ParamDefTable[95].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=96, longName="crumbleEmitterName"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[96];
		ParamDef->init("crumbleEmitterName", TYPE_STRING, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The name of the crumble emitter to use when crumbling\n					the smallest chunks.", true);
		HintTable[1].init("shortDescription", "The name of the crumble emitter to use", true);
		ParamDefTable[96].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=97, longName="dustEmitterName"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[97];
		ParamDef->init("dustEmitterName", TYPE_STRING, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The name of the dust emitter to use.  If defined, dust particles\n					will be spawned above the chunk surface traces when a chunk is fractured.", true);
		HintTable[1].init("shortDescription", "The name of the dust emitter to use", true);
		ParamDefTable[97].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=98, longName="collisionData"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[98];
		ParamDef->init("collisionData", TYPE_REF, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		ParamDefTable[98].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		HintTable[1].init("longDescription", "The cooked convex data for PhysX collision.  All cooked convex hulls for a set of\n					scales may be included", true);
		HintTable[2].init("shortDescription", "The cooked convex data for PhysX collision", true);
		ParamDefTable[98].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "DestructibleAssetCollisionDataSet" };
		ParamDefTable[98].setRefVariantVals((const char**)RefVariantVals, 1);



	}

	// Initialize DefinitionImpl node: nodeIndex=99, longName="renderMeshAsset"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[99];
		ParamDef->init("renderMeshAsset", TYPE_REF, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		ParamDefTable[99].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		HintTable[1].init("longDescription", "The included render mesh asset.", true);
		HintTable[2].init("shortDescription", "The included render mesh asset", true);
		ParamDefTable[99].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "RenderMeshAssetParameters" };
		ParamDefTable[99].setRefVariantVals((const char**)RefVariantVals, 1);



	}

	// Initialize DefinitionImpl node: nodeIndex=100, longName="initialDestructibleActorAllowanceForInstancing"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[100];
		ParamDef->init("initialDestructibleActorAllowanceForInstancing", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Initial actor estimate for instance buffer allocation.\n					Used for setting instance buffer sizes.", true);
		HintTable[1].init("shortDescription", "Initial actor estimate for instance buffer allocation", true);
		ParamDefTable[100].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=101, longName="chunkInstanceInfo"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[101];
		ParamDef->init("chunkInstanceInfo", TYPE_ARRAY, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Per-instance data for each instanced chunk.", true);
		HintTable[1].init("shortDescription", "Per-instance data for each instanced chunk", true);
		ParamDefTable[101].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=102, longName="chunkInstanceInfo[]"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[102];
		ParamDef->init("chunkInstanceInfo", TYPE_STRUCT, "InstanceInfo", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Per-instance data for each instanced chunk.", true);
		HintTable[1].init("shortDescription", "Per-instance data for each instanced chunk", true);
		ParamDefTable[102].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=103, longName="chunkInstanceInfo[].partIndex"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[103];
		ParamDef->init("partIndex", TYPE_U16, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The part instanced for this chunk.", true);
		HintTable[1].init("shortDescription", "The part instanced for this chunk", true);
		ParamDefTable[103].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=104, longName="chunkInstanceInfo[].chunkPositionOffset"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[104];
		ParamDef->init("chunkPositionOffset", TYPE_VEC3, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Translation for this chunk mesh within the asset.\n							Normally a chunk needs no translation, but if a chunk is instanced within\n							the asset, then this translation is needed.", true);
		HintTable[1].init("shortDescription", "Translation for this chunk mesh within the asset", true);
		ParamDefTable[104].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=105, longName="chunkInstanceInfo[].chunkUVOffset"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[105];
		ParamDef->init("chunkUVOffset", TYPE_VEC2, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "UV translation for this chunk mesh's vertices.", true);
		HintTable[1].init("shortDescription", "UV translation for this chunk mesh's vertices", true);
		ParamDefTable[105].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=106, longName="staticMaterialNames"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[106];
		ParamDef->init("staticMaterialNames", TYPE_ARRAY, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Alternative material names for the static render mesh, if it's created.", true);
		HintTable[1].init("shortDescription", "Alternative material names for the static render mesh, if it's created", true);
		ParamDefTable[106].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
		static const physx::PxU8 dynHandleIndices[1] = { 0, };
		ParamDef->setDynamicHandleIndicesMap(dynHandleIndices, 1);

	}

	// Initialize DefinitionImpl node: nodeIndex=107, longName="staticMaterialNames[]"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[107];
		ParamDef->init("staticMaterialNames", TYPE_STRING, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Alternative material names for the static render mesh, if it's created.", true);
		HintTable[1].init("shortDescription", "Alternative material names for the static render mesh, if it's created", true);
		ParamDefTable[107].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=108, longName="neighborPadding"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[108];
		ParamDef->init("neighborPadding", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Padding used for chunk neighbor tests.  This padding is relative to the largest diagonal\n					of the asset's local bounding box.\n					This value must be non-negative.\n					Default value = 0.001f.", true);
		HintTable[1].init("shortDescription", "Padding used for chunk neighbor tests.", true);
		ParamDefTable[108].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=109, longName="overlapsAtDepth"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[109];
		ParamDef->init("overlapsAtDepth", TYPE_ARRAY, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		ParamDefTable[109].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		HintTable[1].init("longDescription", "The chunk overlaps (adjacencies) at each depth of the hierarchy.", true);
		HintTable[2].init("shortDescription", "The chunk overlaps at each depth of the hierarchy", true);
		ParamDefTable[109].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "CachedOverlaps" };
		ParamDefTable[109].setRefVariantVals((const char**)RefVariantVals, 1);


		ParamDef->setArraySize(-1);
		static const physx::PxU8 dynHandleIndices[1] = { 0, };
		ParamDef->setDynamicHandleIndicesMap(dynHandleIndices, 1);

	}

	// Initialize DefinitionImpl node: nodeIndex=110, longName="overlapsAtDepth[]"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[110];
		ParamDef->init("overlapsAtDepth", TYPE_REF, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		ParamDefTable[110].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("INCLUDED", physx::PxU64(1), true);
		HintTable[1].init("longDescription", "The chunk overlaps (adjacencies) at each depth of the hierarchy.", true);
		HintTable[2].init("shortDescription", "The chunk overlaps at each depth of the hierarchy", true);
		ParamDefTable[110].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "CachedOverlaps" };
		ParamDefTable[110].setRefVariantVals((const char**)RefVariantVals, 1);



	}

	// Initialize DefinitionImpl node: nodeIndex=111, longName="firstChunkAtDepth"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[111];
		ParamDef->init("firstChunkAtDepth", TYPE_ARRAY, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The first index of chunks at each depth in the hierarchy.  All chunks\n					at a given depth are stored contiguously.", true);
		HintTable[1].init("shortDescription", "The first index of chunks at each depth", true);
		ParamDefTable[111].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=112, longName="firstChunkAtDepth[]"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[112];
		ParamDef->init("firstChunkAtDepth", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The first index of chunks at each depth in the hierarchy.  All chunks\n					at a given depth are stored contiguously.", true);
		HintTable[1].init("shortDescription", "The first index of chunks at each depth", true);
		ParamDefTable[112].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=113, longName="supportDepth"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[113];
		ParamDef->init("supportDepth", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The chunk hierarchy depth at which to create a support graph.  Higher depth levels give more detailed support,\nbut will give a higher computational load.  Chunks below the support depth will never be supported.\n", true);
		HintTable[1].init("shortDescription", "The chunk hierarchy depth at which to create a support graph.", true);
		ParamDefTable[113].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=114, longName="formExtendedStructures"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[114];
		ParamDef->init("formExtendedStructures", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If initially static, the destructible will become part of an extended support structure if it is\nin contact with another static destructible that also has this flag set.\n", true);
		HintTable[1].init("shortDescription", "If initially static, the destructible will become part of an extended support structure if it is in contact with another static destructible that also has this flag set.", true);
		ParamDefTable[114].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=115, longName="useAssetDefinedSupport"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[115];
		ParamDef->init("useAssetDefinedSupport", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If set, then chunks which are tagged as 'support' chunks (via NxDestructibleChunkDesc::isSupportChunk)\nwill have environmental support in static destructibles.\nNote: if both ASSET_DEFINED_SUPPORT and WORLD_SUPPORT are set, then chunks must be tagged as\n'support' chunks AND overlap the NxScene's static geometry in order to be environmentally supported.\n", true);
		HintTable[1].init("shortDescription", "If set, then chunks which are tagged as 'support' chunks", true);
		ParamDefTable[115].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=116, longName="useWorldSupport"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[116];
		ParamDef->init("useWorldSupport", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If set, then chunks which overlap the NxScene\'s static geometry will have environmental support in\nstatic destructibles.\nNote: if both ASSET_DEFINED_SUPPORT and WORLD_SUPPORT are set, then chunks must be tagged as\n'support' chunks AND overlap the NxScene's static geometry in order to be environmentally supported.\n", true);
		HintTable[1].init("shortDescription", "If set, then chunks which overlap the NxScene's static geometry will have environmental support", true);
		ParamDefTable[116].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=117, longName="actorTransforms"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[117];
		ParamDef->init("actorTransforms", TYPE_ARRAY, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "List of actor poses (that may contain scaling) which may be saved in the asset for convenience.", true);
		HintTable[1].init("shortDescription", "List of actor poses (that may contain scaling) which may be saved in the asset for convenience", true);
		ParamDefTable[117].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=118, longName="actorTransforms[]"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[118];
		ParamDef->init("actorTransforms", TYPE_MAT44, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "List of actor poses (that may contain scaling) which may be saved in the asset for convenience.", true);
		HintTable[1].init("shortDescription", "List of actor poses (that may contain scaling) which may be saved in the asset for convenience", true);
		ParamDefTable[118].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// SetChildren for: nodeIndex=0, longName=""
	{
		static Definition* Children[27];
		Children[0] = PDEF_PTR(1);
		Children[1] = PDEF_PTR(2);
		Children[2] = PDEF_PTR(3);
		Children[3] = PDEF_PTR(4);
		Children[4] = PDEF_PTR(5);
		Children[5] = PDEF_PTR(21);
		Children[6] = PDEF_PTR(38);
		Children[7] = PDEF_PTR(39);
		Children[8] = PDEF_PTR(49);
		Children[9] = PDEF_PTR(51);
		Children[10] = PDEF_PTR(53);
		Children[11] = PDEF_PTR(85);
		Children[12] = PDEF_PTR(96);
		Children[13] = PDEF_PTR(97);
		Children[14] = PDEF_PTR(98);
		Children[15] = PDEF_PTR(99);
		Children[16] = PDEF_PTR(100);
		Children[17] = PDEF_PTR(101);
		Children[18] = PDEF_PTR(106);
		Children[19] = PDEF_PTR(108);
		Children[20] = PDEF_PTR(109);
		Children[21] = PDEF_PTR(111);
		Children[22] = PDEF_PTR(113);
		Children[23] = PDEF_PTR(114);
		Children[24] = PDEF_PTR(115);
		Children[25] = PDEF_PTR(116);
		Children[26] = PDEF_PTR(117);

		ParamDefTable[0].setChildren(Children, 27);
	}

	// SetChildren for: nodeIndex=5, longName="defaultBehaviorGroup"
	{
		static Definition* Children[9];
		Children[0] = PDEF_PTR(6);
		Children[1] = PDEF_PTR(7);
		Children[2] = PDEF_PTR(8);
		Children[3] = PDEF_PTR(9);
		Children[4] = PDEF_PTR(13);
		Children[5] = PDEF_PTR(17);
		Children[6] = PDEF_PTR(18);
		Children[7] = PDEF_PTR(19);
		Children[8] = PDEF_PTR(20);

		ParamDefTable[5].setChildren(Children, 9);
	}

	// SetChildren for: nodeIndex=9, longName="defaultBehaviorGroup.damageSpread"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(10);
		Children[1] = PDEF_PTR(11);
		Children[2] = PDEF_PTR(12);

		ParamDefTable[9].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=13, longName="defaultBehaviorGroup.damageColorSpread"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(14);
		Children[1] = PDEF_PTR(15);
		Children[2] = PDEF_PTR(16);

		ParamDefTable[13].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=21, longName="behaviorGroups"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(22);

		ParamDefTable[21].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=22, longName="behaviorGroups[]"
	{
		static Definition* Children[9];
		Children[0] = PDEF_PTR(23);
		Children[1] = PDEF_PTR(24);
		Children[2] = PDEF_PTR(25);
		Children[3] = PDEF_PTR(26);
		Children[4] = PDEF_PTR(30);
		Children[5] = PDEF_PTR(34);
		Children[6] = PDEF_PTR(35);
		Children[7] = PDEF_PTR(36);
		Children[8] = PDEF_PTR(37);

		ParamDefTable[22].setChildren(Children, 9);
	}

	// SetChildren for: nodeIndex=26, longName="behaviorGroups[].damageSpread"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(27);
		Children[1] = PDEF_PTR(28);
		Children[2] = PDEF_PTR(29);

		ParamDefTable[26].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=30, longName="behaviorGroups[].damageColorSpread"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(31);
		Children[1] = PDEF_PTR(32);
		Children[2] = PDEF_PTR(33);

		ParamDefTable[30].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=39, longName="chunks"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(40);

		ParamDefTable[39].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=40, longName="chunks[]"
	{
		static Definition* Children[8];
		Children[0] = PDEF_PTR(41);
		Children[1] = PDEF_PTR(42);
		Children[2] = PDEF_PTR(43);
		Children[3] = PDEF_PTR(44);
		Children[4] = PDEF_PTR(45);
		Children[5] = PDEF_PTR(46);
		Children[6] = PDEF_PTR(47);
		Children[7] = PDEF_PTR(48);

		ParamDefTable[40].setChildren(Children, 8);
	}

	// SetChildren for: nodeIndex=49, longName="chunkConvexHulls"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(50);

		ParamDefTable[49].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=51, longName="chunkConvexHullStartIndices"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(52);

		ParamDefTable[51].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=53, longName="destructibleParameters"
	{
		static Definition* Children[19];
		Children[0] = PDEF_PTR(54);
		Children[1] = PDEF_PTR(55);
		Children[2] = PDEF_PTR(56);
		Children[3] = PDEF_PTR(57);
		Children[4] = PDEF_PTR(58);
		Children[5] = PDEF_PTR(59);
		Children[6] = PDEF_PTR(60);
		Children[7] = PDEF_PTR(61);
		Children[8] = PDEF_PTR(62);
		Children[9] = PDEF_PTR(63);
		Children[10] = PDEF_PTR(64);
		Children[11] = PDEF_PTR(65);
		Children[12] = PDEF_PTR(66);
		Children[13] = PDEF_PTR(67);
		Children[14] = PDEF_PTR(68);
		Children[15] = PDEF_PTR(76);
		Children[16] = PDEF_PTR(77);
		Children[17] = PDEF_PTR(78);
		Children[18] = PDEF_PTR(79);

		ParamDefTable[53].setChildren(Children, 19);
	}

	// SetChildren for: nodeIndex=68, longName="destructibleParameters.flags"
	{
		static Definition* Children[7];
		Children[0] = PDEF_PTR(69);
		Children[1] = PDEF_PTR(70);
		Children[2] = PDEF_PTR(71);
		Children[3] = PDEF_PTR(72);
		Children[4] = PDEF_PTR(73);
		Children[5] = PDEF_PTR(74);
		Children[6] = PDEF_PTR(75);

		ParamDefTable[68].setChildren(Children, 7);
	}

	// SetChildren for: nodeIndex=79, longName="destructibleParameters.dynamicChunksGroupsMask"
	{
		static Definition* Children[5];
		Children[0] = PDEF_PTR(80);
		Children[1] = PDEF_PTR(81);
		Children[2] = PDEF_PTR(82);
		Children[3] = PDEF_PTR(83);
		Children[4] = PDEF_PTR(84);

		ParamDefTable[79].setChildren(Children, 5);
	}

	// SetChildren for: nodeIndex=85, longName="depthParameters"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(86);

		ParamDefTable[85].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=86, longName="depthParameters[]"
	{
		static Definition* Children[9];
		Children[0] = PDEF_PTR(87);
		Children[1] = PDEF_PTR(88);
		Children[2] = PDEF_PTR(89);
		Children[3] = PDEF_PTR(90);
		Children[4] = PDEF_PTR(91);
		Children[5] = PDEF_PTR(92);
		Children[6] = PDEF_PTR(93);
		Children[7] = PDEF_PTR(94);
		Children[8] = PDEF_PTR(95);

		ParamDefTable[86].setChildren(Children, 9);
	}

	// SetChildren for: nodeIndex=101, longName="chunkInstanceInfo"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(102);

		ParamDefTable[101].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=102, longName="chunkInstanceInfo[]"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(103);
		Children[1] = PDEF_PTR(104);
		Children[2] = PDEF_PTR(105);

		ParamDefTable[102].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=106, longName="staticMaterialNames"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(107);

		ParamDefTable[106].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=109, longName="overlapsAtDepth"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(110);

		ParamDefTable[109].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=111, longName="firstChunkAtDepth"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(112);

		ParamDefTable[111].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=117, longName="actorTransforms"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(118);

		ParamDefTable[117].setChildren(Children, 1);
	}

	mBuiltFlag = true;

}
void DestructibleAssetParameters_0p17::initStrings(void)
{
	comments.isAllocated = true;
	comments.buf = NULL;
	defaultBehaviorGroup.name.isAllocated = true;
	defaultBehaviorGroup.name.buf = NULL;
	crumbleEmitterName.isAllocated = true;
	crumbleEmitterName.buf = NULL;
	dustEmitterName.isAllocated = true;
	dustEmitterName.buf = NULL;
}

void DestructibleAssetParameters_0p17::initDynamicArrays(void)
{
	behaviorGroups.buf = NULL;
	behaviorGroups.isAllocated = true;
	behaviorGroups.elementSize = sizeof(BehaviorGroup_Type);
	behaviorGroups.arraySizes[0] = 0;
	chunks.buf = NULL;
	chunks.isAllocated = true;
	chunks.elementSize = sizeof(Chunk_Type);
	chunks.arraySizes[0] = 0;
	chunkConvexHulls.buf = NULL;
	chunkConvexHulls.isAllocated = true;
	chunkConvexHulls.elementSize = sizeof(NxParameterized::Interface*);
	chunkConvexHulls.arraySizes[0] = 0;
	chunkConvexHullStartIndices.buf = NULL;
	chunkConvexHullStartIndices.isAllocated = true;
	chunkConvexHullStartIndices.elementSize = sizeof(physx::PxU32);
	chunkConvexHullStartIndices.arraySizes[0] = 0;
	depthParameters.buf = NULL;
	depthParameters.isAllocated = true;
	depthParameters.elementSize = sizeof(DestructibleDepthParameters_Type);
	depthParameters.arraySizes[0] = 0;
	chunkInstanceInfo.buf = NULL;
	chunkInstanceInfo.isAllocated = true;
	chunkInstanceInfo.elementSize = sizeof(InstanceInfo_Type);
	chunkInstanceInfo.arraySizes[0] = 0;
	staticMaterialNames.buf = NULL;
	staticMaterialNames.isAllocated = true;
	staticMaterialNames.elementSize = sizeof(NxParameterized::DummyStringStruct);
	staticMaterialNames.arraySizes[0] = 0;
	overlapsAtDepth.buf = NULL;
	overlapsAtDepth.isAllocated = true;
	overlapsAtDepth.elementSize = sizeof(NxParameterized::Interface*);
	overlapsAtDepth.arraySizes[0] = 0;
	firstChunkAtDepth.buf = NULL;
	firstChunkAtDepth.isAllocated = true;
	firstChunkAtDepth.elementSize = sizeof(physx::PxU32);
	firstChunkAtDepth.arraySizes[0] = 0;
	actorTransforms.buf = NULL;
	actorTransforms.isAllocated = true;
	actorTransforms.elementSize = sizeof(physx::PxMat44);
	actorTransforms.arraySizes[0] = 0;
}

void DestructibleAssetParameters_0p17::initDefaults(void)
{

	freeStrings();
	freeReferences();
	freeDynamicArrays();
	depthCount = physx::PxU32(0);
	originalDepthCount = physx::PxU32(0);
	defaultBehaviorGroup.damageThreshold = physx::PxF32(1);
	defaultBehaviorGroup.damageToRadius = physx::PxF32(0.1);
	defaultBehaviorGroup.damageSpread.minimumRadius = physx::PxF32(0);
	defaultBehaviorGroup.damageSpread.radiusMultiplier = physx::PxF32(1);
	defaultBehaviorGroup.damageSpread.falloffExponent = physx::PxF32(1);
	defaultBehaviorGroup.damageColorSpread.minimumRadius = physx::PxF32(0);
	defaultBehaviorGroup.damageColorSpread.radiusMultiplier = physx::PxF32(1);
	defaultBehaviorGroup.damageColorSpread.falloffExponent = physx::PxF32(1);
	defaultBehaviorGroup.damageColorChange = physx::PxVec4(initVec4(0, 0, 0, 0));
	defaultBehaviorGroup.materialStrength = physx::PxF32(0);
	defaultBehaviorGroup.density = physx::PxF32(0);
	defaultBehaviorGroup.fadeOut = physx::PxF32(1);
	RTFractureBehaviorGroup = physx::PxI8(-1);
	destructibleParameters.damageCap = physx::PxF32(0);
	destructibleParameters.forceToDamage = physx::PxF32(0);
	destructibleParameters.impactVelocityThreshold = physx::PxF32(0);
	destructibleParameters.minimumFractureDepth = physx::PxU32(0);
	destructibleParameters.impactDamageDefaultDepth = physx::PxI32(-1);
	destructibleParameters.debrisDepth = physx::PxI32(-1);
	destructibleParameters.essentialDepth = physx::PxU32(0);
	destructibleParameters.debrisLifetimeMin = physx::PxF32(1);
	destructibleParameters.debrisLifetimeMax = physx::PxF32(10);
	destructibleParameters.debrisMaxSeparationMin = physx::PxF32(1);
	destructibleParameters.debrisMaxSeparationMax = physx::PxF32(10);
	destructibleParameters.debrisDestructionProbability = physx::PxF32(0);
	destructibleParameters.validBounds = physx::PxBounds3(init(-1000, -1000, -1000, 1000, 1000, 1000));
	destructibleParameters.maxChunkSpeed = physx::PxF32(0);
	destructibleParameters.flags.ACCUMULATE_DAMAGE = bool(true);
	destructibleParameters.flags.DEBRIS_TIMEOUT = bool(false);
	destructibleParameters.flags.DEBRIS_MAX_SEPARATION = bool(false);
	destructibleParameters.flags.CRUMBLE_SMALLEST_CHUNKS = bool(false);
	destructibleParameters.flags.ACCURATE_RAYCASTS = bool(false);
	destructibleParameters.flags.USE_VALID_BOUNDS = bool(false);
	destructibleParameters.flags.CRUMBLE_VIA_RUNTIME_FRACTURE = bool(false);
	destructibleParameters.fractureImpulseScale = physx::PxF32(0);
	destructibleParameters.damageDepthLimit = physx::PxU16(PX_MAX_U16);
	destructibleParameters.dynamicChunkDominanceGroup = physx::PxU16(PX_MAX_U16);
	destructibleParameters.dynamicChunksGroupsMask.useGroupsMask = bool(false);
	destructibleParameters.dynamicChunksGroupsMask.bits0 = physx::PxU32(0);
	destructibleParameters.dynamicChunksGroupsMask.bits1 = physx::PxU32(0);
	destructibleParameters.dynamicChunksGroupsMask.bits2 = physx::PxU32(0);
	destructibleParameters.dynamicChunksGroupsMask.bits3 = physx::PxU32(0);
	initialDestructibleActorAllowanceForInstancing = physx::PxU32(0);
	neighborPadding = physx::PxF32(0.001);
	supportDepth = physx::PxU32(0);
	formExtendedStructures = bool(false);
	useAssetDefinedSupport = bool(false);
	useWorldSupport = bool(false);

	initDynamicArrays();
	initStrings();
	initReferences();
}

void DestructibleAssetParameters_0p17::initReferences(void)
{
	collisionData = NULL;

	renderMeshAsset = NULL;

}

void DestructibleAssetParameters_0p17::freeDynamicArrays(void)
{
	if (behaviorGroups.isAllocated && behaviorGroups.buf)
	{
		mParameterizedTraits->free(behaviorGroups.buf);
	}
	if (chunks.isAllocated && chunks.buf)
	{
		mParameterizedTraits->free(chunks.buf);
	}
	if (chunkConvexHulls.isAllocated && chunkConvexHulls.buf)
	{
		mParameterizedTraits->free(chunkConvexHulls.buf);
	}
	if (chunkConvexHullStartIndices.isAllocated && chunkConvexHullStartIndices.buf)
	{
		mParameterizedTraits->free(chunkConvexHullStartIndices.buf);
	}
	if (depthParameters.isAllocated && depthParameters.buf)
	{
		mParameterizedTraits->free(depthParameters.buf);
	}
	if (chunkInstanceInfo.isAllocated && chunkInstanceInfo.buf)
	{
		mParameterizedTraits->free(chunkInstanceInfo.buf);
	}
	if (staticMaterialNames.isAllocated && staticMaterialNames.buf)
	{
		mParameterizedTraits->free(staticMaterialNames.buf);
	}
	if (overlapsAtDepth.isAllocated && overlapsAtDepth.buf)
	{
		mParameterizedTraits->free(overlapsAtDepth.buf);
	}
	if (firstChunkAtDepth.isAllocated && firstChunkAtDepth.buf)
	{
		mParameterizedTraits->free(firstChunkAtDepth.buf);
	}
	if (actorTransforms.isAllocated && actorTransforms.buf)
	{
		mParameterizedTraits->free(actorTransforms.buf);
	}
}

void DestructibleAssetParameters_0p17::freeStrings(void)
{

	if (comments.isAllocated && comments.buf)
	{
		mParameterizedTraits->strfree((char*)comments.buf);
	}

	if (defaultBehaviorGroup.name.isAllocated && defaultBehaviorGroup.name.buf)
	{
		mParameterizedTraits->strfree((char*)defaultBehaviorGroup.name.buf);
	}

	for (int i = 0; i < behaviorGroups.arraySizes[0]; ++i)
	{
		if (behaviorGroups.buf[i].name.isAllocated && behaviorGroups.buf[i].name.buf)
		{
			mParameterizedTraits->strfree((char*)behaviorGroups.buf[i].name.buf);
		}
	}

	if (crumbleEmitterName.isAllocated && crumbleEmitterName.buf)
	{
		mParameterizedTraits->strfree((char*)crumbleEmitterName.buf);
	}

	if (dustEmitterName.isAllocated && dustEmitterName.buf)
	{
		mParameterizedTraits->strfree((char*)dustEmitterName.buf);
	}

	for (int i = 0; i < staticMaterialNames.arraySizes[0]; ++i)
	{
		if (staticMaterialNames.buf[i].isAllocated && staticMaterialNames.buf[i].buf)
		{
			mParameterizedTraits->strfree((char*)staticMaterialNames.buf[i].buf);
		}
	}
}

void DestructibleAssetParameters_0p17::freeReferences(void)
{

	for (int i = 0; i < chunkConvexHulls.arraySizes[0]; ++i)
	{
		if (chunkConvexHulls.buf[i])
		{
			chunkConvexHulls.buf[i]->destroy();
		}
	}
	if (collisionData)
	{
		collisionData->destroy();
	}

	if (renderMeshAsset)
	{
		renderMeshAsset->destroy();
	}


	for (int i = 0; i < overlapsAtDepth.arraySizes[0]; ++i)
	{
		if (overlapsAtDepth.buf[i])
		{
			overlapsAtDepth.buf[i]->destroy();
		}
	}
}

} // namespace apex
} // namespace physx
