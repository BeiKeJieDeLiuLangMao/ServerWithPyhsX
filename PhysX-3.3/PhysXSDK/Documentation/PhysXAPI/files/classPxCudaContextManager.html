<html>
	<head>
		<title>PxCudaContextManager Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>
	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.8.3.1 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classPxCudaContextManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PxCudaContextManager Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Manages memory, thread locks, and task scheduling for a CUDA context.  
 <a href="classPxCudaContextManager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PxCudaContextManager_8h_source.html">PxCudaContextManager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6c674f0a07e5c73d0db36762be2479a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a6c674f0a07e5c73d0db36762be2479a4">acquireContext</a> ()=0</td></tr>
<tr class="memdesc:a6c674f0a07e5c73d0db36762be2479a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the CUDA context for the current thread.  <a href="#a6c674f0a07e5c73d0db36762be2479a4">More...</a><br/></td></tr>
<tr class="separator:a6c674f0a07e5c73d0db36762be2479a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e4a66821fe1eec0369c318f629a4f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a41e4a66821fe1eec0369c318f629a4f6">releaseContext</a> ()=0</td></tr>
<tr class="memdesc:a41e4a66821fe1eec0369c318f629a4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the CUDA context from the current thread.  <a href="#a41e4a66821fe1eec0369c318f629a4f6">More...</a><br/></td></tr>
<tr class="separator:a41e4a66821fe1eec0369c318f629a4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1020211c98530d7ade68306ac93afc91"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxCudaMemoryManager.html">PxCudaMemoryManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a1020211c98530d7ade68306ac93afc91">getMemoryManager</a> ()=0</td></tr>
<tr class="memdesc:a1020211c98530d7ade68306ac93afc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classPxCudaMemoryManager.html" title="Allocator class for different kinds of CUDA related memory.">PxCudaMemoryManager</a> instance associated with this CUDA context.  <a href="#a1020211c98530d7ade68306ac93afc91">More...</a><br/></td></tr>
<tr class="separator:a1020211c98530d7ade68306ac93afc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9dbc8cea0adfb7fe153ada50cc3bc6"><td class="memItemLeft" align="right" valign="top">virtual class <a class="el" href="classPxGpuDispatcher.html">PxGpuDispatcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a0c9dbc8cea0adfb7fe153ada50cc3bc6">getGpuDispatcher</a> ()=0</td></tr>
<tr class="memdesc:a0c9dbc8cea0adfb7fe153ada50cc3bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> instance associated with this CUDA context.  <a href="#a0c9dbc8cea0adfb7fe153ada50cc3bc6">More...</a><br/></td></tr>
<tr class="separator:a0c9dbc8cea0adfb7fe153ada50cc3bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16cfa9899936afb93306bcc14afb578"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#af16cfa9899936afb93306bcc14afb578">contextIsValid</a> () const =0</td></tr>
<tr class="memdesc:af16cfa9899936afb93306bcc14afb578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context manager has a valid CUDA context.  <a href="#af16cfa9899936afb93306bcc14afb578">More...</a><br/></td></tr>
<tr class="separator:af16cfa9899936afb93306bcc14afb578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d88d4673763194ab51a732639c7ab3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#ad3d88d4673763194ab51a732639c7ab3">supportsArchSM10</a> () const =0</td></tr>
<tr class="memdesc:ad3d88d4673763194ab51a732639c7ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">G80.  <a href="#ad3d88d4673763194ab51a732639c7ab3">More...</a><br/></td></tr>
<tr class="separator:ad3d88d4673763194ab51a732639c7ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cab6cc8d158d900fc0f4f317c33bf41"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a6cab6cc8d158d900fc0f4f317c33bf41">supportsArchSM11</a> () const =0</td></tr>
<tr class="memdesc:a6cab6cc8d158d900fc0f4f317c33bf41"><td class="mdescLeft">&#160;</td><td class="mdescRight">G92.  <a href="#a6cab6cc8d158d900fc0f4f317c33bf41">More...</a><br/></td></tr>
<tr class="separator:a6cab6cc8d158d900fc0f4f317c33bf41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacebd6f1093ae3e22709c4e344091d02"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#aacebd6f1093ae3e22709c4e344091d02">supportsArchSM12</a> () const =0</td></tr>
<tr class="memdesc:aacebd6f1093ae3e22709c4e344091d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">GT200.  <a href="#aacebd6f1093ae3e22709c4e344091d02">More...</a><br/></td></tr>
<tr class="separator:aacebd6f1093ae3e22709c4e344091d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792ed156791b5d3bb26004f37ffd1e8c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a792ed156791b5d3bb26004f37ffd1e8c">supportsArchSM13</a> () const =0</td></tr>
<tr class="memdesc:a792ed156791b5d3bb26004f37ffd1e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">GT260.  <a href="#a792ed156791b5d3bb26004f37ffd1e8c">More...</a><br/></td></tr>
<tr class="separator:a792ed156791b5d3bb26004f37ffd1e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03cc08d37275ae525119ad593a5b4ed"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#af03cc08d37275ae525119ad593a5b4ed">supportsArchSM20</a> () const =0</td></tr>
<tr class="memdesc:af03cc08d37275ae525119ad593a5b4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">GF100.  <a href="#af03cc08d37275ae525119ad593a5b4ed">More...</a><br/></td></tr>
<tr class="separator:af03cc08d37275ae525119ad593a5b4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7193719ae3f558487a68258da4dbb3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#aaf7193719ae3f558487a68258da4dbb3">supportsArchSM30</a> () const =0</td></tr>
<tr class="memdesc:aaf7193719ae3f558487a68258da4dbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">GK100.  <a href="#aaf7193719ae3f558487a68258da4dbb3">More...</a><br/></td></tr>
<tr class="separator:aaf7193719ae3f558487a68258da4dbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42df60a201efe823ee2d5913fcbf018"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#ae42df60a201efe823ee2d5913fcbf018">supportsArchSM35</a> () const =0</td></tr>
<tr class="memdesc:ae42df60a201efe823ee2d5913fcbf018"><td class="mdescLeft">&#160;</td><td class="mdescRight">GK110.  <a href="#ae42df60a201efe823ee2d5913fcbf018">More...</a><br/></td></tr>
<tr class="separator:ae42df60a201efe823ee2d5913fcbf018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4824018005760e905e50dcc32ae1d1f1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a4824018005760e905e50dcc32ae1d1f1">supportsArchSM50</a> () const =0</td></tr>
<tr class="memdesc:a4824018005760e905e50dcc32ae1d1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">GM100.  <a href="#a4824018005760e905e50dcc32ae1d1f1">More...</a><br/></td></tr>
<tr class="separator:a4824018005760e905e50dcc32ae1d1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bac27a028f5b47c1aea0f37af334ec"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#af7bac27a028f5b47c1aea0f37af334ec">supportsArchSM52</a> () const =0</td></tr>
<tr class="memdesc:af7bac27a028f5b47c1aea0f37af334ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">GM200.  <a href="#af7bac27a028f5b47c1aea0f37af334ec">More...</a><br/></td></tr>
<tr class="separator:af7bac27a028f5b47c1aea0f37af334ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258faadc99ef89fdd0acf1aac9583ba2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a258faadc99ef89fdd0acf1aac9583ba2">isIntegrated</a> () const =0</td></tr>
<tr class="memdesc:a258faadc99ef89fdd0acf1aac9583ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if GPU is an integrated (MCP) part  <a href="#a258faadc99ef89fdd0acf1aac9583ba2">More...</a><br/></td></tr>
<tr class="separator:a258faadc99ef89fdd0acf1aac9583ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d60a97fc3a38b2d947f2b5c2a869da1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a9d60a97fc3a38b2d947f2b5c2a869da1">canMapHostMemory</a> () const =0</td></tr>
<tr class="memdesc:a9d60a97fc3a38b2d947f2b5c2a869da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if GPU map host memory to GPU (0-copy)  <a href="#a9d60a97fc3a38b2d947f2b5c2a869da1">More...</a><br/></td></tr>
<tr class="separator:a9d60a97fc3a38b2d947f2b5c2a869da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00561bab2f869a8efd91f77207be6d7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#ad00561bab2f869a8efd91f77207be6d7">getDriverVersion</a> () const =0</td></tr>
<tr class="memdesc:ad00561bab2f869a8efd91f77207be6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns cached value of cuGetDriverVersion()  <a href="#ad00561bab2f869a8efd91f77207be6d7">More...</a><br/></td></tr>
<tr class="separator:ad00561bab2f869a8efd91f77207be6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43b7f4825fd9414ae26af27712e4f23"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#ac43b7f4825fd9414ae26af27712e4f23">getDeviceTotalMemBytes</a> () const =0</td></tr>
<tr class="memdesc:ac43b7f4825fd9414ae26af27712e4f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns cached value of device memory size  <a href="#ac43b7f4825fd9414ae26af27712e4f23">More...</a><br/></td></tr>
<tr class="separator:ac43b7f4825fd9414ae26af27712e4f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fc2560632de072ba5ad34af021488c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a71fc2560632de072ba5ad34af021488c">getMultiprocessorCount</a> () const =0</td></tr>
<tr class="memdesc:a71fc2560632de072ba5ad34af021488c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns cache value of SM unit count  <a href="#a71fc2560632de072ba5ad34af021488c">More...</a><br/></td></tr>
<tr class="separator:a71fc2560632de072ba5ad34af021488c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a06453d6e1b9699a9ed003ab229277d"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a8a06453d6e1b9699a9ed003ab229277d">getClockRate</a> () const =0</td></tr>
<tr class="memdesc:a8a06453d6e1b9699a9ed003ab229277d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns cached value of SM clock frequency  <a href="#a8a06453d6e1b9699a9ed003ab229277d">More...</a><br/></td></tr>
<tr class="separator:a8a06453d6e1b9699a9ed003ab229277d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2e7446f8621db6672df49426abbd11"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a7b2e7446f8621db6672df49426abbd11">getSharedMemPerBlock</a> () const =0</td></tr>
<tr class="memdesc:a7b2e7446f8621db6672df49426abbd11"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns total amount of shared memory available per block in bytes  <a href="#a7b2e7446f8621db6672df49426abbd11">More...</a><br/></td></tr>
<tr class="separator:a7b2e7446f8621db6672df49426abbd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab722230beaa2cbe64df0bfb6fd0183b2"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#ab722230beaa2cbe64df0bfb6fd0183b2">getMaxThreadsPerBlock</a> () const =0</td></tr>
<tr class="memdesc:ab722230beaa2cbe64df0bfb6fd0183b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the maximum number of threads per block  <a href="#ab722230beaa2cbe64df0bfb6fd0183b2">More...</a><br/></td></tr>
<tr class="separator:ab722230beaa2cbe64df0bfb6fd0183b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37903915b5de827c28554faaa3ef2d77"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a37903915b5de827c28554faaa3ef2d77">getDeviceName</a> () const =0</td></tr>
<tr class="memdesc:a37903915b5de827c28554faaa3ef2d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns device name retrieved from driver  <a href="#a37903915b5de827c28554faaa3ef2d77">More...</a><br/></td></tr>
<tr class="separator:a37903915b5de827c28554faaa3ef2d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba939ca6e6c09a84c83737fdc0c4f162"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structPxCudaInteropMode.html#a8ffddfee1f30e09954181d5924d2a3f4">PxCudaInteropMode::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#aba939ca6e6c09a84c83737fdc0c4f162">getInteropMode</a> () const =0</td></tr>
<tr class="memdesc:aba939ca6e6c09a84c83737fdc0c4f162"><td class="mdescLeft">&#160;</td><td class="mdescRight">interop mode the context was created with  <a href="#aba939ca6e6c09a84c83737fdc0c4f162">More...</a><br/></td></tr>
<tr class="separator:aba939ca6e6c09a84c83737fdc0c4f162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0473ee4833593f208ecbbc8f0994b24b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a0473ee4833593f208ecbbc8f0994b24b">setUsingConcurrentStreams</a> (bool)=0</td></tr>
<tr class="memdesc:a0473ee4833593f208ecbbc8f0994b24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">turn on/off using concurrent streams for GPU work  <a href="#a0473ee4833593f208ecbbc8f0994b24b">More...</a><br/></td></tr>
<tr class="separator:a0473ee4833593f208ecbbc8f0994b24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c049e0df8aa445ea34e390b4c07dd5c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a3c049e0df8aa445ea34e390b4c07dd5c">getUsingConcurrentStreams</a> () const =0</td></tr>
<tr class="memdesc:a3c049e0df8aa445ea34e390b4c07dd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if GPU work can run in concurrent streams  <a href="#a3c049e0df8aa445ea34e390b4c07dd5c">More...</a><br/></td></tr>
<tr class="separator:a3c049e0df8aa445ea34e390b4c07dd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b425a8646f76445413fe014cc5d0a95"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a8b425a8646f76445413fe014cc5d0a95">registerResourceInCudaGL</a> (<a class="el" href="PxCudaContextManager_8h.html#ac0c4e1704647178d9c5ba3be46517dcd">CUgraphicsResource</a> &amp;resource, <a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> buffer)=0</td></tr>
<tr class="memdesc:a8b425a8646f76445413fe014cc5d0a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a rendering resource with CUDA.  <a href="#a8b425a8646f76445413fe014cc5d0a95">More...</a><br/></td></tr>
<tr class="separator:a8b425a8646f76445413fe014cc5d0a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1515fe6dc7f7ffb5ff0ccfa2a0bf9b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a1e1515fe6dc7f7ffb5ff0ccfa2a0bf9b">registerResourceInCudaD3D</a> (<a class="el" href="PxCudaContextManager_8h.html#ac0c4e1704647178d9c5ba3be46517dcd">CUgraphicsResource</a> &amp;resource, void *resourcePointer)=0</td></tr>
<tr class="memdesc:a1e1515fe6dc7f7ffb5ff0ccfa2a0bf9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a rendering resource with CUDA.  <a href="#a1e1515fe6dc7f7ffb5ff0ccfa2a0bf9b">More...</a><br/></td></tr>
<tr class="separator:a1e1515fe6dc7f7ffb5ff0ccfa2a0bf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd62e426e229ca61e0ea44bc39e15c20"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#abd62e426e229ca61e0ea44bc39e15c20">unregisterResourceInCuda</a> (<a class="el" href="PxCudaContextManager_8h.html#ac0c4e1704647178d9c5ba3be46517dcd">CUgraphicsResource</a> resource)=0</td></tr>
<tr class="memdesc:abd62e426e229ca61e0ea44bc39e15c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a rendering resource with CUDA.  <a href="#abd62e426e229ca61e0ea44bc39e15c20">More...</a><br/></td></tr>
<tr class="separator:abd62e426e229ca61e0ea44bc39e15c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d4f773ea780ede42f5f4c3a6fc9182"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a96d4f773ea780ede42f5f4c3a6fc9182">usingDedicatedPhysXGPU</a> () const =0</td></tr>
<tr class="memdesc:a96d4f773ea780ede42f5f4c3a6fc9182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the user has configured a dedicated PhysX GPU in the NV Control Panel.  <a href="#a96d4f773ea780ede42f5f4c3a6fc9182">More...</a><br/></td></tr>
<tr class="separator:a96d4f773ea780ede42f5f4c3a6fc9182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3625bfb1d3426963a3987eda8ff88661"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a3625bfb1d3426963a3987eda8ff88661">release</a> ()=0</td></tr>
<tr class="memdesc:a3625bfb1d3426963a3987eda8ff88661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the <a class="el" href="classPxCudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">PxCudaContextManager</a>.  <a href="#a3625bfb1d3426963a3987eda8ff88661">More...</a><br/></td></tr>
<tr class="separator:a3625bfb1d3426963a3987eda8ff88661"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a94e6c0e48087fd0efd42e810e786ea4a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCudaContextManager.html#a94e6c0e48087fd0efd42e810e786ea4a">~PxCudaContextManager</a> ()</td></tr>
<tr class="memdesc:a94e6c0e48087fd0efd42e810e786ea4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">protected destructor, use <a class="el" href="classPxCudaContextManager.html#a3625bfb1d3426963a3987eda8ff88661" title="Release the PxCudaContextManager.">release()</a> method  <a href="#a94e6c0e48087fd0efd42e810e786ea4a">More...</a><br/></td></tr>
<tr class="separator:a94e6c0e48087fd0efd42e810e786ea4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manages memory, thread locks, and task scheduling for a CUDA context. </p>
<p>A <a class="el" href="classPxCudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">PxCudaContextManager</a> manages access to a single CUDA context, allowing it to be shared between multiple scenes. Memory allocations are dynamic: starting with an initial heap size and growing on demand by a configurable page size. The context must be acquired from the manager before using any CUDA APIs.</p>
<p>The <a class="el" href="classPxCudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">PxCudaContextManager</a> is based on the CUDA driver API and explictly does not support the the CUDA runtime API (aka, CUDART).</p>
<p>To enable CUDA use by an APEX scene, a <a class="el" href="classPxCudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">PxCudaContextManager</a> must be created (supplying your own CUDA context, or allowing a new context to be allocated for you), the <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> for that context is retrieved via the <a class="el" href="classPxCudaContextManager.html#a0c9dbc8cea0adfb7fe153ada50cc3bc6" title="Return the PxGpuDispatcher instance associated with this CUDA context.">getGpuDispatcher()</a> method, and this is assigned to the TaskManager that is given to the scene via its NxApexSceneDesc. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a94e6c0e48087fd0efd42e810e786ea4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxCudaContextManager::~PxCudaContextManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>protected destructor, use <a class="el" href="classPxCudaContextManager.html#a3625bfb1d3426963a3987eda8ff88661" title="Release the PxCudaContextManager.">release()</a> method </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6c674f0a07e5c73d0db36762be2479a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxCudaContextManager::acquireContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire the CUDA context for the current thread. </p>
<p>Acquisitions are allowed to be recursive within a single thread. You can acquire the context multiple times so long as you release it the same count.</p>
<p>The context must be acquired before using most CUDA functions.</p>
<p>It is not necessary to acquire the CUDA context inside GpuTask launch functions, because the <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> will have already acquired the context for its worker thread. However it is not harmfull to (re)acquire the context in code that is shared between GpuTasks and non-task functions. </p>

</div>
</div>
<a class="anchor" id="a9d60a97fc3a38b2d947f2b5c2a869da1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCudaContextManager::canMapHostMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if GPU map host memory to GPU (0-copy) </p>

</div>
</div>
<a class="anchor" id="af16cfa9899936afb93306bcc14afb578"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCudaContextManager::contextIsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Context manager has a valid CUDA context. </p>
<p>This method should be called after creating a <a class="el" href="classPxCudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">PxCudaContextManager</a>, especially if the manager was responsible for allocating its own CUDA context (desc.ctx == NULL). If it returns false, there is no point in assigning this manager's <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> to a TaskManager as it will be unable to execute GpuTasks. </p>

</div>
</div>
<a class="anchor" id="a8a06453d6e1b9699a9ed003ab229277d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int PxCudaContextManager::getClockRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns cached value of SM clock frequency </p>

</div>
</div>
<a class="anchor" id="a37903915b5de827c28554faaa3ef2d77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* PxCudaContextManager::getDeviceName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns device name retrieved from driver </p>

</div>
</div>
<a class="anchor" id="ac43b7f4825fd9414ae26af27712e4f23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t PxCudaContextManager::getDeviceTotalMemBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns cached value of device memory size </p>

</div>
</div>
<a class="anchor" id="ad00561bab2f869a8efd91f77207be6d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int PxCudaContextManager::getDriverVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns cached value of cuGetDriverVersion() </p>

</div>
</div>
<a class="anchor" id="a0c9dbc8cea0adfb7fe153ada50cc3bc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual class <a class="el" href="classPxGpuDispatcher.html">PxGpuDispatcher</a>* PxCudaContextManager::getGpuDispatcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> instance associated with this CUDA context. </p>

</div>
</div>
<a class="anchor" id="aba939ca6e6c09a84c83737fdc0c4f162"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structPxCudaInteropMode.html#a8ffddfee1f30e09954181d5924d2a3f4">PxCudaInteropMode::Enum</a> PxCudaContextManager::getInteropMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>interop mode the context was created with </p>

</div>
</div>
<a class="anchor" id="ab722230beaa2cbe64df0bfb6fd0183b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int PxCudaContextManager::getMaxThreadsPerBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the maximum number of threads per block </p>

</div>
</div>
<a class="anchor" id="a1020211c98530d7ade68306ac93afc91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxCudaMemoryManager.html">PxCudaMemoryManager</a>* PxCudaContextManager::getMemoryManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classPxCudaMemoryManager.html" title="Allocator class for different kinds of CUDA related memory.">PxCudaMemoryManager</a> instance associated with this CUDA context. </p>

</div>
</div>
<a class="anchor" id="a71fc2560632de072ba5ad34af021488c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int PxCudaContextManager::getMultiprocessorCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns cache value of SM unit count </p>

</div>
</div>
<a class="anchor" id="a7b2e7446f8621db6672df49426abbd11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int PxCudaContextManager::getSharedMemPerBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns total amount of shared memory available per block in bytes </p>

</div>
</div>
<a class="anchor" id="a3c049e0df8aa445ea34e390b4c07dd5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCudaContextManager::getUsingConcurrentStreams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if GPU work can run in concurrent streams </p>

</div>
</div>
<a class="anchor" id="a258faadc99ef89fdd0acf1aac9583ba2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCudaContextManager::isIntegrated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if GPU is an integrated (MCP) part </p>

</div>
</div>
<a class="anchor" id="a1e1515fe6dc7f7ffb5ff0ccfa2a0bf9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCudaContextManager::registerResourceInCudaD3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PxCudaContextManager_8h.html#ac0c4e1704647178d9c5ba3be46517dcd">CUgraphicsResource</a> &amp;&#160;</td>
          <td class="paramname"><em>resource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>resourcePointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a rendering resource with CUDA. </p>
<p>This function is called to register render resources (allocated from Direct3D) with CUDA so that the memory may be shared between the two systems. This is only required for render resources that are designed for interop use. In APEX, each render resource descriptor that could support interop has a 'registerInCUDA' boolean variable.</p>
<p>The function must be called again any time your graphics device is reset, to re-register the resource.</p>
<p>Returns true if the registration succeeded. A registered resource must be unregistered before it can be released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource</td><td>[OUT] the handle to the resource that can be used with CUDA </td></tr>
    <tr><td class="paramname">resourcePointer</td><td>[IN] A pointer to either IDirect3DResource9, or ID3D10Device, or ID3D11Resource to be registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b425a8646f76445413fe014cc5d0a95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCudaContextManager::registerResourceInCudaGL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PxCudaContextManager_8h.html#ac0c4e1704647178d9c5ba3be46517dcd">CUgraphicsResource</a> &amp;&#160;</td>
          <td class="paramname"><em>resource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a rendering resource with CUDA. </p>
<p>This function is called to register render resources (allocated from OpenGL) with CUDA so that the memory may be shared between the two systems. This is only required for render resources that are designed for interop use. In APEX, each render resource descriptor that could support interop has a 'registerInCUDA' boolean variable.</p>
<p>The function must be called again any time your graphics device is reset, to re-register the resource.</p>
<p>Returns true if the registration succeeded. A registered resource must be unregistered before it can be released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource</td><td>[OUT] the handle to the resource that can be used with CUDA </td></tr>
    <tr><td class="paramname">buffer</td><td>[IN] GLuint buffer index to be mapped to cuda </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3625bfb1d3426963a3987eda8ff88661"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxCudaContextManager::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the <a class="el" href="classPxCudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">PxCudaContextManager</a>. </p>
<p>When the manager instance is released, it also releases its <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> instance and <a class="el" href="classPxCudaMemoryManager.html" title="Allocator class for different kinds of CUDA related memory.">PxCudaMemoryManager</a>. Before the memory manager is released, it frees all allocated memory pages. If the <a class="el" href="classPxCudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">PxCudaContextManager</a> created the CUDA context it was responsible for, it also frees that context.</p>
<p>Do not release the <a class="el" href="classPxCudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">PxCudaContextManager</a> if there are any scenes using its <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a>. Those scenes must be released first since there is no safe way to remove a <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> from a TaskManager once the TaskManager has been given to a scene. </p>

</div>
</div>
<a class="anchor" id="a41e4a66821fe1eec0369c318f629a4f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxCudaContextManager::releaseContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the CUDA context from the current thread. </p>
<p>The CUDA context should be released as soon as practically possible, to allow other CPU threads (including the <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a>) to work efficiently. </p>

</div>
</div>
<a class="anchor" id="a0473ee4833593f208ecbbc8f0994b24b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxCudaContextManager::setUsingConcurrentStreams </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>turn on/off using concurrent streams for GPU work </p>

</div>
</div>
<a class="anchor" id="ad3d88d4673763194ab51a732639c7ab3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCudaContextManager::supportsArchSM10 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>G80. </p>

</div>
</div>
<a class="anchor" id="a6cab6cc8d158d900fc0f4f317c33bf41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCudaContextManager::supportsArchSM11 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>G92. </p>

</div>
</div>
<a class="anchor" id="aacebd6f1093ae3e22709c4e344091d02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCudaContextManager::supportsArchSM12 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GT200. </p>

</div>
</div>
<a class="anchor" id="a792ed156791b5d3bb26004f37ffd1e8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCudaContextManager::supportsArchSM13 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GT260. </p>

</div>
</div>
<a class="anchor" id="af03cc08d37275ae525119ad593a5b4ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCudaContextManager::supportsArchSM20 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GF100. </p>

</div>
</div>
<a class="anchor" id="aaf7193719ae3f558487a68258da4dbb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCudaContextManager::supportsArchSM30 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GK100. </p>

</div>
</div>
<a class="anchor" id="ae42df60a201efe823ee2d5913fcbf018"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCudaContextManager::supportsArchSM35 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GK110. </p>

</div>
</div>
<a class="anchor" id="a4824018005760e905e50dcc32ae1d1f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCudaContextManager::supportsArchSM50 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GM100. </p>

</div>
</div>
<a class="anchor" id="af7bac27a028f5b47c1aea0f37af334ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCudaContextManager::supportsArchSM52 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GM200. </p>

</div>
</div>
<a class="anchor" id="abd62e426e229ca61e0ea44bc39e15c20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCudaContextManager::unregisterResourceInCuda </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PxCudaContextManager_8h.html#ac0c4e1704647178d9c5ba3be46517dcd">CUgraphicsResource</a>&#160;</td>
          <td class="paramname"><em>resource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister a rendering resource with CUDA. </p>
<p>If a render resource was successfully registered with CUDA using the registerResourceInCuda***() methods, this function must be called to unregister the resource before the it can be released. </p>

</div>
</div>
<a class="anchor" id="a96d4f773ea780ede42f5f4c3a6fc9182"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int PxCudaContextManager::usingDedicatedPhysXGPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the user has configured a dedicated PhysX GPU in the NV Control Panel. </p>
<dl class="section note"><dt>Note</dt><dd>If using CUDA Interop, this will always return false </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>1 if there is a dedicated PhysX GPU </dd>
<dd>
0 if there is NOT a dedicated PhysX GPU </dd>
<dd>
-1 if the routine is not implemented </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxCudaContextManager_8h_source.html">PxCudaContextManager.h</a></li>
</ul>
</div><!-- contents -->

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2015 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
