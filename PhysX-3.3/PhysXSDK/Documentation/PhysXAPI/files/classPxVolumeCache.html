<html>
	<head>
		<title>PxVolumeCache Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>
	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.8.3.1 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classPxVolumeCache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PxVolumeCache Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__physics.html">Physics</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Volumetric cache for local collision geometry.  
 <a href="classPxVolumeCache.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PxVolumeCache_8h_source.html">PxVolumeCache.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxVolumeCache_1_1Iterator.html">Iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback wrapper class for use with <a class="el" href="classPxVolumeCache.html#ae589287aa090d15e8bd13efd7a80285b" title="Iterates over the scene shapes overlapping with the cache volume.">PxVolumeCache::forEach</a> function.  <a href="structPxVolumeCache_1_1Iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a43e58f6fea62f6ec81827e2f251912f5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#a43e58f6fea62f6ec81827e2f251912f5">FillStatus</a> { <br/>
&#160;&#160;<a class="el" href="classPxVolumeCache.html#a43e58f6fea62f6ec81827e2f251912f5a05556701b332b57b8899a95c431d8b56">FILL_OK</a>, 
<br/>
&#160;&#160;<a class="el" href="classPxVolumeCache.html#a43e58f6fea62f6ec81827e2f251912f5a4a3175a948c5e06d6a2c2f44495a6f95">FILL_OVER_MAX_COUNT</a>, 
<br/>
&#160;&#160;<a class="el" href="classPxVolumeCache.html#a43e58f6fea62f6ec81827e2f251912f5a36f4ffaf326d5f4fc310fd0a8676e6f3">FILL_UNSUPPORTED_GEOMETRY_TYPE</a>, 
<br/>
&#160;&#160;<a class="el" href="classPxVolumeCache.html#a43e58f6fea62f6ec81827e2f251912f5acbdc57f8bf59feec81f31871969c8c1e">FILL_OUT_OF_MEMORY</a>
<br/>
 }</td></tr>
<tr class="memdesc:a43e58f6fea62f6ec81827e2f251912f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">describes <a class="el" href="classPxVolumeCache.html#a046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> return status.  <a href="classPxVolumeCache.html#a43e58f6fea62f6ec81827e2f251912f5">More...</a><br/></td></tr>
<tr class="separator:a43e58f6fea62f6ec81827e2f251912f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a046b0c5bed6e6f0dad3696cc9b69ed17"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxVolumeCache.html#a43e58f6fea62f6ec81827e2f251912f5">FillStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#a046b0c5bed6e6f0dad3696cc9b69ed17">fill</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;cacheVolume, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose)=0</td></tr>
<tr class="memdesc:a046b0c5bed6e6f0dad3696cc9b69ed17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the cache with objects intersecting the specified cacheVolume.  <a href="#a046b0c5bed6e6f0dad3696cc9b69ed17">More...</a><br/></td></tr>
<tr class="separator:a046b0c5bed6e6f0dad3696cc9b69ed17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af151c4569e890ee2b36b1c9ad0da348f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#af151c4569e890ee2b36b1c9ad0da348f">isValid</a> () const =0</td></tr>
<tr class="memdesc:af151c4569e890ee2b36b1c9ad0da348f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the cache is valid (not over specified max capacity, for both statics and dynamics) and up-to-date.  <a href="#af151c4569e890ee2b36b1c9ad0da348f">More...</a><br/></td></tr>
<tr class="separator:af151c4569e890ee2b36b1c9ad0da348f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f2d9a1fcd27838188f4da17ae03dd8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#aa5f2d9a1fcd27838188f4da17ae03dd8">invalidate</a> ()=0</td></tr>
<tr class="memdesc:aa5f2d9a1fcd27838188f4da17ae03dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates the cache.  <a href="#aa5f2d9a1fcd27838188f4da17ae03dd8">More...</a><br/></td></tr>
<tr class="separator:aa5f2d9a1fcd27838188f4da17ae03dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f69209809698ad305b9ae29b5d2366"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#a31f69209809698ad305b9ae29b5d2366">getCacheVolume</a> (<a class="el" href="classPxGeometryHolder.html">PxGeometryHolder</a> &amp;resultVolume, <a class="el" href="classPxTransform.html">PxTransform</a> &amp;resultPose)=0</td></tr>
<tr class="memdesc:a31f69209809698ad305b9ae29b5d2366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the last cached volume geometry.  <a href="#a31f69209809698ad305b9ae29b5d2366">More...</a><br/></td></tr>
<tr class="separator:a31f69209809698ad305b9ae29b5d2366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8687904f29300ec7a27222f8db50bf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gad30c834d58a6d6b96437f322fb402dad">PxI32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#acd8687904f29300ec7a27222f8db50bf">getNbCachedShapes</a> ()=0</td></tr>
<tr class="memdesc:acd8687904f29300ec7a27222f8db50bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of cached shapes.  <a href="#acd8687904f29300ec7a27222f8db50bf">More...</a><br/></td></tr>
<tr class="separator:acd8687904f29300ec7a27222f8db50bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf192b373fadb356a2c016717852c4d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#a5cf192b373fadb356a2c016717852c4d">release</a> ()=0</td></tr>
<tr class="memdesc:a5cf192b373fadb356a2c016717852c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the cache object and its resources.  <a href="#a5cf192b373fadb356a2c016717852c4d">More...</a><br/></td></tr>
<tr class="separator:a5cf192b373fadb356a2c016717852c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae589287aa090d15e8bd13efd7a80285b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#ae589287aa090d15e8bd13efd7a80285b">forEach</a> (<a class="el" href="structPxVolumeCache_1_1Iterator.html">Iterator</a> &amp;iter)=0</td></tr>
<tr class="memdesc:ae589287aa090d15e8bd13efd7a80285b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the scene shapes overlapping with the cache volume.  <a href="#ae589287aa090d15e8bd13efd7a80285b">More...</a><br/></td></tr>
<tr class="separator:ae589287aa090d15e8bd13efd7a80285b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c239abc1d93b2dea0cec7ae68d93319"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#a7c239abc1d93b2dea0cec7ae68d93319">setMaxNbStaticShapes</a> (<a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> maxCount)=0</td></tr>
<tr class="memdesc:a7c239abc1d93b2dea0cec7ae68d93319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the limit on the maximum number of static shapes allowed to be stored in the cache.  <a href="#a7c239abc1d93b2dea0cec7ae68d93319">More...</a><br/></td></tr>
<tr class="separator:a7c239abc1d93b2dea0cec7ae68d93319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30048238aa971768c4bf24c56d186d7c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#a30048238aa971768c4bf24c56d186d7c">setMaxNbDynamicShapes</a> (<a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> maxCount)=0</td></tr>
<tr class="memdesc:a30048238aa971768c4bf24c56d186d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the limit on the maximum number of dynamic shapes allowed to be stored in the cache.  <a href="#a30048238aa971768c4bf24c56d186d7c">More...</a><br/></td></tr>
<tr class="separator:a30048238aa971768c4bf24c56d186d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf05a6049d5f282069ab2d666fdc911"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#adaf05a6049d5f282069ab2d666fdc911">getMaxNbStaticShapes</a> ()=0</td></tr>
<tr class="memdesc:adaf05a6049d5f282069ab2d666fdc911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current maximum number of static cached shapes.  <a href="#adaf05a6049d5f282069ab2d666fdc911">More...</a><br/></td></tr>
<tr class="separator:adaf05a6049d5f282069ab2d666fdc911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721bd8c6edc998ad2fd2b113c4acb1a4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#a721bd8c6edc998ad2fd2b113c4acb1a4">getMaxNbDynamicShapes</a> ()=0</td></tr>
<tr class="memdesc:a721bd8c6edc998ad2fd2b113c4acb1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current maximum number of dynamic cached shapes.  <a href="#a721bd8c6edc998ad2fd2b113c4acb1a4">More...</a><br/></td></tr>
<tr class="separator:a721bd8c6edc998ad2fd2b113c4acb1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9feb4df002ccf6a69f1442689f18186"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#ae9feb4df002ccf6a69f1442689f18186">raycast</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;origin, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gad567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="group__scenequery.html#ga4dbe8142d799492bd8e7c5ec70bfac41">PxRaycastCallback</a> &amp;hitCall, PxHitFlags hitFlags=PxHitFlags(<a class="el" href="structPxHitFlag.html#a44c173f6ddf0522ffbd8fa3c585e6b64afbdec54374d753fed4682d855aac7270">PxHitFlag::eDEFAULT</a>), const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>(), <a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *filterCall=<a class="el" href="PxCudaMemoryManager_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) const =0</td></tr>
<tr class="memdesc:ae9feb4df002ccf6a69f1442689f18186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raycast against objects in the cache, returning results via PxRaycastCallback callback or PxRaycastBuffer object or a custom user callback implementation.  <a href="#ae9feb4df002ccf6a69f1442689f18186">More...</a><br/></td></tr>
<tr class="separator:ae9feb4df002ccf6a69f1442689f18186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847401da1a397a74ae193b5ff4408219"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#a847401da1a397a74ae193b5ff4408219">sweep</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;<a class="el" href="PxGeometryHelpers_8h.html#aa55209c75b105f03f459417b08801e69">geometry</a>, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gad567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="group__scenequery.html#ga6f93f556cef747d50f643499928dd865">PxSweepCallback</a> &amp;hitCall, PxHitFlags hitFlags=PxHitFlags(<a class="el" href="structPxHitFlag.html#a44c173f6ddf0522ffbd8fa3c585e6b64a21e4769575db55be01d8f91e06c59b1a">PxHitFlag::ePOSITION</a>|<a class="el" href="structPxHitFlag.html#a44c173f6ddf0522ffbd8fa3c585e6b64a5972f664c2fbe85c992fb9aaba46a5cf">PxHitFlag::eNORMAL</a>|<a class="el" href="structPxHitFlag.html#a44c173f6ddf0522ffbd8fa3c585e6b64a8bcc72eb9965eae03f53182e7e4b79ae">PxHitFlag::eDISTANCE</a>), const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>(), <a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *filterCall=<a class="el" href="PxCudaMemoryManager_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, const <a class="el" href="group__foundation.html#gad567a025d5e084c3b953c7ad755fc2b6">PxReal</a> inflation=0.f) const =0</td></tr>
<tr class="memdesc:a847401da1a397a74ae193b5ff4408219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sweep against objects in the cache, returning results via PxRaycastCallback callback or PxRaycastBuffer object or a custom user callback implementation.  <a href="#a847401da1a397a74ae193b5ff4408219">More...</a><br/></td></tr>
<tr class="separator:a847401da1a397a74ae193b5ff4408219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad339ef9e688aed817333ef1ac78d868c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#ad339ef9e688aed817333ef1ac78d868c">overlap</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;<a class="el" href="PxGeometryHelpers_8h.html#aa55209c75b105f03f459417b08801e69">geometry</a>, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, <a class="el" href="group__scenequery.html#ga9baa3a8cad31bbb8ef666fe01b3afeb7">PxOverlapCallback</a> &amp;hitCall, const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>(), <a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *filterCall=<a class="el" href="PxCudaMemoryManager_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) const =0</td></tr>
<tr class="memdesc:ad339ef9e688aed817333ef1ac78d868c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test overlap between a geometry and objects in the cache.  <a href="#ad339ef9e688aed817333ef1ac78d868c">More...</a><br/></td></tr>
<tr class="separator:ad339ef9e688aed817333ef1ac78d868c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1fad2b6c49845c49d143151678e01616"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#a1fad2b6c49845c49d143151678e01616">~PxVolumeCache</a> ()</td></tr>
<tr class="separator:a1fad2b6c49845c49d143151678e01616"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Volumetric cache for local collision geometry. </p>
<p>Provides a mechanism for caching objects within a specified volume and performing raycast, sweep, overlap and forEach queries on the cached objects.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classPxScene.html#a62abe3371a20c93c02e8f43deadc64eb" title="Creates a volume cache. See the Guide, &quot;Scene Queries&quot; section, &quot;Volume Caching&quot; subsection for more ...">PxScene.createVolumeCache()</a> </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a43e58f6fea62f6ec81827e2f251912f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classPxVolumeCache.html#a43e58f6fea62f6ec81827e2f251912f5">PxVolumeCache::FillStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>describes <a class="el" href="classPxVolumeCache.html#a046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> return status. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classPxVolumeCache.html#a046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">PxVolumeCache.fill()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a43e58f6fea62f6ec81827e2f251912f5a05556701b332b57b8899a95c431d8b56"></a>FILL_OK</em>&nbsp;</td><td class="fielddoc">
<p>Cache <a class="el" href="classPxVolumeCache.html#a046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> operation was successful, the cache is valid and had enough capacity to store all the objects within the specified cacheVolume. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a43e58f6fea62f6ec81827e2f251912f5a4a3175a948c5e06d6a2c2f44495a6f95"></a>FILL_OVER_MAX_COUNT</em>&nbsp;</td><td class="fielddoc">
<p>Over specified cache capacity. </p>
<p>Cache <a class="el" href="classPxVolumeCache.html#a046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> was over max count specified in <a class="el" href="classPxScene.html#a62abe3371a20c93c02e8f43deadc64eb" title="Creates a volume cache. See the Guide, &quot;Scene Queries&quot; section, &quot;Volume Caching&quot; subsection for more ...">PxScene.createVolumeCache()</a> or <a class="el" href="classPxVolumeCache.html#a7c239abc1d93b2dea0cec7ae68d93319" title="Sets the limit on the maximum number of static shapes allowed to be stored in the cache...">setMaxNbStaticShapes()</a> and <a class="el" href="classPxVolumeCache.html#a30048238aa971768c4bf24c56d186d7c" title="Sets the limit on the maximum number of dynamic shapes allowed to be stored in the cache...">setMaxNbDynamicShapes()</a>. If this value is returned the cache will be in invalid state (no caching), but all the queries will still return correct results within the specified cache volume.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classPxScene.html#a62abe3371a20c93c02e8f43deadc64eb" title="Creates a volume cache. See the Guide, &quot;Scene Queries&quot; section, &quot;Volume Caching&quot; subsection for more ...">PxScene.createVolumeCache()</a> <a class="el" href="classPxVolumeCache.html#a7c239abc1d93b2dea0cec7ae68d93319" title="Sets the limit on the maximum number of static shapes allowed to be stored in the cache...">setMaxNbStaticShapes()</a> <a class="el" href="classPxVolumeCache.html#a30048238aa971768c4bf24c56d186d7c" title="Sets the limit on the maximum number of dynamic shapes allowed to be stored in the cache...">setMaxNbDynamicShapes()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a43e58f6fea62f6ec81827e2f251912f5a36f4ffaf326d5f4fc310fd0a8676e6f3"></a>FILL_UNSUPPORTED_GEOMETRY_TYPE</em>&nbsp;</td><td class="fielddoc">
<p>Unsupported geometry type. </p>
<p>The geometry type of cacheVolume parameter provided to <a class="el" href="classPxVolumeCache.html#a046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> is not supported. Supported types are sphere, box, capsule. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a43e58f6fea62f6ec81827e2f251912f5acbdc57f8bf59feec81f31871969c8c1e"></a>FILL_OUT_OF_MEMORY</em>&nbsp;</td><td class="fielddoc">
<p>Cache <a class="el" href="classPxVolumeCache.html#a046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> ran out of temporary memory for intermediate results, try reducing the cache size. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1fad2b6c49845c49d143151678e01616"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxVolumeCache::~PxVolumeCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a046b0c5bed6e6f0dad3696cc9b69ed17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxVolumeCache.html#a43e58f6fea62f6ec81827e2f251912f5">FillStatus</a> PxVolumeCache::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>cacheVolume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>pose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the cache with objects intersecting the specified cacheVolume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cacheVolume</td><td>Geometry of the cached volume (supported types are: sphere, box, capsule). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>Pose of the cache volume.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classPxVolumeCache.html#a43e58f6fea62f6ec81827e2f251912f5" title="describes fill() return status.">FillStatus</a> enum.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classPxVolumeCache.html#a43e58f6fea62f6ec81827e2f251912f5" title="describes fill() return status.">PxVolumeCache.FillStatus</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae589287aa090d15e8bd13efd7a80285b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxVolumeCache::forEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxVolumeCache_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterates over the scene shapes overlapping with the cache volume. </p>
<p>forEach will invoke <a class="el" href="structPxVolumeCache_1_1Iterator.html#a32f1fd4467e896a9f544a01aae3e8941" title="Reports cache contents to the user.">PxVolumeCache::Iterator::processShapes</a> virtual function, returning all overlapping shapes (possibly by issuing multiple callbacks) to the user. The size of reported blocks can change depending on internal SDK implementation. Any pointers to the contents of the buffer are only valid within the scope of a single processShapes() callback function. If forEach is invoked on an invalid cache (empty or out of date), this call will attempt to refill the cache within specified capacity. If the cache is over capacity, an attempt will be made to allocate a temp internal buffer, retrieve the results directly from the scene and return to the user via provided iterator. Results from forEach will be current for the last set cacheVolume provided in <a class="el" href="classPxVolumeCache.html#a046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> even if the cache is invalid and refill fails. If the number of overlapping shapes is so high that the internal temporary allocation fails this call will produce an error and return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td><a class="el" href="structPxVolumeCache_1_1Iterator.html" title="A callback wrapper class for use with PxVolumeCache::forEach function.">Iterator</a> callback. <a class="el" href="classPxVolumeCache.html#ae589287aa090d15e8bd13efd7a80285b" title="Iterates over the scene shapes overlapping with the cache volume.">forEach()</a> will invokes iter.shapes() function (possibly multiple times) to return blocks of actor+shape pairs overlapped with cacheVolume to the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31f69209809698ad305b9ae29b5d2366"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxVolumeCache::getCacheVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxGeometryHolder.html">PxGeometryHolder</a> &amp;&#160;</td>
          <td class="paramname"><em>resultVolume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxTransform.html">PxTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>resultPose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the last cached volume geometry. </p>
<dl class="section return"><dt>Returns</dt><dd>False if the cache wasn't previously filled. True otherwise with cacheVolume from the last <a class="el" href="classPxVolumeCache.html#a046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> call returned in resultVolume and corresponding transform in resultPose.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classPxVolumeCache.html#a046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a721bd8c6edc998ad2fd2b113c4acb1a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxVolumeCache::getMaxNbDynamicShapes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current maximum number of dynamic cached shapes. </p>
<dl class="section return"><dt>Returns</dt><dd>The max number of cached dynamics. </dd></dl>

</div>
</div>
<a class="anchor" id="adaf05a6049d5f282069ab2d666fdc911"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxVolumeCache::getMaxNbStaticShapes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current maximum number of static cached shapes. </p>
<dl class="section return"><dt>Returns</dt><dd>The max number of cached statics. </dd></dl>

</div>
</div>
<a class="anchor" id="acd8687904f29300ec7a27222f8db50bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gad30c834d58a6d6b96437f322fb402dad">PxI32</a> PxVolumeCache::getNbCachedShapes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of cached shapes. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of shapes stored in the cache (statics+dynamics). Returns -1 if the cache is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5f2d9a1fcd27838188f4da17ae03dd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxVolumeCache::invalidate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidates the cache. </p>
<p>Marks the cache as invalid. Subsequent query will attempt to refill the cache from the scene. </p>

</div>
</div>
<a class="anchor" id="af151c4569e890ee2b36b1c9ad0da348f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxVolumeCache::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the cache is valid (not over specified max capacity, for both statics and dynamics) and up-to-date. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the cache is valid and up-to-date. Cache can become out-of-date if any statics or dynamics are moved or added or deleted from the scene.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classPxVolumeCache.html#a43e58f6fea62f6ec81827e2f251912f5" title="describes fill() return status.">PxVolumeCache.FillStatus</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad339ef9e688aed817333ef1ac78d868c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxVolumeCache::overlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__scenequery.html#ga9baa3a8cad31bbb8ef666fe01b3afeb7">PxOverlapCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>hitCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;&#160;</td>
          <td class="paramname"><em>filterData</em> = <code><a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *&#160;</td>
          <td class="paramname"><em>filterCall</em> = <code><a class="el" href="PxCudaMemoryManager_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test overlap between a geometry and objects in the cache. </p>
<dl class="section note"><dt>Note</dt><dd>Filtering: Overlap tests do not distinguish between touching and blocking hit types (see <a class="el" href="structPxQueryHitType.html" title="Classification of scene query hits (intersections).">PxQueryHitType</a>). Both get written to the hit buffer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">geometry</td><td>Geometry of object to check for overlap (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>Pose of the object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitCall</td><td>Overlap hit callback or hit buffer object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterData</td><td>Filtering data and simple logic. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterCall</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxQueryFlag.html" title="Filtering flags for scene queries.">PxQueryFlag</a> flags are set. If NULL, all hits are assumed to overlap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a blocking hit was found or any hit was found in case <a class="el" href="structPxQueryFlag.html#a2124ff0cff0a021e01e6880a1bba431fa2837a6ac649b29ee72af661b65f4d8ab">PxQueryFlag::eANY_HIT</a> flag was specified.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__scenequery.html#ga9baa3a8cad31bbb8ef666fe01b3afeb7" title="Overlap query callback.">PxOverlapCallback</a> <a class="el" href="group__scenequery.html#ga54a708942a891f3321c2427d5c160750" title="Overlap query buffer.">PxOverlapBuffer</a> <a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="classPxQueryFilterCallback.html" title="Scene query filtering callbacks.">PxQueryFilterCallback</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae9feb4df002ccf6a69f1442689f18186"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxVolumeCache::raycast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gad567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__scenequery.html#ga4dbe8142d799492bd8e7c5ec70bfac41">PxRaycastCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>hitCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxHitFlags&#160;</td>
          <td class="paramname"><em>hitFlags</em> = <code>PxHitFlags(<a class="el" href="structPxHitFlag.html#a44c173f6ddf0522ffbd8fa3c585e6b64afbdec54374d753fed4682d855aac7270">PxHitFlag::eDEFAULT</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;&#160;</td>
          <td class="paramname"><em>filterData</em> = <code><a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *&#160;</td>
          <td class="paramname"><em>filterCall</em> = <code><a class="el" href="PxCudaMemoryManager_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raycast against objects in the cache, returning results via PxRaycastCallback callback or PxRaycastBuffer object or a custom user callback implementation. </p>
<p>Returns whether any rigid actor is hit along the ray.</p>
<dl class="section note"><dt>Note</dt><dd>Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in user guide article SceneQuery. User can ignore such objects by employing one of the provided filter mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>Origin of the ray. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Normalized direction of the ray. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>Length of the ray. Needs to be larger than 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitCall</td><td>Raycast hit callback or hit buffer object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hitFlags</td><td>Specifies which properties per hit should be computed and returned via the hit callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterData</td><td>Filtering data and simple logic. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterCall</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxQueryFlag.html" title="Filtering flags for scene queries.">PxQueryFlag</a> flags are set. If NULL, all hits are assumed to be blocking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a blocking hit was found or any hit was found in case <a class="el" href="structPxQueryFlag.html#a2124ff0cff0a021e01e6880a1bba431fa2837a6ac649b29ee72af661b65f4d8ab">PxQueryFlag::eANY_HIT</a> flag was used.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__scenequery.html#ga4dbe8142d799492bd8e7c5ec70bfac41" title="Raycast query callback.">PxRaycastCallback</a> <a class="el" href="group__scenequery.html#gab21a68ce9e5a18aa742111920b75a84c" title="Raycast query buffer.">PxRaycastBuffer</a> <a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="classPxQueryFilterCallback.html" title="Scene query filtering callbacks.">PxQueryFilterCallback</a> <a class="el" href="structPxQueryCache.html" title="single hit cache for scene queries.">PxQueryCache</a> <a class="el" href="structPxRaycastHit.html" title="Stores results of raycast queries.">PxRaycastHit</a> <a class="el" href="structPxQueryFlag.html" title="Filtering flags for scene queries.">PxQueryFlag</a> <a class="el" href="structPxQueryFlag.html#a2124ff0cff0a021e01e6880a1bba431fa2837a6ac649b29ee72af661b65f4d8ab">PxQueryFlag::eANY_HIT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5cf192b373fadb356a2c016717852c4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxVolumeCache::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the cache object and its resources. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classPxScene.html#a62abe3371a20c93c02e8f43deadc64eb" title="Creates a volume cache. See the Guide, &quot;Scene Queries&quot; section, &quot;Volume Caching&quot; subsection for more ...">PxScene.createVolumeCache</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a30048238aa971768c4bf24c56d186d7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxVolumeCache::setMaxNbDynamicShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&#160;</td>
          <td class="paramname"><em>maxCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the limit on the maximum number of dynamic shapes allowed to be stored in the cache. </p>
<p>If the number of cached objects goes over this limit, the query functions (forEach/raycast/sweep/overlap) will fall back to scene queries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxCount</td><td>Maximum number of dynamic shapes cached. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c239abc1d93b2dea0cec7ae68d93319"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxVolumeCache::setMaxNbStaticShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&#160;</td>
          <td class="paramname"><em>maxCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the limit on the maximum number of static shapes allowed to be stored in the cache. </p>
<p>If the number of cached objects goes over this limit, the query functions (forEach/raycast/sweep/overlap) will fall back to scene queries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxCount</td><td>Maximum number of static shapes cached. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a847401da1a397a74ae193b5ff4408219"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxVolumeCache::sweep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gad567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__scenequery.html#ga6f93f556cef747d50f643499928dd865">PxSweepCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>hitCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxHitFlags&#160;</td>
          <td class="paramname"><em>hitFlags</em> = <code>PxHitFlags(<a class="el" href="structPxHitFlag.html#a44c173f6ddf0522ffbd8fa3c585e6b64a21e4769575db55be01d8f91e06c59b1a">PxHitFlag::ePOSITION</a>|<a class="el" href="structPxHitFlag.html#a44c173f6ddf0522ffbd8fa3c585e6b64a5972f664c2fbe85c992fb9aaba46a5cf">PxHitFlag::eNORMAL</a>|<a class="el" href="structPxHitFlag.html#a44c173f6ddf0522ffbd8fa3c585e6b64a8bcc72eb9965eae03f53182e7e4b79ae">PxHitFlag::eDISTANCE</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;&#160;</td>
          <td class="paramname"><em>filterData</em> = <code><a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *&#160;</td>
          <td class="paramname"><em>filterCall</em> = <code><a class="el" href="PxCudaMemoryManager_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gad567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&#160;</td>
          <td class="paramname"><em>inflation</em> = <code>0.f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sweep against objects in the cache, returning results via PxRaycastCallback callback or PxRaycastBuffer object or a custom user callback implementation. </p>
<p>Returns whether any rigid actor is hit along the sweep path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">geometry</td><td>Geometry of object to sweep (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>Pose of the sweep object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>Sweep distance. Needs to be larger than 0. Will be clamped to PX_MAX_SWEEP_DISTANCE. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitCall</td><td>Sweep hit callback or hit buffer object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hitFlags</td><td>Specifies which properties per hit should be computed and returned via the hit callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterData</td><td>Filtering data and simple logic. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterCall</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxQueryFlag.html" title="Filtering flags for scene queries.">PxQueryFlag</a> flags are set. If NULL, all hits are assumed to be blocking. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inflation</td><td>This parameter creates a skin around the swept geometry which increases its extents for sweeping. The sweep will register a hit as soon as the skin touches a shape, and will return the corresponding distance and normal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a blocking hit was found or any hit was found in case <a class="el" href="structPxQueryFlag.html#a2124ff0cff0a021e01e6880a1bba431fa2837a6ac649b29ee72af661b65f4d8ab">PxQueryFlag::eANY_HIT</a> flag was specified.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__scenequery.html#ga6f93f556cef747d50f643499928dd865" title="Sweep query callback.">PxSweepCallback</a> <a class="el" href="group__scenequery.html#gaecfed2b83a930b922b3d95e22ff30665" title="Sweep query buffer.">PxSweepBuffer</a> <a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="classPxQueryFilterCallback.html" title="Scene query filtering callbacks.">PxQueryFilterCallback</a> <a class="el" href="structPxSweepHit.html" title="Stores results of sweep queries.">PxSweepHit</a> <a class="el" href="structPxQueryCache.html" title="single hit cache for scene queries.">PxQueryCache</a> PxHitFlags </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxVolumeCache_8h_source.html">PxVolumeCache.h</a></li>
</ul>
</div><!-- contents -->

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2015 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
