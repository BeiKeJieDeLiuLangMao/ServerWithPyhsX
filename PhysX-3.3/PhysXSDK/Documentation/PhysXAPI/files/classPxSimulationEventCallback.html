<html>
	<head>
		<title>PxSimulationEventCallback Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>
	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.8.3.1 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classPxSimulationEventCallback-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PxSimulationEventCallback Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__physics.html">Physics</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An interface class that the user can implement in order to receive simulation events.  
 <a href="classPxSimulationEventCallback.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PxSimulationEventCallback_8h_source.html">PxSimulationEventCallback.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a67c6553ee9090481ece8b041502eb948"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#a67c6553ee9090481ece8b041502eb948">onConstraintBreak</a> (<a class="el" href="structPxConstraintInfo.html">PxConstraintInfo</a> *constraints, <a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> count)=0</td></tr>
<tr class="memdesc:a67c6553ee9090481ece8b041502eb948"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called when a breakable constraint breaks.  <a href="#a67c6553ee9090481ece8b041502eb948">More...</a><br/></td></tr>
<tr class="separator:a67c6553ee9090481ece8b041502eb948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e6f45b530cfb8536bc2ff14f38e2fe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#a37e6f45b530cfb8536bc2ff14f38e2fe">onWake</a> (<a class="el" href="classPxActor.html">PxActor</a> **actors, <a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> count)=0</td></tr>
<tr class="memdesc:a37e6f45b530cfb8536bc2ff14f38e2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called with the actors which have just been woken up.  <a href="#a37e6f45b530cfb8536bc2ff14f38e2fe">More...</a><br/></td></tr>
<tr class="separator:a37e6f45b530cfb8536bc2ff14f38e2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614256e6c2570e24cf45e974d6087d38"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#a614256e6c2570e24cf45e974d6087d38">onSleep</a> (<a class="el" href="classPxActor.html">PxActor</a> **actors, <a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> count)=0</td></tr>
<tr class="memdesc:a614256e6c2570e24cf45e974d6087d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called with the actors which have just been put to sleep.  <a href="#a614256e6c2570e24cf45e974d6087d38">More...</a><br/></td></tr>
<tr class="separator:a614256e6c2570e24cf45e974d6087d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc1da28643ccf9f77c8432b5eb2fd32"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#a4dc1da28643ccf9f77c8432b5eb2fd32">onContact</a> (const <a class="el" href="structPxContactPairHeader.html">PxContactPairHeader</a> &amp;pairHeader, const <a class="el" href="structPxContactPair.html">PxContactPair</a> *pairs, <a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> nbPairs)=0</td></tr>
<tr class="memdesc:a4dc1da28643ccf9f77c8432b5eb2fd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called when certain contact events occur.  <a href="#a4dc1da28643ccf9f77c8432b5eb2fd32">More...</a><br/></td></tr>
<tr class="separator:a4dc1da28643ccf9f77c8432b5eb2fd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768b2ee9fe28736da3fcdc6a0eae9733"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#a768b2ee9fe28736da3fcdc6a0eae9733">onTrigger</a> (<a class="el" href="structPxTriggerPair.html">PxTriggerPair</a> *pairs, <a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> count)=0</td></tr>
<tr class="memdesc:a768b2ee9fe28736da3fcdc6a0eae9733"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is called with the current trigger pair events.  <a href="#a768b2ee9fe28736da3fcdc6a0eae9733">More...</a><br/></td></tr>
<tr class="separator:a768b2ee9fe28736da3fcdc6a0eae9733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97f7e6f3dbccaeef1e3fa1578862e88"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#ae97f7e6f3dbccaeef1e3fa1578862e88">~PxSimulationEventCallback</a> ()</td></tr>
<tr class="separator:ae97f7e6f3dbccaeef1e3fa1578862e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An interface class that the user can implement in order to receive simulation events. </p>
<p>The events get sent during the call to either <a class="el" href="classPxScene.html#ab34e054ccf428a1cdbd81bf1e2b87fae">PxScene::fetchResults()</a> or <a class="el" href="classPxScene.html#ab557fc677e9549c71d36979dfd3ec8c5" title="Clear internal buffers and free memory.">PxScene::flushSimulation()</a> with sendPendingReports=true.</p>
<dl class="section note"><dt>Note</dt><dd>SDK state should not be modified from within the callbacks. In particular objects should not be created or destroyed. If state modification is needed then the changes should be stored to a buffer and performed after the simulation step.</dd></dl>
<p><b>Threading:</b> It is not necessary to make this class thread safe as it will only be called in the context of the user thread.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classPxScene.html#a06eb4fdf45e324c6110fd9fd5f28ca03" title="Sets a user notify object which receives special simulation events when they occur.">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxScene.html#a17361190e6640cbd1a5a9bc82796d4fc" title="Retrieves the simulationEventCallback pointer set with setSimulationEventCallback().">PxScene.getSimulationEventCallback()</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae97f7e6f3dbccaeef1e3fa1578862e88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxSimulationEventCallback::~PxSimulationEventCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a67c6553ee9090481ece8b041502eb948"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onConstraintBreak </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxConstraintInfo.html">PxConstraintInfo</a> *&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called when a breakable constraint breaks. </p>
<dl class="section note"><dt>Note</dt><dd>The user should not release the constraint shader inside this call!</dd>
<dd>
No event will get reported if the constraint breaks but gets deleted while the time step is still being simulated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">constraints</td><td>- The constraints which have been broken. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>- The number of constraints</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classPxConstraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> PxConstraintDesc.linearBreakForce PxConstraintDesc.angularBreakForce </dd></dl>

</div>
</div>
<a class="anchor" id="a4dc1da28643ccf9f77c8432b5eb2fd32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onContact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPxContactPairHeader.html">PxContactPairHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>pairHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxContactPair.html">PxContactPair</a> *&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&#160;</td>
          <td class="paramname"><em>nbPairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called when certain contact events occur. </p>
<p>The method will be called for a pair of actors if one of the colliding shape pairs requested contact notification. You request which events are reported using the filter shader/callback mechanism (see <a class="el" href="group__physics.html#ga9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a>, <a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a>, <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a>).</p>
<p>Do not keep references to the passed objects, as they will be invalid after this function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pairHeader</td><td>Information on the two actors whose shapes triggered a contact report. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pairs</td><td>The contact pairs of two actors for which contact reports have been requested. See <a class="el" href="structPxContactPair.html" title="Contact report pair information.">PxContactPair</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbPairs</td><td>The number of provided contact pairs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classPxScene.html#a06eb4fdf45e324c6110fd9fd5f28ca03" title="Sets a user notify object which receives special simulation events when they occur.">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxSceneDesc.html#a71a00536a56d40fe031de2ced1834941" title="Possible notification callback.">PxSceneDesc.simulationEventCallback</a> <a class="el" href="structPxContactPair.html" title="Contact report pair information.">PxContactPair</a> <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a> <a class="el" href="group__physics.html#ga9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> <a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a614256e6c2570e24cf45e974d6087d38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onSleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> **&#160;</td>
          <td class="paramname"><em>actors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called with the actors which have just been put to sleep. </p>
<dl class="section note"><dt>Note</dt><dd>Only supported by rigid bodies yet. </dd>
<dd>
Only called on actors for which the <a class="el" href="structPxActorFlag.html" title="Flags which control the behavior of an actor.">PxActorFlag</a> eSEND_SLEEP_NOTIFIES has been set. </dd>
<dd>
Only the latest sleep state transition happening between fetchResults() of the previous frame and fetchResults() of the current frame will get reported. For example, let us assume actor A is asleep, then A-&gt;wakeUp() gets called, then later A-&gt;putToSleep() gets called. At the next simulate/fetchResults() step only an <a class="el" href="classPxSimulationEventCallback.html#a614256e6c2570e24cf45e974d6087d38" title="This is called with the actors which have just been put to sleep.">onSleep()</a> event will get triggered because that was the last transition (assuming the simulation does not wake the actor up). </dd>
<dd>
If an actor gets newly added to a scene with properties such that it is asleep and the sleep state does not get changed by the user or simulation, then an <a class="el" href="classPxSimulationEventCallback.html#a614256e6c2570e24cf45e974d6087d38" title="This is called with the actors which have just been put to sleep.">onSleep()</a> event will get sent at the next simulate/fetchResults() step.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actors</td><td>- The actors which have just been put to sleep. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>- The number of actors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classPxScene.html#a06eb4fdf45e324c6110fd9fd5f28ca03" title="Sets a user notify object which receives special simulation events when they occur.">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxSceneDesc.html#a71a00536a56d40fe031de2ced1834941" title="Possible notification callback.">PxSceneDesc.simulationEventCallback</a> <a class="el" href="structPxActorFlag.html" title="Flags which control the behavior of an actor.">PxActorFlag</a> <a class="el" href="classPxActor.html#ae24ff3f3ed0cb2a138b382fd0720b94f" title="Raises or clears a particular actor flag.">PxActor.setActorFlag()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a768b2ee9fe28736da3fcdc6a0eae9733"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxTriggerPair.html">PxTriggerPair</a> *&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called with the current trigger pair events. </p>
<p>Shapes which have been marked as triggers using <a class="el" href="structPxShapeFlag.html#a6edb481aaa3a998c5d6dd3fc4ad87f1aaef2b90024dc86be72b68bbaf94a5821d" title="The shape is a trigger which can send reports whenever other shapes enter/leave its volume...">PxShapeFlag::eTRIGGER_SHAPE</a> will send events according to the pair flag specification in the filter shader (see <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a>, <a class="el" href="group__physics.html#ga9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pairs</td><td>- The trigger pairs which caused events. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>- The number of trigger pairs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classPxScene.html#a06eb4fdf45e324c6110fd9fd5f28ca03" title="Sets a user notify object which receives special simulation events when they occur.">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxSceneDesc.html#a71a00536a56d40fe031de2ced1834941" title="Possible notification callback.">PxSceneDesc.simulationEventCallback</a> <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a> <a class="el" href="group__physics.html#ga9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> <a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a> <a class="el" href="classPxShape.html#a3c879df184ef40514589c5aa3d1f2a33" title="Sets shape flags.">PxShape.setFlag()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a37e6f45b530cfb8536bc2ff14f38e2fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onWake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> **&#160;</td>
          <td class="paramname"><em>actors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is called with the actors which have just been woken up. </p>
<dl class="section note"><dt>Note</dt><dd>Only supported by rigid bodies yet. </dd>
<dd>
Only called on actors for which the <a class="el" href="structPxActorFlag.html" title="Flags which control the behavior of an actor.">PxActorFlag</a> eSEND_SLEEP_NOTIFIES has been set. </dd>
<dd>
Only the latest sleep state transition happening between fetchResults() of the previous frame and fetchResults() of the current frame will get reported. For example, let us assume actor A is awake, then A-&gt;putToSleep() gets called, then later A-&gt;wakeUp() gets called. At the next simulate/fetchResults() step only an <a class="el" href="classPxSimulationEventCallback.html#a37e6f45b530cfb8536bc2ff14f38e2fe" title="This is called with the actors which have just been woken up.">onWake()</a> event will get triggered because that was the last transition. </dd>
<dd>
If an actor gets newly added to a scene with properties such that it is awake and the sleep state does not get changed by the user or simulation, then an <a class="el" href="classPxSimulationEventCallback.html#a37e6f45b530cfb8536bc2ff14f38e2fe" title="This is called with the actors which have just been woken up.">onWake()</a> event will get sent at the next simulate/fetchResults() step.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actors</td><td>- The actors which just woke up. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>- The number of actors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classPxScene.html#a06eb4fdf45e324c6110fd9fd5f28ca03" title="Sets a user notify object which receives special simulation events when they occur.">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxSceneDesc.html#a71a00536a56d40fe031de2ced1834941" title="Possible notification callback.">PxSceneDesc.simulationEventCallback</a> <a class="el" href="structPxActorFlag.html" title="Flags which control the behavior of an actor.">PxActorFlag</a> <a class="el" href="classPxActor.html#ae24ff3f3ed0cb2a138b382fd0720b94f" title="Raises or clears a particular actor flag.">PxActor.setActorFlag()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxSimulationEventCallback_8h_source.html">PxSimulationEventCallback.h</a></li>
</ul>
</div><!-- contents -->

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2015 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
