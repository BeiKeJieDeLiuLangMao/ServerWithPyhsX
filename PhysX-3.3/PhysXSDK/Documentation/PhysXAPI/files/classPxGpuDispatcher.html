<html>
	<head>
		<title>PxGpuDispatcher Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>
	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.8.3.1 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classPxGpuDispatcher-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PxGpuDispatcher Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A GpuTask dispatcher.  
 <a href="classPxGpuDispatcher.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PxGpuDispatcher_8h_source.html">PxGpuDispatcher.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0450fd4af23a1d9f2b4d936dd9a2132e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#a0450fd4af23a1d9f2b4d936dd9a2132e">startSimulation</a> ()=0</td></tr>
<tr class="memdesc:a0450fd4af23a1d9f2b4d936dd9a2132e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the start of a simulation step.  <a href="#a0450fd4af23a1d9f2b4d936dd9a2132e">More...</a><br/></td></tr>
<tr class="separator:a0450fd4af23a1d9f2b4d936dd9a2132e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa5f619a4c331e8de04bade660013cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#abfa5f619a4c331e8de04bade660013cb">startGroup</a> ()=0</td></tr>
<tr class="memdesc:abfa5f619a4c331e8de04bade660013cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the start of a GpuTask batch submission.  <a href="#abfa5f619a4c331e8de04bade660013cb">More...</a><br/></td></tr>
<tr class="separator:abfa5f619a4c331e8de04bade660013cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f2a53800fa9f6c9348a009fd2ace4b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#a86f2a53800fa9f6c9348a009fd2ace4b">submitTask</a> (<a class="el" href="classPxTask.html">PxTask</a> &amp;task)=0</td></tr>
<tr class="memdesc:a86f2a53800fa9f6c9348a009fd2ace4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a GpuTask for execution.  <a href="#a86f2a53800fa9f6c9348a009fd2ace4b">More...</a><br/></td></tr>
<tr class="separator:a86f2a53800fa9f6c9348a009fd2ace4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc22970568b130346ffc5449127889be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#abc22970568b130346ffc5449127889be">finishGroup</a> ()=0</td></tr>
<tr class="memdesc:abc22970568b130346ffc5449127889be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the end of a GpuTask batch submission.  <a href="#abc22970568b130346ffc5449127889be">More...</a><br/></td></tr>
<tr class="separator:abc22970568b130346ffc5449127889be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba802ba004b39f0a94cda874ff1addd5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#aba802ba004b39f0a94cda874ff1addd5">addCompletionPrereq</a> (<a class="el" href="classPxBaseTask.html">PxBaseTask</a> &amp;task)=0</td></tr>
<tr class="memdesc:aba802ba004b39f0a94cda874ff1addd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a CUDA completion prerequisite dependency to a task.  <a href="#aba802ba004b39f0a94cda874ff1addd5">More...</a><br/></td></tr>
<tr class="separator:aba802ba004b39f0a94cda874ff1addd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef4c36fdffc9615f61aadde7a7395bd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxCudaContextManager.html">PxCudaContextManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#a5ef4c36fdffc9615f61aadde7a7395bd">getCudaContextManager</a> ()=0</td></tr>
<tr class="memdesc:a5ef4c36fdffc9615f61aadde7a7395bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <a class="el" href="classPxCudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">PxCudaContextManager</a> associated with this <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a>.  <a href="#a5ef4c36fdffc9615f61aadde7a7395bd">More...</a><br/></td></tr>
<tr class="separator:a5ef4c36fdffc9615f61aadde7a7395bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8e3086259e2b4ad5fc3dcfd8f42083"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#a7e8e3086259e2b4ad5fc3dcfd8f42083">stopSimulation</a> ()=0</td></tr>
<tr class="memdesc:a7e8e3086259e2b4ad5fc3dcfd8f42083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the end of a simulation frame.  <a href="#a7e8e3086259e2b4ad5fc3dcfd8f42083">More...</a><br/></td></tr>
<tr class="separator:a7e8e3086259e2b4ad5fc3dcfd8f42083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab184a1d948fb4ce311f2881db995633"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#aab184a1d948fb4ce311f2881db995633">failureDetected</a> () const =0</td></tr>
<tr class="memdesc:aab184a1d948fb4ce311f2881db995633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a CUDA call has returned a non-recoverable error.  <a href="#aab184a1d948fb4ce311f2881db995633">More...</a><br/></td></tr>
<tr class="separator:aab184a1d948fb4ce311f2881db995633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb1b85b09139ca092d803b6d89d9e0c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#a0bb1b85b09139ca092d803b6d89d9e0c">forceFailureMode</a> ()=0</td></tr>
<tr class="memdesc:a0bb1b85b09139ca092d803b6d89d9e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> into failure mode.  <a href="#a0bb1b85b09139ca092d803b6d89d9e0c">More...</a><br/></td></tr>
<tr class="separator:a0bb1b85b09139ca092d803b6d89d9e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917458ce763a40c77e25cba385f5d987"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#a917458ce763a40c77e25cba385f5d987">getCurrentProfileBuffer</a> () const =0</td></tr>
<tr class="memdesc:a917458ce763a40c77e25cba385f5d987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the current in-use profile buffer.  <a href="#a917458ce763a40c77e25cba385f5d987">More...</a><br/></td></tr>
<tr class="separator:a917458ce763a40c77e25cba385f5d987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ba1f15f2abc7c3575944c8c6eee162"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#ga1062e3989bd862873cdf0d4f7286d11d">PxU16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#a97ba1f15f2abc7c3575944c8c6eee162">registerKernelNames</a> (const char **, <a class="el" href="group__foundation.html#ga1062e3989bd862873cdf0d4f7286d11d">PxU16</a> count)=0</td></tr>
<tr class="memdesc:a97ba1f15f2abc7c3575944c8c6eee162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register kernel names with PlatformAnalyzer.  <a href="#a97ba1f15f2abc7c3575944c8c6eee162">More...</a><br/></td></tr>
<tr class="separator:a97ba1f15f2abc7c3575944c8c6eee162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0214929561a436c26d6ec6cbce9d3e1f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#a0214929561a436c26d6ec6cbce9d3e1f">launchCopyKernel</a> (<a class="el" href="structPxGpuCopyDesc.html">PxGpuCopyDesc</a> *desc, <a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> count, <a class="el" href="PxGpuDispatcher_8h.html#ab946c7f02e09efd788a204718015d88a">CUstream</a> stream)=0</td></tr>
<tr class="memdesc:a0214929561a436c26d6ec6cbce9d3e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch a copy kernel with arbitrary number of copy commands.  <a href="#a0214929561a436c26d6ec6cbce9d3e1f">More...</a><br/></td></tr>
<tr class="separator:a0214929561a436c26d6ec6cbce9d3e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc20169dcadacfc0a5849d7263f14de2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxBaseTask.html">PxBaseTask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#abc20169dcadacfc0a5849d7263f14de2">getPreLaunchTask</a> ()=0</td></tr>
<tr class="memdesc:abc20169dcadacfc0a5849d7263f14de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query pre launch task that runs before launching gpu kernels.  <a href="#abc20169dcadacfc0a5849d7263f14de2">More...</a><br/></td></tr>
<tr class="separator:abc20169dcadacfc0a5849d7263f14de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d438c6dacee88fcb9a250bc33abbe6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#aa5d438c6dacee88fcb9a250bc33abbe6">addPreLaunchDependent</a> (<a class="el" href="classPxBaseTask.html">PxBaseTask</a> &amp;dependent)=0</td></tr>
<tr class="memdesc:aa5d438c6dacee88fcb9a250bc33abbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a gpu launch task that gets executed after the pre launch task.  <a href="#aa5d438c6dacee88fcb9a250bc33abbe6">More...</a><br/></td></tr>
<tr class="separator:aa5d438c6dacee88fcb9a250bc33abbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9433c1132869548aba01f0fa2d2fb819"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxBaseTask.html">PxBaseTask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#a9433c1132869548aba01f0fa2d2fb819">getPostLaunchTask</a> ()=0</td></tr>
<tr class="memdesc:a9433c1132869548aba01f0fa2d2fb819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query post launch task that runs after the gpu is done.  <a href="#a9433c1132869548aba01f0fa2d2fb819">More...</a><br/></td></tr>
<tr class="separator:a9433c1132869548aba01f0fa2d2fb819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802630db052be20a94d069ad16a2e432"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#a802630db052be20a94d069ad16a2e432">addPostLaunchDependent</a> (<a class="el" href="classPxBaseTask.html">PxBaseTask</a> &amp;dependent)=0</td></tr>
<tr class="memdesc:a802630db052be20a94d069ad16a2e432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a task that gets executed after the post launch task.  <a href="#a802630db052be20a94d069ad16a2e432">More...</a><br/></td></tr>
<tr class="separator:a802630db052be20a94d069ad16a2e432"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5ffadf4e113dac47a8aa509a1d623d23"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGpuDispatcher.html#a5ffadf4e113dac47a8aa509a1d623d23">~PxGpuDispatcher</a> ()</td></tr>
<tr class="memdesc:a5ffadf4e113dac47a8aa509a1d623d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">protected destructor  <a href="#a5ffadf4e113dac47a8aa509a1d623d23">More...</a><br/></td></tr>
<tr class="separator:a5ffadf4e113dac47a8aa509a1d623d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A GpuTask dispatcher. </p>
<p>A <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> executes GpuTasks submitted by one or more TaskManagers (one or more scenes). It maintains a CPU worker thread which waits on GpuTask "groups" to be submitted. The submission API is explicitly sessioned so that GpuTasks are dispatched together as a group whenever possible to improve parallelism on the GPU.</p>
<p>A <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> cannot be allocated ad-hoc, they are created as a result of creating a <a class="el" href="classPxCudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">PxCudaContextManager</a>. Every <a class="el" href="classPxCudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">PxCudaContextManager</a> has a <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> instance that can be queried. In this way, each <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> is tied to exactly one CUDA context.</p>
<p>A scene will use CPU fallback Tasks for GpuTasks if the <a class="el" href="classPxTaskManager.html" title="The PxTaskManager interface.">PxTaskManager</a> provided to it does not have a <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a>. For this reason, the <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> must be assigned to the <a class="el" href="classPxTaskManager.html" title="The PxTaskManager interface.">PxTaskManager</a> before the <a class="el" href="classPxTaskManager.html" title="The PxTaskManager interface.">PxTaskManager</a> is given to a scene.</p>
<p>Multiple TaskManagers may safely share a single <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> instance, thus enabling scenes to share a CUDA context.</p>
<p>Only <a class="el" href="classPxGpuDispatcher.html#aab184a1d948fb4ce311f2881db995633" title="Returns true if a CUDA call has returned a non-recoverable error.">failureDetected()</a> is intended for use by the user. The rest of the <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> public methods are reserved for internal use by only both TaskManagers and GpuTasks. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5ffadf4e113dac47a8aa509a1d623d23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxGpuDispatcher::~PxGpuDispatcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>protected destructor </p>
<p>GpuDispatchers are allocated and freed by their <a class="el" href="classPxCudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">PxCudaContextManager</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aba802ba004b39f0a94cda874ff1addd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxGpuDispatcher::addCompletionPrereq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxBaseTask.html">PxBaseTask</a> &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a CUDA completion prerequisite dependency to a task. </p>
<p>A GpuTask calls this function to add a prerequisite dependency on another task (usually a CpuTask) preventing that task from starting until all of the CUDA kernels and copies already launched have been completed. The <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> will increment that task's reference count, blocking its execution, until the CUDA work is complete.</p>
<p>This is generally only required when a CPU task is expecting the results of the CUDA kernels to have been copied into host memory.</p>
<p>This mechanism is not at all not required to ensure CUDA kernels and copies are issued in the correct order. Kernel issue order is determined by normal task dependencies. The rule of thumb is to only use a blocking completion prerequisite if the task in question depends on a completed GPU-&gt;Host DMA.</p>
<p>The <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> issues a blocking event record to CUDA for the purposes of tracking the already submitted CUDA work. When this event is resolved, the <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> manually decrements the reference count of the specified task, allowing it to execute (assuming it does not have other pending prerequisites). </p>

</div>
</div>
<a class="anchor" id="a802630db052be20a94d069ad16a2e432"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxGpuDispatcher::addPostLaunchDependent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxBaseTask.html">PxBaseTask</a> &amp;&#160;</td>
          <td class="paramname"><em>dependent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a task that gets executed after the post launch task. </p>
<p>This is part of an optional feature to schedule multiple gpu features at the same time to get kernels to run in parallel. </p>
<dl class="section note"><dt>Note</dt><dd>Each call adds a reference to the pre-launch task. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5d438c6dacee88fcb9a250bc33abbe6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxGpuDispatcher::addPreLaunchDependent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxBaseTask.html">PxBaseTask</a> &amp;&#160;</td>
          <td class="paramname"><em>dependent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a gpu launch task that gets executed after the pre launch task. </p>
<p>This is part of an optional feature to schedule multiple gpu features at the same time to get kernels to run in parallel. </p>
<dl class="section note"><dt>Note</dt><dd>Each call adds a reference to the pre-launch task. </dd></dl>

</div>
</div>
<a class="anchor" id="aab184a1d948fb4ce311f2881db995633"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxGpuDispatcher::failureDetected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a CUDA call has returned a non-recoverable error. </p>
<p>A return value of true indicates a fatal error has occurred. To protect itself, the <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> enters a fall through mode that allows GpuTasks to complete without being executed. This allows simulations to continue but leaves GPU content static or corrupted.</p>
<p>The user may try to recover from these failures by deleting GPU content so the visual artifacts are mimimized. But there is no way to recover the state of the GPU actors before the failure. Once a CUDA context is in this state, the only recourse is to create a new CUDA context, a new scene, and start over.</p>
<p>This is our "Best Effort" attempt to not turn a soft failure into a hard failure because continued use of a CUDA context after it has returned an error will usually result in a driver reset. However if the initial failure was serious enough, a reset may have already occurred by the time we learn of it. </p>

</div>
</div>
<a class="anchor" id="abc22970568b130346ffc5449127889be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxGpuDispatcher::finishGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record the end of a GpuTask batch submission. </p>
<p>A <a class="el" href="classPxTaskManager.html" title="The PxTaskManager interface.">PxTaskManager</a> calls this function to notify the <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> that it is done submitting a group of GpuTasks (GpuTasks which were all make ready to run by the same prerequisite dependency becoming resolved). If no other group submissions are in progress, the <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> will execute the set of ready tasks. </p>

</div>
</div>
<a class="anchor" id="a0bb1b85b09139ca092d803b6d89d9e0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxGpuDispatcher::forceFailureMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force the <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> into failure mode. </p>
<p>This API should be used if user code detects a non-recoverable CUDA error. This ensures the <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> does not launch any further CUDA work. Subsequent calls to <a class="el" href="classPxGpuDispatcher.html#aab184a1d948fb4ce311f2881db995633" title="Returns true if a CUDA call has returned a non-recoverable error.">failureDetected()</a> will return true. </p>

</div>
</div>
<a class="anchor" id="a5ef4c36fdffc9615f61aadde7a7395bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxCudaContextManager.html">PxCudaContextManager</a>* PxGpuDispatcher::getCudaContextManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the <a class="el" href="classPxCudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">PxCudaContextManager</a> associated with this <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a>. </p>
<p>Every <a class="el" href="classPxCudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">PxCudaContextManager</a> has one <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a>, and every <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> has one <a class="el" href="classPxCudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">PxCudaContextManager</a>. </p>

</div>
</div>
<a class="anchor" id="a917458ce763a40c77e25cba385f5d987"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* PxGpuDispatcher::getCurrentProfileBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the current in-use profile buffer. </p>
<p>The returned pointer should be passed to all kernel launches to enable CTA/Warp level profiling. If a data collector is not attached, or CTA profiling is not enabled, the pointer will be zero. </p>

</div>
</div>
<a class="anchor" id="a9433c1132869548aba01f0fa2d2fb819"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxBaseTask.html">PxBaseTask</a>&amp; PxGpuDispatcher::getPostLaunchTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query post launch task that runs after the gpu is done. </p>
<p>This is part of an optional feature to schedule multiple gpu features at the same time to get kernels to run in parallel. </p>
<dl class="section note"><dt>Note</dt><dd>Do <em>not</em> set the continuation on the returned task, but use <a class="el" href="classPxGpuDispatcher.html#a802630db052be20a94d069ad16a2e432" title="Adds a task that gets executed after the post launch task.">addPostLaunchDependent()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="abc20169dcadacfc0a5849d7263f14de2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxBaseTask.html">PxBaseTask</a>&amp; PxGpuDispatcher::getPreLaunchTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query pre launch task that runs before launching gpu kernels. </p>
<p>This is part of an optional feature to schedule multiple gpu features at the same time to get kernels to run in parallel. </p>
<dl class="section note"><dt>Note</dt><dd>Do <em>not</em> set the continuation on the returned task, but use <a class="el" href="classPxGpuDispatcher.html#aa5d438c6dacee88fcb9a250bc33abbe6" title="Adds a gpu launch task that gets executed after the pre launch task.">addPreLaunchDependent()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0214929561a436c26d6ec6cbce9d3e1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxGpuDispatcher::launchCopyKernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxGpuCopyDesc.html">PxGpuCopyDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#ga07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxGpuDispatcher_8h.html#ab946c7f02e09efd788a204718015d88a">CUstream</a>&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Launch a copy kernel with arbitrary number of copy commands. </p>
<p>This method is intended to be called from Kernel GpuTasks, but it can function outside of that context as well.</p>
<p>If count is 1, the descriptor is passed to the kernel as arguments, so it may be declared on the stack.</p>
<p>If count is greater than 1, the kernel will read the descriptors out of host memory. Because of this, the descriptor array must be located in page locked (pinned) memory. The provided descriptors may be modified by this method (converting host pointers to their GPU mapped equivalents) and should be considered <em>owned</em> by CUDA until the current batch of work has completed, so descriptor arrays should not be freed or modified until you have received a completion notification.</p>
<p>If your GPU does not support mapping of page locked memory (SM&gt;=1.1), this function degrades to calling CUDA copy methods. </p>

</div>
</div>
<a class="anchor" id="a97ba1f15f2abc7c3575944c8c6eee162"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#ga1062e3989bd862873cdf0d4f7286d11d">PxU16</a> PxGpuDispatcher::registerKernelNames </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#ga1062e3989bd862873cdf0d4f7286d11d">PxU16</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register kernel names with PlatformAnalyzer. </p>
<p>The returned PxU16 must be stored and used as a base offset for the ID passed to the KERNEL_START|STOP_EVENT macros. </p>

</div>
</div>
<a class="anchor" id="abfa5f619a4c331e8de04bade660013cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxGpuDispatcher::startGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record the start of a GpuTask batch submission. </p>
<p>A <a class="el" href="classPxTaskManager.html" title="The PxTaskManager interface.">PxTaskManager</a> calls this function to notify the <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> that one or more GpuTasks are about to be submitted for execution. The <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> will not read the incoming task queue until it receives one <a class="el" href="classPxGpuDispatcher.html#abc22970568b130346ffc5449127889be" title="Record the end of a GpuTask batch submission.">finishGroup()</a> call for each <a class="el" href="classPxGpuDispatcher.html#abfa5f619a4c331e8de04bade660013cb" title="Record the start of a GpuTask batch submission.">startGroup()</a> call. This is to ensure as many GpuTasks as possible are executed together as a group, generating optimal parallelism on the GPU. </p>

</div>
</div>
<a class="anchor" id="a0450fd4af23a1d9f2b4d936dd9a2132e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxGpuDispatcher::startSimulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record the start of a simulation step. </p>
<p>A <a class="el" href="classPxTaskManager.html" title="The PxTaskManager interface.">PxTaskManager</a> calls this function to record the beginning of a simulation step. The <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> uses this notification to initialize the profiler state. </p>

</div>
</div>
<a class="anchor" id="a7e8e3086259e2b4ad5fc3dcfd8f42083"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxGpuDispatcher::stopSimulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record the end of a simulation frame. </p>
<p>A <a class="el" href="classPxTaskManager.html" title="The PxTaskManager interface.">PxTaskManager</a> calls this function to record the completion of its dependency graph. If profiling is enabled, the <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> will trigger the retrieval of profiling data from the GPU at this point. </p>

</div>
</div>
<a class="anchor" id="a86f2a53800fa9f6c9348a009fd2ace4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxGpuDispatcher::submitTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxTask.html">PxTask</a> &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a GpuTask for execution. </p>
<p>Submitted tasks are pushed onto an incoming queue. The <a class="el" href="classPxGpuDispatcher.html" title="A GpuTask dispatcher.">PxGpuDispatcher</a> will take the contents of this queue every time the pending group count reaches 0 and run the group of submitted GpuTasks as an interleaved group. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxGpuDispatcher_8h_source.html">PxGpuDispatcher.h</a></li>
</ul>
</div><!-- contents -->

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2015 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
